<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>2025회계 연차 미사용 수당 계산기</title>

  <link rel="stylesheet" href="/static/style.css" />
  <script src="https://cdn.sheetjs.com/xlsx-0.20.3/package/dist/xlsx.full.min.js"></script>

  <style>
    .msg { border:1px solid #e5e5e5; border-radius:12px; padding:10px 12px; background:#fafafa; }
    .msg.ok { border-color:#b7eb8f; background:#f6ffed; }
    .msg.warn { border-color:#ffd666; background:#fffbe6; }
    .msg.err { border-color:#ffccc7; background:#fff2f0; }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; font-size:0.92rem; border:1px solid #ddd; background:#fff; }
    .pill.ok { border-color:#b7eb8f; }
    .pill.warn { border-color:#ffd666; }
    .pill.err { border-color:#ffccc7; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size:0.95rem; background:#f3f4f6; border:1px solid #e5e7eb; padding:1px 6px; border-radius:6px; }

    details > summary { cursor:pointer; font-weight:700; color:#111; }
    details > summary:hover { text-decoration: underline; }
    .hidden { display:none !important; }

    .table-compact th, .table-compact td { padding: 6px 8px; }
    .right { text-align:right; }
    .center { text-align:center; }
    .nowrap { white-space: nowrap; }

    .stack { display:flex; flex-direction:column; gap:10px; }
    .mini { font-size:0.95rem; color:#555; }

    .danger-line { border-left: 4px solid #ff4d4f; padding-left: 10px; }
    .warn-line { border-left: 4px solid #faad14; padding-left: 10px; }

    table input[type="number"] { min-width: 90px; }
    table input[type="text"] { min-width: 120px; }
    table select { min-width: 140px; }

    .site-header .shell,
    .site-header h1,
    .site-header .subtitle { text-align:left !important; }

    /* Drag & Drop */
    .dropzone {
      border: 2px dashed #d4d4d8;
      border-radius: 14px;
      padding: 14px 16px;
      background: #fafafa;
      cursor: pointer;
      transition: all 0.15s ease;
    }
    .dropzone:hover { background:#f3f4f6; }
    .dropzone.dragover {
      border-color: #111;
      background: #eef2ff;
    }
    .dz-title { font-weight: 700; color:#111; margin:0 0 4px; }
    .dz-desc { margin:0; color:#555; font-size:0.95rem; }

    .help { font-size: 0.95rem; color:#555; }

    /* =========================
       표 틀고정(스크롤 내 고정)
       - 가로 스크롤 시: 1~2열 고정(개인번호/성명)
       - (가능하면) 세로 스크롤 시: 헤더 고정
       ========================= */
    :root{
      --sticky-col-id: 140px;   /* 나이스 개인번호 */
      --sticky-col-name: 100px; /* 성명 */
    }

    /* table-wrap이 이미 overflow를 갖고 있더라도, 안전하게 보강 */
    .table-wrap { overflow:auto; }

    /* sticky가 table에서 안정적으로 동작하도록 */
    #workersTable, #resultTable, #workOnlyResultTable, #workOnlyDetailTable, #reviewTable {
      border-collapse: separate;
      border-spacing: 0;
    }

    /* 헤더 고정 */
    #workersTable thead th,
    #resultTable thead th,
    #workOnlyResultTable thead th,
    #workOnlyDetailTable thead th,
    #reviewTable thead th {
      position: sticky;
      top: 0;
      z-index: 6;
      background: #f8fafc;
    }

    /* 공통: 1~2열 고정(개인번호/성명) */
    /* 1열 width */
    #workersTable th:nth-child(1), #workersTable td:nth-child(1),
    #resultTable th:nth-child(1),  #resultTable td:nth-child(1),
    #workOnlyResultTable th:nth-child(1), #workOnlyResultTable td:nth-child(1),
    #workOnlyDetailTable th:nth-child(1), #workOnlyDetailTable td:nth-child(1),
    #reviewTable th:nth-child(1), #reviewTable td:nth-child(1) {
      min-width: var(--sticky-col-id);
    }
    /* 2열 width */
    #workersTable th:nth-child(2), #workersTable td:nth-child(2),
    #resultTable th:nth-child(2),  #resultTable td:nth-child(2),
    #workOnlyResultTable th:nth-child(2), #workOnlyResultTable td:nth-child(2),
    #workOnlyDetailTable th:nth-child(2), #workOnlyDetailTable td:nth-child(2),
    #reviewTable th:nth-child(2), #reviewTable td:nth-child(2) {
      min-width: var(--sticky-col-name);
    }

    /* 1열 sticky */
    #workersTable th:nth-child(1), #workersTable td:nth-child(1),
    #resultTable th:nth-child(1),  #resultTable td:nth-child(1),
    #workOnlyResultTable th:nth-child(1), #workOnlyResultTable td:nth-child(1),
    #workOnlyDetailTable th:nth-child(1), #workOnlyDetailTable td:nth-child(1),
    #reviewTable th:nth-child(1), #reviewTable td:nth-child(1) {
      position: sticky;
      left: 0;
      z-index: 5;
      background: #fff;
    }
    /* 2열 sticky */
    #workersTable th:nth-child(2), #workersTable td:nth-child(2),
    #resultTable th:nth-child(2),  #resultTable td:nth-child(2),
    #workOnlyResultTable th:nth-child(2), #workOnlyResultTable td:nth-child(2),
    #workOnlyDetailTable th:nth-child(2), #workOnlyDetailTable td:nth-child(2),
    #reviewTable th:nth-child(2), #reviewTable td:nth-child(2) {
      position: sticky;
      left: var(--sticky-col-id);
      z-index: 5;
      background: #fff;
      /* 고정 영역 오른쪽 경계선 느낌 */
      box-shadow: 2px 0 0 #e5e7eb;
    }

    /* 헤더와 좌측고정이 겹치는 셀은 더 위로 */
    #workersTable thead th:nth-child(1),
    #workersTable thead th:nth-child(2),
    #resultTable thead th:nth-child(1),
    #resultTable thead th:nth-child(2),
    #workOnlyResultTable thead th:nth-child(1),
    #workOnlyResultTable thead th:nth-child(2),
    #workOnlyDetailTable thead th:nth-child(1),
    #workOnlyDetailTable thead th:nth-child(2),
    #reviewTable thead th:nth-child(1),
    #reviewTable thead th:nth-child(2) {
      z-index: 9;
      background: #f8fafc;
    }
  </style>
</head>

<body>
  <header class="site-header">
    <div class="shell">
      <h1>2025회계 교육공무직 연차 미사용 수당 계산기</h1>
      <p class="subtitle">
        ·2025회계에 부여된 연차 일수 중에서 미사용분에 대해 연차 미사용 수당을 산정 (통상임금: 2026.2월 기준) <br/>
        ·연차 사용 집계 기간: 2025.3.1.~2026.2.28.<br/>
        ※ 업로드한 파일은 저장되지 않습니다. 서버랑 DB 없음<br/>
      </p>
    </div>
  </header>

  <main class="container">

    <section class="section">
      <h2>1. 인사 정보 입력</h2>
      <p class="muted">
        ·나이스 "교육공무직등인사 -인사기록(교육공무직) -인사기록관리 -인사기록(인사권한-조회)"에서 엑셀 파일 다운로드 가능<br/>
        ·인사기록 파일 여러 개 업로드 가능 <br/>
        ※ 1행에 적힌 항목 열 삭제 없이 다운받은 파일 그대로 올려주십시오. <br/>
      </p>

      <div class="card">
        <div class="grid two">
          <div>
            <div class="dropzone" id="hrDrop">
              <p class="dz-title">엑셀 파일 업로드하기</p>
              <p class="dz-desc">(파일 드래그 가능)</p>
            </div>
            <input type="file" id="hrFile" accept=".xlsx,.xls" class="hidden" multiple />

            <div class="row gap" style="margin-top:10px;">
              <button class="btn primary" id="btnLoadHr">인사정보 내역추출</button>
              <button class="btn" id="btnClearAll">초기화하기</button>
            </div>
            <div id="hrMsg" class="msg" style="margin-top:12px;"></div>
          </div>
        </div>

        <div class="table-wrap">
          <table class="sheetlike table-compact" id="workersTable">
            <thead>
              <tr>
                <th class="nowrap">나이스 개인번호</th>
                <th class="nowrap">성명</th>
                <th class="nowrap">직종</th>
                <th class="nowrap">최초임용일</th>
                <th class="nowrap right">1일 소정근무시간</th>
                <th class="nowrap right">주당 소정근무시간</th>
                <th class="nowrap right">근속년수(2026.2.28. 기준)</th>
                <th class="nowrap right">2025회계 부여 연차일수</th>
                <th class="nowrap right">통상임금 반영 기타수당(월)</th>
                <th class="nowrap right">시간당 통상임금 수기 입력</th>
                <th class="nowrap center">삭제하기</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>

        <div class="msg" style="margin-top:10px;">
          <div>연차 미사용수당 산정 기준일자는 2026.2.28.로 고정해둠</div>
          <div class="muted">※ 2025회계에 부여받은 연차의 미사용분은 "사용기간이 종료되는 달"인 2026.2월의 통상임금을 기준으로 산정함.</div>
        </div>
      </div>
    </section>

    <section class="section">
      <h2>2. 근무상황 업로드</h2>
      <p class="muted">
        ·개별 근로자 조회하지 않고 교내 교육공무직 전체 복무 섞인 파일 올려도 됨니다. 알아서 추출함. <br/>
        ·나이스 복무에서 근무상황 조회내역 엑셀 파일 원자료 그대로 업로드. <br/>
      </p>

      <div class="card">
        <div class="grid two">
          <div>
            <div class="dropzone" id="workDrop">
              <p class="dz-title">엑셀 파일 업로드 (CSV가능)</p>
              <p class="dz-desc">(파일 드래그 가능)</p>
            </div>
            <input type="file" id="workFiles" accept=".xlsx,.xls,.csv" multiple class="hidden" />

            <div class="row gap" style="margin-top:10px;">
              <button class="btn primary" id="btnLoadWork">연차 사용내역 집계</button>
              <button class="btn" id="btnClearWork">근무상황 초기화</button>
            </div>

            <!-- (추가) 인사기록 기반 매칭 옵션 -->
            <div class="row gap" style="margin-top:10px;">
              <label class="row">
                <input type="checkbox" id="optIncludeWorkOnly" />
                인사기록에는 없고 복무상황에만 있는 사람도 집계/계산에 포함합니다.
              </label>
            </div>
            <div class="muted">
              ※ 기본값: <b>인사기록 조회내역 기준으로만</b> 집계합니다. (체크 해제 시, 인사기록에 없는 인원은 아래 결과의 ‘별도’ 표로만 표시)
            </div>

            <div id="workMsg" class="msg" style="margin-top:12px;"></div>
          </div>
        </div>

        <details id="reviewBox" class="card hidden" style="margin-top:12px;">
          <summary>검토 필요 목록</summary>
          <div class="muted" style="margin-top:8px;">
            ·확인 후에 수동으로 분류하십시오.
          </div>
          <div class="table-wrap">
            <table class="sheetlike table-compact" id="reviewTable">
              <thead>
                <tr>
                  <th class="nowrap">근로자 성명</th>
                  <th class="nowrap">나이스 개인번호</th>
                  <th class="nowrap">복무 유형</th>
                  <th class="nowrap">복무 사용 기간</th>
                  <th class="nowrap">시간 및 일수</th>
                  <th class="nowrap right">수기 입력(분단위)</th>
                  <th class="nowrap center">반영하기</th>
                  <th class="nowrap">파일</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </details>
      </div>
    </section>

    <section class="section">
      <h2>3. 통상임금 설정</h2>

      <div class="card">
        <div class="row gap">
          <label class="row"><input type="checkbox" id="optIncludeBonus" /> 정기상여금을 통상임금에 포함합니다. </label>
        </div>

        <div class="row gap" style="margin-top:8px;">
          <label class="row"><input type="checkbox" id="optIncludeHoliday" /> 명절휴가비를 통상임금에 포함합니다. </label>
        </div>

        <div class="msg" style="margin-top:10px;">
          <div><b>주40시간 근무 기준 기본 설정값 (2025회계 보수표 반영) </b></div>
          <ul>
            <li>기본급: 1유형 2,266,000원 / 2유형 2,066,000원</li>
            <li>정액급식비: 150,000원</li>
            <li>근속수당: 1년당 40,000원 (상한 23년)</li>
            <li>정기상여금(연간): 기본 1,000,000원 / 특수운영직군(일부) 500,000원</li>
            <li>명절휴가비(연간): 1,850,000원</li>
          </ul>
          <div class="muted">※ 금액 변동사항 발생 시 아래의 "▶변동내역 수기 입력"을 펼쳐서 입력하십시오. </div>
        </div>

        <details style="margin-top:10px;">
          <summary>변동내역 수기 입력</summary>

          <div class="grid three" style="margin-top:10px;">
            <label class="stack">
              <span class="mini">1유형 기본급(주40시간)</span>
              <input type="number" id="cType1" class="numeric" />
            </label>
            <label class="stack">
              <span class="mini">2유형 기본급(주40시간)</span>
              <input type="number" id="cType2" class="numeric" />
            </label>
            <label class="stack">
              <span class="mini">1유형 미만 기본급(주40시간)</span>
              <input type="number" id="cType1Under" class="numeric" />
            </label>

            <label class="stack">
              <span class="mini">교육복지사(기관) 기본급(주40시간)</span>
              <input type="number" id="cWelfareInst" class="numeric" />
            </label>
            <label class="stack">
              <span class="mini">임상/대안 기본급(주40시간)</span>
              <input type="number" id="cClinical" class="numeric" />
            </label>
            <label class="stack">
              <span class="mini">학습/학부모 기본급(주40시간)</span>
              <input type="number" id="cClinic" class="numeric" />
            </label>

            <label class="stack">
              <span class="mini">진학전문지원관 기본급(주40시간)</span>
              <input type="number" id="cJinhak" class="numeric" />
            </label>
            <label class="stack">
              <span class="mini">학교운동부지도자 기본급(주40시간)</span>
              <input type="number" id="cSports" class="numeric" />
            </label>
            <label class="stack">
              <span class="mini">정액급식비(월)</span>
              <input type="number" id="cMeal" class="numeric" />
            </label>

            <label class="stack">
              <span class="mini">근속수당 (1년당 단가)</span>
              <input type="number" id="cServiceStep" class="numeric" />
            </label>
            <label class="stack">
              <span class="mini">근속수당 상한년도</span>
              <input type="number" id="cServiceCap" class="numeric" />
            </label>
            <label class="stack">
              <span class="mini">정기상여금(일반, 연간)</span>
              <input type="number" id="cBonusDefault" class="numeric" />
            </label>

            <label class="stack">
              <span class="mini">정기상여금(특수운영직군, 연간)</span>
              <input type="number" id="cBonusSpecial1" class="numeric" />
            </label>
            <label class="stack">
              <span class="mini">명절휴가비(연간)</span>
              <input type="number" id="cHoliday" class="numeric" />
            </label>
            <label class="stack">
              <span class="mini">초단시간 특수운영직군 시급 (주15시간 미만)</span>
              <input type="number" id="cSpecialHourly" class="numeric" />
            </label>
          </div>

          <div class="row gap" style="margin-top:10px;">
            <button class="btn" id="btnResetConstants">기본값으로 되돌리기</button>
            <button class="btn primary" id="btnApplyConstants">변경 설정 반영하기</button>
          </div>

          <div id="constMsg" class="msg" style="margin-top:10px;"></div>
        </details>
      </div>
    </section>

    <section class="section">
      <h2>4. 2025회계 연차 미사용수당 계산 결과</h2>

      <div class="card">
        <div class="row gap">
          <button class="btn primary" id="btnRun">연차 미사용수당 계산하기</button>
          <button class="btn" id="btnDownload">산출 결과 엑셀로 저장하기</button>
        </div>
        <div id="runMsg" class="msg" style="margin-top:12px;"></div>
      </div>

      <div id="resultSummary" class="msg">아직 계산 내역 없음</div>

      <div class="table-wrap">
        <table class="sheetlike table-compact" id="resultTable">
          <thead>
            <tr>
              <th class="nowrap">나이스 개인번호</th>
              <th class="nowrap">성명</th>
              <th class="nowrap">직종</th>
              <th class="nowrap right">연차유급휴가 부여일수</th>
              <th class="nowrap right">연차 사용일수 (일/시/분)</th>
              <th class="nowrap right">연차 미사용일수 (일/시/분)</th>
              <th class="nowrap right">통상임금 (2026.2.28. 기준)</th>
              <th class="nowrap right">2025회계 연차 미사용수당</th>
              <th class="nowrap">비고</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>

      <!-- (추가) 인사기록 미존재(복무상황만) 인원: 별도 표 -->
      <details id="workOnlyBox" class="card hidden" style="margin-top:12px;">
        <summary>인사기록에는 없고 복무상황에만 있는 인원(별도 표시)</summary>

        <div id="workOnlySummary" class="msg" style="margin-top:10px;"></div>

        <div class="table-wrap">
          <table class="sheetlike table-compact" id="workOnlyResultTable">
            <thead>
              <tr>
                <th class="nowrap">나이스 개인번호</th>
                <th class="nowrap">성명</th>
                <th class="nowrap">직종(수기)</th>
                <th class="nowrap">최초임용일(수기)</th>
                <th class="nowrap right">1일 소정근무시간</th>
                <th class="nowrap right">주당 소정근무시간</th>
                <th class="nowrap right">2025회계 부여 연차일수</th>
                <th class="nowrap right">연차 사용일수 (일/시/분)</th>
                <th class="nowrap right">연차 미사용일수 (일/시/분)</th>
                <th class="nowrap right">통상임금 (2026.2.28. 기준)</th>
                <th class="nowrap right">2025회계 연차 미사용수당</th>
                <th class="nowrap">비고</th>
                <th class="nowrap center">삭제하기</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>

        <details class="card" style="margin-top:12px;">
          <summary>복무상황 원본(인사기록 미존재 인원) 세부내역</summary>
          <div class="table-wrap">
            <table class="sheetlike table-compact" id="workOnlyDetailTable">
              <thead>
                <tr>
                  <th class="nowrap">나이스 개인번호</th>
                  <th class="nowrap">성명</th>
                  <th class="nowrap">복무 유형</th>
                  <th class="nowrap">복무 사용 기간</th>
                  <th class="nowrap right">사용(일/시/분)</th>
                  <th class="nowrap right">사용분</th>
                  <th class="nowrap">판독방법</th>
                  <th class="nowrap">원본값</th>
                  <th class="nowrap">파일</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </details>
      </details>

      <details class="card" style="margin-top:12px;">
        <summary>개인별 연차 사용내역 상세보기</summary>
        <div id="detailBox" class="stack" style="margin-top:10px;"></div>
      </details>
    </section>

  </main>

  <div class="home-link-wrap">
    <a class="btn" href="/">메인으로 돌아가기</a>
  </div>

<script>
(() => {
  "use strict";

  // 기간(고정): 2025회계(학년도 기준)
  const PERIOD_START = ymdToUTC("2025-03-01");
  const PERIOD_END   = ymdToUTC("2026-02-28"); // inclusive

  // 2024회계 마지막날(2025.2.28)의 다음날을 기준으로 부여 -> 2025.3.1 (참고용)
  const GRANT_DATE   = ymdToUTC("2025-03-01");

  // 미사용 수당 산정 기준 통상임금: 2026.2월(사용기간 종료월) 기준
  const PAY_WAGE_DATE = ymdToUTC("2026-02-28");

  const DEFAULT_DAILY_HOURS = 8;

  // 깊은 복사(브라우저 호환)
  const deepClone = (obj) => {
    if (typeof structuredClone === "function") return structuredClone(obj);
    return JSON.parse(JSON.stringify(obj));
  };

  // 통상임금 계산용 기본 상수(2025 보수표 기반)
  const DEFAULT_CONST = {
    basePay40: {
      type1: 2266000,
      type2: 2066000,
      type1Under: 2167610,
      welfareInst: 2667280,
      clinical: 2725350,
      clinic: 2569280,
      jinhak: 3566500,
      sports: 2287390,
    },
    mealAllowance: 150000,
    serviceStep: 40000,
    serviceCapYears: 23,
    annualBonusDefault: 1000000,
    annualBonusSpecial1: 500000,
    annualHoliday: 1850000,
    specialHourly: 11200,

    // 직무관련수당(대표적인 것만)
    hazardAllowance: 50000,      // 조리사/조리실무사 위험수당
    mealOpsAllowance: 50000,     // 영양사 급식운영수당
    techInfoAllowance: 20000,    // 영양사 기술정보수당(면허가산 미수령 시)
    specialDutyLibrarian: 20000, // 학교도서관사서(면허)
    specialDutyWelfare: 20000,   // 교육복지사(학교)
    specialDutyOld: 50000,       // 구육성회직원
  };

  // 직종 분류(기본급 유형 판별)
  const JOB_KEYWORDS = {
    type1: [
      "치료사","장애영아지도사","장애유아지도사","직업지도사","유치원방과후교육사",
      "학교도서관사서","기숙사생활지도원","전문상담사","영양사","평생교육사","사회복지사","진로교육사",
      "교육복지사"
    ],
    type2: [
      "학교도서관실무사","특수교육지도사","건강실무사","조리실무사","조리사",
      "초등돌봄전담사","방과후전담사","교무행정사","발명실무원",
      "통학차량운전원","통학지도원","늘봄학교전담사"
    ],
    type1Under: ["교육지도사","방과후학교지원가"],
    type1Over: [
      "임상심리사","대안교육전문가","교육복지사(기관)","학습클리닉전문가","학부모지원전문가",
      "진학전문지원관","학교운동부지도자"
    ],
    special1: ["학교보안관","청소원","당직전담원","출입문개폐전담원","열람실관리원"],
    special2: ["객실청소원","청사안내원","시설관리원","콜센터상담원"],
  };

  const state = {
    workers: new Map(),          // HR(인사기록) 기반
    workOnlyWorkers: new Map(),  // 복무상황에만 있고 인사기록에는 없는 인원(별도)
    leaveRecords: [],            // 집계된 연차성 복무 레코드
    reviewRecords: [],           // 검토 필요 레코드(수기 분 입력)
    lastRunAt: null,
    options: {
      includeBonus: false,
      includeHoliday: false,
      includeWorkOnly: false,    // (추가) 인사기록 미존재 인원도 집계/계산 포함
    },
    constants: deepClone(DEFAULT_CONST),

    selectedFiles: {
      hr: [],
      work: [],
    }
  };

  const $ = (sel) => document.querySelector(sel);
  const $$ = (sel) => Array.from(document.querySelectorAll(sel));

  function setMsg(el, cls, html) {
    el.className = `msg ${cls || ""}`.trim();
    el.innerHTML = html;
  }

  function escapeHtml(s) {
    return String(s ?? "")
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  function ymdToUTC(ymd) {
    const [y, m, d] = ymd.split("-").map(Number);
    return new Date(Date.UTC(y, m - 1, d));
  }

  function utcToYmd(date) {
    const y = date.getUTCFullYear();
    const m = String(date.getUTCMonth() + 1).padStart(2, "0");
    const d = String(date.getUTCDate()).padStart(2, "0");
    return `${y}-${m}-${d}`;
  }

  function addDaysUTC(date, days) {
    return new Date(date.getTime() + days * 86400000);
  }

  function isWeekendUTC(date) {
    const wd = date.getUTCDay();
    return wd === 0 || wd === 6; // 일/토
  }

  function clampToPeriod(date) {
    if (date < PERIOD_START) return PERIOD_START;
    if (date > PERIOD_END) return PERIOD_END;
    return date;
  }

  function normalizeRange(start, end) {
    if (!start || !end) return null;
    if (end < start) [start, end] = [end, start];

    const s = clampToPeriod(start);
    const e = clampToPeriod(end);
    if (e < PERIOD_START || s > PERIOD_END) return null;
    return { start: s, end: e };
  }

  function computeServiceYearsAt(baseUTC, hireUTC) {
    if (!baseUTC || !hireUTC) return 0;
    const y = baseUTC.getUTCFullYear() - hireUTC.getUTCFullYear();
    const m = baseUTC.getUTCMonth() - hireUTC.getUTCMonth();
    const d = baseUTC.getUTCDate() - hireUTC.getUTCDate();
    let years = y;
    if (m < 0 || (m === 0 && d < 0)) years -= 1;
    return Math.max(0, years);
  }

  function formatMoney(n) {
    const v = Number(n || 0);
    return v.toLocaleString("ko-KR");
  }

  function safeNum(v, fallback = 0) {
    const n = Number(String(v ?? "").replace(/[^0-9.\-]/g, ""));
    return Number.isFinite(n) ? n : fallback;
  }

  /**
   * (수정) 인사기록/근무기록에 자주 나오는 "40시간00분" 같은 값을
   * 숫자 시간(40)으로 안전하게 변환.
   *
   * - "40시간00분" -> 40
   * - "14시간00분" -> 14
   * - "7시간30분"  -> 7.5
   * - "480분"      -> 8
   * - "8:30"       -> 8.5
   * - "4000"       -> 40 (휴리스틱: 100으로 나눔)
   */
  function parseWorkTimeHours(v) {
    if (v == null) return null;

    if (typeof v === "number") {
      const n = Number(v);
      return Number.isFinite(n) ? n : null;
    }

    const s = String(v || "").trim();
    if (!s) return null;

    // 40시간00분 / 7시간 30분 / 4시간 등
    const mhm = s.match(/(-?\d+(?:\.\d+)?)\s*시간\s*(\d+(?:\.\d+)?)?\s*분?/);
    if (mhm) {
      const h = Number(mhm[1]);
      const m = mhm[2] != null ? Number(mhm[2]) : 0;
      if (Number.isFinite(h) && Number.isFinite(m)) return h + (m / 60);
      if (Number.isFinite(h)) return h;
    }

    // 480분 형태
    const mm = s.match(/(-?\d+(?:\.\d+)?)\s*분/);
    if (mm && !s.includes("시간")) {
      const mins = Number(mm[1]);
      if (Number.isFinite(mins)) return mins / 60;
    }

    // 8:30 형태
    const mt = s.match(/(\d{1,2}):(\d{2})/);
    if (mt) {
      const hh = Number(mt[1]);
      const mn = Number(mt[2]);
      if (Number.isFinite(hh) && Number.isFinite(mn)) return hh + (mn / 60);
    }

    // 숫자만 남는 케이스 방어
    const n = safeNum(s, NaN);
    if (Number.isFinite(n)) {
      // 4000 -> 40, 800 -> 8 같은 케이스
      if (n >= 100 && n % 100 === 0) return n / 100;
      // 480 -> 8 같은 분 단위 케이스(휴리스틱)
      if (n > 24 && n <= 1440 && n % 60 === 0) return n / 60;
      return n;
    }

    return null;
  }

  function workerKeyOf(name, pid) {
    const p = String(pid || "").trim();
    if (p) return p;
    return String(name || "").trim();
  }

  function getWorkerByKey(key) {
    return state.workers.get(key) || state.workOnlyWorkers.get(key) || null;
  }

  function ensureXLSX() {
    if (typeof XLSX === "undefined") {
      throw new Error("XLSX 라이브러리를 찾을 수 없습니다. (CDN 차단 여부 확인 필요)");
    }
  }

  function readFileAsArrayBuffer(file) {
    return new Promise((resolve, reject) => {
      const fr = new FileReader();
      fr.onload = () => resolve(fr.result);
      fr.onerror = () => reject(new Error("파일 읽기 실패"));
      fr.readAsArrayBuffer(file);
    });
  }

  function sheetToJson(workbook) {
    const sheetName = workbook.SheetNames[0];
    const ws = workbook.Sheets[sheetName];
    return XLSX.utils.sheet_to_json(ws, { header: 1, raw: false, defval: "" });
  }

  function normalizeHeader(s) {
    return String(s || "").replace(/\s+/g, "").replace(/[()]/g, "").toLowerCase();
  }

  function findHeaderRow(rows, mustHaveAny) {
    let bestIdx = -1;
    let bestScore = -1;

    for (let i = 0; i < Math.min(rows.length, 30); i++) {
      const row = rows[i];
      if (!Array.isArray(row)) continue;

      const nh = row.map(normalizeHeader);
      const joined = nh.join("|");
      const hit = mustHaveAny.some(k => joined.includes(normalizeHeader(k)));
      if (!hit) continue;

      const score = nh.filter(x => x && x.length >= 2).length;
      if (score > bestScore) {
        bestScore = score;
        bestIdx = i;
      }
    }
    return bestIdx;
  }

  function findColumnIndex(headers, candidates) {
    const nh = headers.map(normalizeHeader);

    for (const c of candidates) {
      const nc = normalizeHeader(c);
      const idx = nh.findIndex(h => h === nc);
      if (idx >= 0) return idx;
    }

    for (const c of candidates) {
      const nc = normalizeHeader(c);
      const idx = nh.findIndex(h => h.includes(nc) || nc.includes(h));
      if (idx >= 0) return idx;
    }

    return -1;
  }

  function parseDateLoose(v) {
    const s = String(v || "").trim();
    if (!s) return null;

    // 2025.3.1 / 2025-03-01 / 2025/03/01
    const m = s.match(/(\d{4})[.\-/](\d{1,2})[.\-/](\d{1,2})/);
    if (m) {
      const y = Number(m[1]);
      const mo = Number(m[2]);
      const d = Number(m[3]);
      return new Date(Date.UTC(y, mo - 1, d));
    }
    return null;
  }

  function parseRangeLoose(s) {
    const str = String(s||"").trim();
    if (!str) return null;
    const parts = str.split(/~|〜/).map(x => x.trim()).filter(Boolean);
    if (parts.length === 2) {
      const a = parseDateLoose(parts[0]);
      const b = parseDateLoose(parts[1]);
      if (a && b) return { start: a, end: b };
    }
    const d = parseDateLoose(str);
    if (d) return { start: d, end: d };
    return null;
  }

  function normalizeText(s) {
    return String(s || "").replace(/\s+/g, "").trim();
  }

  function classifyLeaveType(typeRaw) {
    const t = normalizeText(typeRaw);
    if (!t) return null;

    // 병가/병지각/병조퇴/병외출 등 배제
    if (/(병가|병지각|병조퇴|병외출|유급병가|무급병가|질병)/.test(t) || t.startsWith("병")) {
      return null;
    }

    // 반일연차(반차) 처리
    if (t.includes("반일연차") || t.includes("반차") || t.includes("반일연가")) return "HALF";

    // 연차(연가) 처리
    if (t.includes("연차") || t === "연가" || t.includes("연가")) return "FULL";

    if (t.includes("지각")) return "LATE";
    if (t.includes("조퇴")) return "EARLY";
    if (t.includes("외출")) return "OUT";

    return null;
  }

  function parseTimeToMinutes(str) {
    const s = String(str||"").trim();
    const m = s.match(/(\d{1,2}):(\d{2})/);
    if (!m) return null;
    const hh = Number(m[1]);
    const mm = Number(m[2]);
    if (!Number.isFinite(hh) || !Number.isFinite(mm)) return null;
    return hh * 60 + mm;
  }

  function parseDurationToMinutes(cell, dailyMinutes) {
    const s = String(cell || "").trim();
    if (!s) return null;

    // 0.5일, 1일, 2.0일 등 / "1일 2시간 30분" 등
    let days = null;
    const md = s.match(/(-?\d+(?:\.\d+)?)\s*일/);
    if (md) days = Number(md[1]);

    let hours = null;
    const mh = s.match(/(-?\d+(?:\.\d+)?)\s*시간/);
    if (mh) hours = Number(mh[1]);

    let mins = null;
    const mm = s.match(/(-?\d+(?:\.\d+)?)\s*분/);
    if (mm) mins = Number(mm[1]);

    if (md || mh || mm) {
      let total = 0;
      if (days != null && Number.isFinite(days)) total += days * dailyMinutes;
      if (hours != null && Number.isFinite(hours)) total += hours * 60;
      if (mins != null && Number.isFinite(mins)) total += mins;
      return Math.round(total);
    }

    return null;
  }

  function countWorkdaysInRange(startUTC, endUTC) {
    let count = 0;
    for (let d = startUTC; d <= endUTC; d = addDaysUTC(d, 1)) {
      if (isWeekendUTC(d)) continue;
      count += 1;
    }
    return count;
  }

  function computeMonthlyHours(weeklyHours, dailyHours) {
    const wh = Number(weeklyHours || 0);
    const dh = Number(dailyHours || 0);
    if (!(wh > 0) || !(dh > 0)) return 209;

    // 주휴 1일분(일 근로시간) 포함하여 월 환산(근사)
    const weeklyTotal = wh + dh;
    const approx = (weeklyTotal / 7) * (365 / 12);
    return Math.round(approx);
  }

  // =============================
  // 인사정보 로딩(다중 파일)
  // =============================
  async function loadHrFile(file) {
    ensureXLSX();
    const buf = await readFileAsArrayBuffer(file);
    const wb = XLSX.read(buf, { type: "array" });
    const rows = sheetToJson(wb);

    const headerIdx = findHeaderRow(rows, ["성명", "직종", "최초임용일", "개인번호"]);
    if (headerIdx < 0) throw new Error(`[${file.name}] 인사기록 파일에서 헤더 행을 찾지 못했습니다. (원자료 그대로인지 확인)`);

    const headers = rows[headerIdx].map(x => String(x || "").trim());
    const dataRows = rows.slice(headerIdx + 1).filter(r => Array.isArray(r) && r.some(x => String(x||"").trim() !== ""));

    const colName = findColumnIndex(headers, ["성명","이름"]);
    const colPid  = findColumnIndex(headers, ["나이스개인번호","개인번호","사번","인적번호","개인번호(아이디)"]);
    const colHire = findColumnIndex(headers, ["최초임용일","근무시작일","임용일","최초계약일","계약시작일"]);
    const colJob  = findColumnIndex(headers, ["직종","직종명","직무","직무명"]);
    const colDailyH = findColumnIndex(headers, ["1일근로시간","일근로시간","1일소정근로시간"]);
    const colWeeklyH = findColumnIndex(headers, ["주소정근로시간","주당근로시간","주근무시간","주소정근로시간(시간)"]);

    if (colName < 0) throw new Error(`[${file.name}] [성명] 컬럼을 찾지 못했습니다.`);

    let loaded = 0;
    let skipped = 0;

    for (const row of dataRows) {
      const name = String(row[colName] || "").trim();
      if (!name) { skipped++; continue; }

      const pid = (colPid >= 0) ? String(row[colPid] || "").trim() : "";
      const key = workerKeyOf(name, pid);

      const hire = (colHire >= 0) ? parseDateLoose(row[colHire]) : null;
      const job = (colJob >= 0) ? String(row[colJob] || "").trim() : "";

      let weeklyHours = null;
      if (colWeeklyH >= 0) {
        // "40시간00분" -> 40
        const v = parseWorkTimeHours(row[colWeeklyH]);
        if (Number.isFinite(v) && v > 0) weeklyHours = v;
      }

      let dailyHours = DEFAULT_DAILY_HOURS;
      if (colDailyH >= 0) {
        // "8시간00분" -> 8
        const v = parseWorkTimeHours(row[colDailyH]);
        if (Number.isFinite(v) && v > 0) dailyHours = v;
      } else if (weeklyHours != null) {
        dailyHours = Math.round((weeklyHours / 5) * 10) / 10;
      }

      if (weeklyHours == null) {
        weeklyHours = Math.round((dailyHours * 5) * 10) / 10;
      }

      // (추가) HR 업로드 시, 기존에 workOnly로 잡힌 인원이면 정보 병합 후 workOnly에서 제거
      const prev = state.workers.get(key) || state.workOnlyWorkers.get(key);

      const merged = prev ? { ...prev } : {
        key,
        pid,
        name,
        job,
        hireDateUTC: hire,
        dailyHours,
        weeklyHours,
        grantedDays: null,
        customMonthlyAllowance: 0,
        hourlyOverride: null,
        flags: {},
      };

      // 기존 입력을 최대한 보존하면서, HR에서 확보된 값으로 보강
      merged.pid = pid || merged.pid;
      merged.name = name || merged.name;
      merged.job = job || merged.job;
      merged.hireDateUTC = hire || merged.hireDateUTC;
      merged.dailyHours = dailyHours || merged.dailyHours;
      merged.weeklyHours = weeklyHours || merged.weeklyHours;

      // 영양사 기본: 면허가산수당 받는다고 가정(필요시 코드 확장 가능)
      if ((merged.job || "").includes("영양사")) {
        if (merged.flags.nutritionLicense == null) merged.flags.nutritionLicense = true;
      }

      state.workers.set(key, merged);
      if (state.workOnlyWorkers.has(key)) state.workOnlyWorkers.delete(key);

      loaded++;
    }

    return { loaded, skipped };
  }

  async function handleLoadHrFiles(files) {
    if (!files || files.length === 0) {
      setMsg($("#hrMsg"), "err", "인사기록 파일을 선택하거나 드래그하여 업로드하세요.");
      return;
    }

    let totalLoaded = 0;
    let totalSkipped = 0;
    const fail = [];

    for (const f of files) {
      try {
        const out = await loadHrFile(f);
        totalLoaded += out.loaded;
        totalSkipped += out.skipped;
      } catch (e) {
        fail.push(`${f.name}: ${e.message}`);
      }
    }

    renderWorkersTable();
    renderWorkOnlyBox(null); // HR 업데이트 후, 별도표도 갱신

    const failHtml = fail.length
      ? `<div class="msg err" style="margin-top:10px;"><b>실패 파일</b><ul>${fail.map(x => `<li>${escapeHtml(x)}</li>`).join("")}</ul></div>`
      : "";

    setMsg($("#hrMsg"), fail.length ? "warn" : "ok", `
      <div><b>인사정보 추출 완료</b></div>
      <ul>
        <li>처리 파일: ${files.length}개</li>
        <li>로드(행 기준): ${totalLoaded}건</li>
        <li>스킵(빈 성명 등): ${totalSkipped}건</li>
      </ul>
      <div class="muted">※ 동일 인원이 여러 파일에 있으면, 정보는 병합(보강)됩니다.</div>
      ${failHtml}
    `);

    if (state.lastRunAt) runCalculation(false);
  }

  function renderWorkersTable() {
    const tbody = $("#workersTable tbody");
    tbody.innerHTML = "";

    const arr = Array.from(state.workers.values())
      .sort((a,b) => (a.name||"").localeCompare(b.name||"", "ko"));

    for (const w of arr) {
      const tr = document.createElement("tr");
      const serviceYears = computeServiceYearsAt(PAY_WAGE_DATE, w.hireDateUTC);

      tr.innerHTML = `
        <td class="nowrap">${escapeHtml(w.key)}</td>
        <td class="nowrap">${escapeHtml(w.name||"")}</td>
        <td class="nowrap">${escapeHtml(w.job||"")}</td>
        <td class="nowrap">${w.hireDateUTC ? utcToYmd(w.hireDateUTC) : ""}</td>
        <td class="right nowrap">${escapeHtml(String(w.dailyHours ?? DEFAULT_DAILY_HOURS))}</td>
        <td class="right nowrap">${escapeHtml(String(w.weeklyHours ?? (Number(w.dailyHours||DEFAULT_DAILY_HOURS)*5)))}</td>
        <td class="right nowrap">${serviceYears}년</td>
        <td class="right nowrap">
          <input type="number" step="0.1" min="0" class="numeric" data-wk="${escapeHtml(w.key)}" data-field="grantedDays"
                 value="${w.grantedDays ?? ""}" placeholder="예: 15" />
        </td>
        <td class="right nowrap">
          <input type="number" step="10" min="0" class="numeric" data-wk="${escapeHtml(w.key)}" data-field="customMonthlyAllowance"
                 value="${Number(w.customMonthlyAllowance||0) ? String(w.customMonthlyAllowance) : ""}" placeholder="0" />
        </td>
        <td class="right nowrap">
          <input type="number" step="1" min="0" class="numeric" data-wk="${escapeHtml(w.key)}" data-field="hourlyOverride"
                 value="${w.hourlyOverride ?? ""}" placeholder="자동" />
        </td>
        <td class="center nowrap"><button class="btn btn-lightgrey" data-del="${escapeHtml(w.key)}">삭제</button></td>
      `;
      tbody.appendChild(tr);
    }

    tbody.querySelectorAll("input[data-wk]").forEach(inp => {
      inp.addEventListener("change", () => {
        const key = inp.getAttribute("data-wk");
        const field = inp.getAttribute("data-field");
        const w = state.workers.get(key);
        if (!w) return;

        if (field === "grantedDays") {
          const v = inp.value.trim();
          w.grantedDays = v === "" ? null : safeNum(v, null);
        }
        if (field === "customMonthlyAllowance") {
          const v = inp.value.trim();
          w.customMonthlyAllowance = v === "" ? 0 : safeNum(v, 0);
        }
        if (field === "hourlyOverride") {
          const v = inp.value.trim();
          w.hourlyOverride = v === "" ? null : safeNum(v, null);
        }

        state.workers.set(key, w);
        if (state.lastRunAt) runCalculation(false);
      });
    });

    tbody.querySelectorAll("button[data-del]").forEach(btn => {
      btn.addEventListener("click", () => {
        const key = btn.getAttribute("data-del");
        state.workers.delete(key);
        state.leaveRecords = state.leaveRecords.filter(r => r.workerKey !== key);
        state.reviewRecords = state.reviewRecords.filter(r => r.workerKey !== key);
        renderWorkersTable();
        renderReviewRecords();
        renderWorkOnlyBox(null);
        if (state.lastRunAt) runCalculation(false);
      });
    });

    if (!arr.length) {
      setMsg($("#hrMsg"), "warn", "인사정보를 업로드해주세요.");
    }
  }

  // =============================
  // 근무상황 로딩(연차 사용 집계)
  // =============================
  async function loadWorkFiles(files) {
    ensureXLSX();
    if (!files || files.length === 0) throw new Error("근무상황 파일이 선택되지 않았습니다.");

    // 초기화 후 다시 집계(중복 집계 방지)
    state.leaveRecords = [];
    state.reviewRecords = [];
    state.workOnlyWorkers.clear(); // (추가) workOnly 인원은 근무상황 집계 기준으로 재생성

    let totalRows = 0;
    let usedRows = 0;
    let reviewRows = 0;
    let workOnlyCount = 0;

    for (const file of files) {
      const ext = (file.name.split(".").pop() || "").toLowerCase();

      if (ext === "csv") {
        const text = await file.text();
        const rows = csvToRows(text);
        const out = parseWorkRows(rows, file.name);
        totalRows += out.totalRows;
        usedRows += out.usedRows;
        reviewRows += out.reviewRows;
        workOnlyCount += out.workOnlyCreated;
        continue;
      }

      const buf = await readFileAsArrayBuffer(file);
      const wb = XLSX.read(buf, { type: "array" });
      const rows = sheetToJson(wb);
      const out = parseWorkRows(rows, file.name);
      totalRows += out.totalRows;
      usedRows += out.usedRows;
      reviewRows += out.reviewRows;
      workOnlyCount += out.workOnlyCreated;
    }

    renderReviewRecords();
    renderWorkersTable();

    setMsg($("#workMsg"), "ok", `
      <div><b>근무상황 집계 완료</b></div>
      <ul>
        <li>처리 파일: ${files.length}개</li>
        <li>전체 행(대략): ${totalRows.toLocaleString("ko-KR")}행</li>
        <li>연차 사용으로 집계된 건수: ${usedRows.toLocaleString("ko-KR")}건</li>
        <li>검토 필요: ${reviewRows.toLocaleString("ko-KR")}건</li>
        <li>인사기록에 없는 인원(복무상황만): ${state.workOnlyWorkers.size.toLocaleString("ko-KR")}명</li>
      </ul>
      <div class="muted">※ 인사기록에 없는 인원은 기본적으로 <b>집계 제외</b>이며, 옵션 체크 시 계산에 포함됩니다.</div>
    `);

    // 별도표 렌더
    renderWorkOnlyBox(null);

    if (state.lastRunAt) runCalculation(false);
  }

  function csvToRows(text) {
    const lines = text.split(/\r?\n/).filter(x => x.trim() !== "");
    return lines.map(line => parseCsvLine(line));
  }

  function parseCsvLine(line) {
    const res = [];
    let cur = "";
    let inQ = false;

    for (let i = 0; i < line.length; i++) {
      const ch = line[i];
      if (ch === '"') {
        if (inQ && line[i+1] === '"') { cur += '"'; i++; continue; }
        inQ = !inQ; continue;
      }
      if (ch === "," && !inQ) { res.push(cur); cur = ""; continue; }
      cur += ch;
    }
    res.push(cur);
    return res;
  }

  function nextRecordId() {
    return "R" + Math.random().toString(36).slice(2, 10) + Date.now().toString(36);
  }

  function parseWorkRows(rows, filename) {
    const headerIdx = findHeaderRow(rows, ["성명", "종별", "근태", "기간", "일시"]);
    if (headerIdx < 0) throw new Error(`[${filename}] 헤더 행을 찾지 못했습니다.`);

    const headers = rows[headerIdx].map(x => String(x||"").trim());
    const dataRows = rows.slice(headerIdx + 1).filter(r => Array.isArray(r) && r.some(x => String(x||"").trim() !== ""));

    const colName = findColumnIndex(headers, ["성명","이름"]);
    const colPid  = findColumnIndex(headers, ["나이스개인번호","개인번호","사번","인적번호"]);
    const colType = findColumnIndex(headers, ["종별","복무종별","근무상황","근태종류","근태유형","복무구분"]);
    const colReason = findColumnIndex(headers, ["사유","상세사유","용무","비고"]);

    const colStart = findColumnIndex(headers, ["시작일","시작","from","시작일자"]);
    const colEnd   = findColumnIndex(headers, ["종료일","종료","to","종료일자"]);
    const colRange = findColumnIndex(headers, ["기간","일시","기간(일시)","기간(일자)","기간일시"]);

    const colDays = findColumnIndex(headers, ["일수","기간(일수)","사용일수","일수(사용)"]);
    const colHours = findColumnIndex(headers, ["시간","사용시간","근무시간","사용시간(시간)"]);
    const colMins = findColumnIndex(headers, ["분","사용분","사용시간(분)"]);
    const colTime = findColumnIndex(headers, ["시간(분)","사용시간(분)"]);

    const colStartTime = findColumnIndex(headers, ["시작시각","시작시간"]);
    const colEndTime   = findColumnIndex(headers, ["종료시각","종료시간"]);

    if (colName < 0) throw new Error(`[${filename}] 성명 열을 찾지 못했습니다.`);
    if (colType < 0) throw new Error(`[${filename}] 종별/근태 종류 열을 찾지 못했습니다.`);

    let totalRows = dataRows.length;
    let usedRows = 0;
    let reviewRows = 0;
    let workOnlyCreated = 0;

    for (const row of dataRows) {
      const nameRaw = String(row[colName] || "").trim();
      if (!nameRaw) continue;

      // "홍길동(K12345)" 같은 경우 대비
      let name = nameRaw;
      let pidFromName = "";
      const m = nameRaw.match(/\((K[0-9A-Za-z]+)\)/);
      if (m) pidFromName = m[1];
      name = nameRaw.replace(/\(.*?\)/g, "").trim();

      const pid = (colPid >= 0 ? String(row[colPid]||"").trim() : "") || pidFromName;
      const key = workerKeyOf(name, pid);

      // (핵심 변경) 인사기록 기준 매칭
      // - HR에 있으면 state.workers 사용
      // - HR에 없으면 state.workOnlyWorkers에만 생성(별도 표시)
      if (!state.workers.has(key) && !state.workOnlyWorkers.has(key)) {
        state.workOnlyWorkers.set(key, {
          key,
          pid,
          name,
          job: "",
          hireDateUTC: null,
          dailyHours: DEFAULT_DAILY_HOURS,
          weeklyHours: DEFAULT_DAILY_HOURS * 5,
          grantedDays: null,
          customMonthlyAllowance: 0,
          hourlyOverride: null,
          flags: {},
          __workOnly: true,
        });
        workOnlyCreated++;
      }

      const w = getWorkerByKey(key);
      const dailyMinutes = Math.round(Number(w?.dailyHours || DEFAULT_DAILY_HOURS) * 60);

      const typeRaw = String(row[colType] || "").trim();
      const leaveKind = classifyLeaveType(typeRaw);
      if (!leaveKind) continue;

      // 날짜/기간 파싱
      let start = null, end = null;

      if (colRange >= 0) {
        const rangeStr = String(row[colRange] || "").trim();
        const parsed = parseRangeLoose(rangeStr);
        if (parsed) { start = parsed.start; end = parsed.end; }
      }

      if ((!start || !end) && colStart >= 0 && colEnd >= 0) {
        const s = parseDateLoose(row[colStart]);
        const e = parseDateLoose(row[colEnd]);
        if (s && e) { start = s; end = e; }
      }

      if (!start && colStart >= 0) start = parseDateLoose(row[colStart]);
      if (!end && colEnd >= 0) end = parseDateLoose(row[colEnd]);
      if (start && !end) end = start;
      if (end && !start) start = end;

      if (!start || !end) continue;

      const overlap = normalizeRange(start, end);
      if (!overlap) continue;

      const reason = (colReason >= 0) ? String(row[colReason] || "").trim() : "";

      // 시간/일수 파싱
      let minutes = null;
      let rawDur = "";
      let method = "";

      // 1) 일수 컬럼 우선
      if (colDays >= 0) {
        const cell = row[colDays];
        rawDur = String(cell||"").trim();

        // "1일 0시간 0분" 같은 문자열 우선 파싱
        const p = parseDurationToMinutes(cell, dailyMinutes);
        if (p != null) {
          minutes = p;
          method = "일수(문자)";
        } else {
          const d = safeNum(cell, NaN);
          if (Number.isFinite(d)) {
            minutes = Math.round(d * dailyMinutes);
            method = "일수";
          }
        }
      }

      // 2) 시간/분 컬럼
      if (minutes == null) {
        const h = (colHours >= 0) ? safeNum(row[colHours], NaN) : NaN;
        const m2 = (colMins >= 0) ? safeNum(row[colMins], NaN) : NaN;
        const tmin = (colTime >= 0) ? safeNum(row[colTime], NaN) : NaN;

        if (Number.isFinite(tmin)) {
          rawDur = String(row[colTime]||"");
          minutes = Math.round(tmin);
          method = "분";
        } else if (Number.isFinite(h) || Number.isFinite(m2)) {
          rawDur = `${Number.isFinite(h) ? h : 0}시간 ${Number.isFinite(m2) ? m2 : 0}분`;
          minutes = Math.round((Number.isFinite(h) ? h : 0) * 60 + (Number.isFinite(m2) ? m2 : 0));
          method = "시/분";
        }
      }

      // 3) 셀에 "1일 2시간" 같이 들어간 경우
      if (minutes == null && colHours >= 0) {
        const p = parseDurationToMinutes(row[colHours], dailyMinutes);
        if (p != null) {
          rawDur = String(row[colHours]||"");
          minutes = p;
          method = "문자(시간)";
        }
      }

      // 4) 시작/종료 시각이 있으면 차이 계산
      if (minutes == null && colStartTime >= 0 && colEndTime >= 0) {
        const st = parseTimeToMinutes(row[colStartTime]);
        const et = parseTimeToMinutes(row[colEndTime]);
        if (st != null && et != null) {
          rawDur = `${row[colStartTime]}~${row[colEndTime]}`;
          minutes = Math.max(0, et - st);
          method = "시각차";
        }
      }

      // 5) 기간(일시)에 시각이 들어있는 경우
      if (minutes == null && colRange >= 0) {
        const s = String(row[colRange]||"");
        const mt = s.match(/(\d{1,2}:\d{2})\s*(?:~|〜|-)\s*(\d{1,2}:\d{2})/);
        if (mt) {
          const st = parseTimeToMinutes(mt[1]);
          const et = parseTimeToMinutes(mt[2]);
          if (st != null && et != null) {
            rawDur = `${mt[1]}~${mt[2]}`;
            minutes = Math.max(0, et - st);
            method = "기간시각";
          }
        }
      }

      // 6) 그래도 없으면 유형에 따라 추정/검토필요
      if (minutes == null) {
        const wd = countWorkdaysInRange(overlap.start, overlap.end);
        if (leaveKind === "FULL") {
          minutes = wd * dailyMinutes;
          method = "추정(연차)";
        } else if (leaveKind === "HALF") {
          minutes = Math.round(wd * dailyMinutes * 0.5);
          method = "추정(반일)";
        } else {
          // 지각/조퇴/외출인데 시간이 없으면 검토 필요
          minutes = 0;
          method = "검토필요";
        }
      }

      // sanity cap: 기간 내 최대치 초과 방지
      const maxMins = countWorkdaysInRange(overlap.start, overlap.end) * dailyMinutes;
      minutes = Math.min(Math.max(0, minutes), maxMins);

      const rec = {
        id: nextRecordId(),
        workerKey: key,
        name,
        pid,
        type: typeRaw,
        kind: leaveKind,
        startUTC: overlap.start,
        endUTC: overlap.end,
        minutes,
        rawDur,
        reason,
        method,
        filename,
      };

      state.leaveRecords.push(rec);
      usedRows++;

      if (method === "검토필요") {
        state.reviewRecords.push({
          id: rec.id,
          workerKey: key,
          name,
          pid,
          type: typeRaw,
          startUTC: overlap.start,
          endUTC: overlap.end,
          rawDur: rawDur || "(없음)",
          minutes: null,
          filename,
        });
        reviewRows++;
      }
    }

    return { totalRows, usedRows, reviewRows, workOnlyCreated };
  }

  function renderReviewRecords() {
    const box = $("#reviewBox");
    const tbody = $("#reviewTable tbody");

    if (!state.reviewRecords.length) {
      box.classList.add("hidden");
      tbody.innerHTML = "";
      return;
    }

    box.classList.remove("hidden");
    tbody.innerHTML = "";

    for (const r of state.reviewRecords) {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td class="nowrap">${escapeHtml(r.name)}</td>
        <td class="nowrap">${escapeHtml(r.workerKey)}</td>
        <td class="nowrap">${escapeHtml(r.type)}</td>
        <td class="nowrap">${utcToYmd(r.startUTC)} ~ ${utcToYmd(r.endUTC)}</td>
        <td class="nowrap">${escapeHtml(r.rawDur||"")}</td>
        <td class="right nowrap">
          <input type="number" class="numeric" min="0" step="1" data-rev="${escapeHtml(r.id)}" placeholder="분" />
        </td>
        <td class="center nowrap"><button class="btn btn-lightgrey" data-apply="${escapeHtml(r.id)}">반영</button></td>
        <td class="nowrap">${escapeHtml(r.filename)}</td>
      `;
      tbody.appendChild(tr);
    }

    tbody.querySelectorAll("button[data-apply]").forEach(btn => {
      btn.addEventListener("click", () => {
        const id = btn.getAttribute("data-apply");
        const inp = tbody.querySelector(`input[data-rev='${CSS.escape(id)}']`);
        const mins = inp ? safeNum(inp.value, NaN) : NaN;
        if (!Number.isFinite(mins) || mins < 0) {
          alert("분 단위 숫자를 입력하세요.");
          return;
        }

        // leaveRecords에 반영
        const rec = state.leaveRecords.find(x => x.id === id);
        if (rec) {
          rec.minutes = Math.round(mins);
          rec.method = "수기(분)";
        }

        // reviewRecords에서 제거
        state.reviewRecords = state.reviewRecords.filter(x => x.id !== id);
        renderReviewRecords();

        if (state.lastRunAt) runCalculation(false);
      });
    });
  }

  // =============================
  // 통상임금 계산
  // =============================
  function detectPayCategory(job) {
    const jn = normalizeText(job);

    // 특수운영직군
    if (JOB_KEYWORDS.special1.some(k => jn.includes(normalizeText(k)))) {
      return { cat: "special1", base40: state.constants.basePay40.type2, note: "특수운영직군 1유형" };
    }
    if (JOB_KEYWORDS.special2.some(k => jn.includes(normalizeText(k)))) {
      return { cat: "special2", base40: state.constants.basePay40.type2, note: "특수운영직군 2유형" };
    }

    // 1유형 초과(직종별)
    if (jn.includes("교육복지사") && jn.includes("기관")) {
      return { cat: "type1Over", base40: state.constants.basePay40.welfareInst, note: "교육복지사(기관)" };
    }
    if (jn.includes("임상심리사") || jn.includes("대안교육전문가")) {
      return { cat: "type1Over", base40: state.constants.basePay40.clinical, note: "임상/대안" };
    }
    if (jn.includes("학습클리닉") || jn.includes("학부모지원")) {
      return { cat: "type1Over", base40: state.constants.basePay40.clinic, note: "학습/학부모" };
    }
    if (jn.includes("진학전문지원관")) {
      return { cat: "type1Over", base40: state.constants.basePay40.jinhak, note: "진학전문지원관" };
    }
    if (jn.includes("학교운동부지도자")) {
      return { cat: "type1Over", base40: state.constants.basePay40.sports, note: "학교운동부지도자" };
    }

    // 1유형 미만
    if (JOB_KEYWORDS.type1Under.some(k => jn.includes(normalizeText(k)))) {
      return { cat: "type1Under", base40: state.constants.basePay40.type1Under, note: "1유형 미만" };
    }

    // 1유형
    if (JOB_KEYWORDS.type1.some(k => jn.includes(normalizeText(k)))) {
      return { cat: "type1", base40: state.constants.basePay40.type1, note: "1유형" };
    }

    // 2유형
    if (JOB_KEYWORDS.type2.some(k => jn.includes(normalizeText(k)))) {
      return { cat: "type2", base40: state.constants.basePay40.type2, note: "2유형" };
    }

    return { cat: "unknown", base40: state.constants.basePay40.type2, note: "직종 판독 실패(2유형 가정)" };
  }

  function annualBonusFor(job) {
    const jn = normalizeText(job);
    if (JOB_KEYWORDS.special1.some(k => jn.includes(normalizeText(k)))) return state.constants.annualBonusSpecial1;
    if (JOB_KEYWORDS.special2.some(k => jn.includes(normalizeText(k)))) return state.constants.annualBonusDefault;
    return state.constants.annualBonusDefault;
  }

  function isSpecialHourlyCase(w) {
    const weekly = Number(w.weeklyHours || (Number(w.dailyHours||DEFAULT_DAILY_HOURS)*5));
    if (!(weekly > 0)) return false;
    const jn = normalizeText(w.job);
    const isSpecial = JOB_KEYWORDS.special1.concat(JOB_KEYWORDS.special2).some(k => jn.includes(normalizeText(k)));
    return isSpecial && weekly < 15;
  }

  function computeOrdinaryWage(w) {
    const dailyHours = Number(w.dailyHours || DEFAULT_DAILY_HOURS);
    const weeklyHours = Number(w.weeklyHours || dailyHours * 5);
    const monthlyHours = computeMonthlyHours(weeklyHours, dailyHours);

    // 수기 입력 우선(시간당 통상임금)
    if (w.hourlyOverride != null && Number.isFinite(Number(w.hourlyOverride)) && Number(w.hourlyOverride) > 0) {
      const hr = Number(w.hourlyOverride);
      return {
        hourlyRaw: hr,
        hourly: Math.round(hr),
        monthly: null,
        monthlyHours,
        breakdown: { note: "수기입력(시간당)" }
      };
    }

    // 특수운영(주15시간 미만): 시급제(참고 가정)
    if (isSpecialHourlyCase(w)) {
      const hourlyRaw = Number(state.constants.specialHourly || 0);
      const monthly = Math.round(hourlyRaw * (weeklyHours / 7) * (365 / 12));
      return {
        hourlyRaw,
        hourly: Math.round(hourlyRaw),
        monthly,
        monthlyHours: Math.round((weeklyHours / 7) * (365 / 12)),
        breakdown: { note: "특수운영(주15시간 미만) 시급제 가정" }
      };
    }

    // ★ 근속수당: 2026.2.28. 기준 근속연수로 산정
    const serviceYears = computeServiceYearsAt(PAY_WAGE_DATE, w.hireDateUTC);
    const serviceStep = Number(state.constants.serviceStep || 0);
    const serviceCap = Number(state.constants.serviceCapYears || 0);
    const serviceAllowance = serviceStep * Math.min(serviceCap, Math.max(0, serviceYears));

    const mealAllowance = Number(state.constants.mealAllowance || 0);

    const cat = detectPayCategory(w.job);

    // 기본급(근로시간 비례)
    const ratio = (weeklyHours > 0) ? (weeklyHours / 40) : 1;
    let basePay = Math.round(cat.base40 * ratio);

    // 조리사는 기본급에 5% 가산(가정)
    const jn = normalizeText(w.job);
    if (jn.includes("조리사") && !jn.includes("조리실무사")) {
      basePay = Math.round(Math.round(state.constants.basePay40.type2 * ratio) * 1.05);
    }

    // 직무관련수당(대표)
    let hazard = 0;
    if (jn.includes("조리실무사") || (jn.includes("조리사") && !jn.includes("조리실무사"))) {
      hazard = Number(state.constants.hazardAllowance || 0);
    }

    let mealOps = 0;
    if (jn.includes("영양사")) mealOps = Number(state.constants.mealOpsAllowance || 0);

    let license = 0;
    let techInfo = 0;
    if (jn.includes("영양사")) {
      const hasLicense = (w.flags && w.flags.nutritionLicense != null)
        ? !!w.flags.nutritionLicense
        : true;
      if (hasLicense) {
        license = Math.round(basePay * 0.05);
      } else {
        techInfo = Number(state.constants.techInfoAllowance || 0);
      }
    }

    let specialDuty = 0;
    if (jn.includes("학교도서관사서")) specialDuty = Number(state.constants.specialDutyLibrarian || 0);
    if (jn.includes("교육복지사") && !jn.includes("기관")) specialDuty = Math.max(specialDuty, Number(state.constants.specialDutyWelfare || 0));
    if (jn.includes("구육성회")) specialDuty = Math.max(specialDuty, Number(state.constants.specialDutyOld || 0));

    const custom = Number(w.customMonthlyAllowance || 0);

    const bonusMonthly = state.options.includeBonus ? (annualBonusFor(w.job) / 12) : 0;
    const holidayMonthly = state.options.includeHoliday ? (Number(state.constants.annualHoliday || 0) / 12) : 0;

    const monthly = basePay + serviceAllowance + mealAllowance + hazard + mealOps + license + techInfo + specialDuty + custom + bonusMonthly + holidayMonthly;

    const hourlyRaw = monthlyHours > 0 ? (monthly / monthlyHours) : 0;
    const hourly = Math.round(hourlyRaw);

    return {
      hourlyRaw,
      hourly,
      monthly,
      monthlyHours,
      breakdown: {
        cat: cat.note,
        basePay,
        serviceYears,
        serviceAllowance,
        mealAllowance,
        hazard,
        mealOps,
        license,
        techInfo,
        specialDuty,
        custom,
        bonusMonthly,
        holidayMonthly
      }
    };
  }

  // =============================
  // 연차 사용/미사용 계산
  // =============================
  function summarizeLeaveByWorker() {
    const map = new Map();

    for (const r of state.leaveRecords) {
      const w = getWorkerByKey(r.workerKey);
      const dailyMinutes = Math.round(Number(w?.dailyHours || DEFAULT_DAILY_HOURS) * 60);

      if (!map.has(r.workerKey)) {
        map.set(r.workerKey, {
          total: 0,
          byKind: { FULL:0, HALF:0, LATE:0, EARLY:0, OUT:0 },
          dailyMinutes,
          reviewCount: 0,
        });
      }
      const s = map.get(r.workerKey);

      const mins = Math.max(0, Number(r.minutes||0));
      s.total += mins;
      if (s.byKind[r.kind] != null) s.byKind[r.kind] += mins;

      if (r.method === "검토필요") s.reviewCount += 1;
    }

    // reviewRecords도 반영(아직 미반영된 것은 reviewCount만)
    for (const rr of state.reviewRecords) {
      if (!map.has(rr.workerKey)) {
        const w = getWorkerByKey(rr.workerKey);
        const dailyMinutes = Math.round(Number(w?.dailyHours || DEFAULT_DAILY_HOURS) * 60);
        map.set(rr.workerKey, { total: 0, byKind:{ FULL:0, HALF:0, LATE:0, EARLY:0, OUT:0 }, dailyMinutes, reviewCount: 1 });
      } else {
        map.get(rr.workerKey).reviewCount += 1;
      }
    }

    return map;
  }

  function minutesToDHM(mins, dailyMinutes) {
    const m = Math.max(0, Math.round(mins || 0));
    const dm = Math.max(1, Math.round(dailyMinutes || 480));

    const days = Math.floor(m / dm);
    const rem = m - days * dm;
    const hours = Math.floor(rem / 60);
    const minutes = rem - hours * 60;

    return { days, hours, minutes };
  }

  function fmtDHM(x) {
    if (!x) return "0일";
    const parts = [];
    parts.push(`${x.days}일`);
    if (x.hours) parts.push(`${x.hours}시간`);
    if (x.minutes) parts.push(`${x.minutes}분`);
    return parts.join(" ");
  }

  function floorTo10Won(amount) {
    const n = Math.floor(Number(amount || 0));
    return Math.floor(n / 10) * 10;
  }

  function buildResultsFor(workersArr, computePayAllowed, extraNote) {
    const usage = summarizeLeaveByWorker();
    const results = [];

    for (const w of workersArr) {
      const dailyMinutes = Math.round(Number(w.dailyHours || DEFAULT_DAILY_HOURS) * 60);

      const grantedDays = (w.grantedDays == null || !Number.isFinite(Number(w.grantedDays))) ? null : Number(w.grantedDays);
      const grantedMinutes = (grantedDays == null) ? null : Math.round(grantedDays * dailyMinutes);

      const usedMinutes = usage.get(w.key)?.total || 0;
      const unusedMinutes = (grantedMinutes == null) ? null : Math.max(0, grantedMinutes - usedMinutes);

      const usedDhm = minutesToDHM(usedMinutes, dailyMinutes);
      const unusedDhm = (unusedMinutes == null) ? null : minutesToDHM(unusedMinutes, dailyMinutes);

      const wage = computeOrdinaryWage(w);

      let pay = null;
      if (computePayAllowed && unusedMinutes != null) {
        // 분단위 계산: (시간당 통상임금 / 60) × 분
        const raw = unusedMinutes * (Number(wage.hourlyRaw || wage.hourly || 0) / 60);
        pay = floorTo10Won(raw);
      }

      const reviewCount = usage.get(w.key)?.reviewCount || 0;

      const notes = [];
      if (extraNote) notes.push(extraNote);
      if (grantedDays == null) notes.push("부여연차 미입력");
      if (!w.job) notes.push("직종 없음");
      if (!w.hireDateUTC) notes.push("최초임용일 없음");
      if (reviewCount > 0) notes.push(`검토필요 ${reviewCount}건`);
      if (w.hourlyOverride != null) notes.push("통상임금 수기");

      results.push({
        workerKey: w.key,
        name: w.name || "",
        job: w.job || "",
        dailyMinutes,
        grantedDays,
        usedMinutes,
        unusedMinutes,
        usedDhm,
        unusedDhm,
        wage,
        pay,
        notes: notes.join(" · "),
        breakdown: usage.get(w.key)?.byKind || { FULL:0, HALF:0, LATE:0, EARLY:0, OUT:0 }
      });
    }

    return results;
  }

  function runCalculation(showMsg = true) {
    const hrWorkers = Array.from(state.workers.values());
    const woWorkers = Array.from(state.workOnlyWorkers.values());

    if (hrWorkers.length === 0 && woWorkers.length === 0) {
      if (showMsg) setMsg($("#runMsg"), "err", "대상자가 없습니다. 인사기록 파일을 먼저 불러오세요.");
      renderResults([], []);
      return;
    }

    const hrResults = buildResultsFor(hrWorkers, true, "");
    const woResults = buildResultsFor(
      woWorkers,
      state.options.includeWorkOnly,
      state.options.includeWorkOnly ? "인사기록 미존재(포함)" : "집계 제외(인사기록 미존재)"
    );

    state.lastRunAt = Date.now();

    if (showMsg) {
      const warn = hrResults.concat(woResults).some(r => (r.notes||"").includes("미입력") || (r.notes||"").includes("검토필요"));
      setMsg($("#runMsg"), warn ? "warn" : "ok", `
        <div><b>계산 완료</b> · 인사기록 ${hrResults.length}명 / 복무상황만 ${woResults.length}명</div>
        <div class="muted">실행시각: ${new Date(state.lastRunAt).toLocaleString()}</div>
      `);
    }

    renderResults(hrResults, woResults);
  }

  function renderResults(hrResults, woResults) {
    const tbody = $("#resultTable tbody");
    tbody.innerHTML = "";

    const hrSorted = (hrResults || []).slice().sort((a,b) => (a.name||"").localeCompare(b.name||"", "ko"));
    const woSorted = (woResults || []).slice().sort((a,b) => (a.name||"").localeCompare(b.name||"", "ko"));

    if (hrSorted.length === 0 && woSorted.length === 0) {
      setMsg($("#resultSummary"), "warn", "결과가 없습니다. 계산을 실행해주세요.");
      $("#detailBox").innerHTML = "";
      renderWorkOnlyBox(null);
      return;
    }

    const sumHr = hrSorted.reduce((acc, r) => acc + (Number(r.pay||0)), 0);
    const sumWo = woSorted.reduce((acc, r) => acc + (Number(r.pay||0)), 0);
    const sumAll = sumHr + (state.options.includeWorkOnly ? sumWo : 0);

    setMsg($("#resultSummary"), "ok", `
      <div><b>결과 요약</b></div>
      <ul>
        <li>대상(인사기록): ${hrSorted.length}명</li>
        <li>대상(복무상황만): ${woSorted.length}명 ${state.options.includeWorkOnly ? "<span class='pill ok'>계산 포함</span>" : "<span class='pill warn'>집계 제외</span>"}</li>
        <li>총 미사용수당(10원 절사 후 합계): <b>${formatMoney(sumAll)}</b>원</li>
        <li class="muted">· 인사기록 합계: ${formatMoney(sumHr)}원 ${state.options.includeWorkOnly ? ` / 복무상황만 합계: ${formatMoney(sumWo)}원` : ""}</li>
        <li>정기상여금 포함: <b>${state.options.includeBonus ? "예" : "아니오"}</b></li>
        <li>명절휴가비 포함: <b>${state.options.includeHoliday ? "예" : "아니오"}</b></li>
      </ul>
      <div class="muted">※ 표의 ‘비고’에 <b>미입력/검토필요</b>가 있으면 해당 인원 확인 필요</div>
    `);

    for (const r of hrSorted) {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td class="nowrap">${escapeHtml(r.workerKey)}</td>
        <td class="nowrap">${escapeHtml(r.name)}</td>
        <td class="nowrap">${escapeHtml(r.job)}</td>
        <td class="right nowrap">${r.grantedDays == null ? "" : r.grantedDays.toFixed(1)}</td>
        <td class="right nowrap">${fmtDHM(r.usedDhm)}</td>
        <td class="right nowrap">${r.unusedDhm ? `<b>${fmtDHM(r.unusedDhm)}</b>` : ""}</td>
        <td class="right nowrap">${formatMoney(r.wage.hourly)}</td>
        <td class="right nowrap">${r.pay == null ? "" : `<b>${formatMoney(r.pay)}</b>`}</td>
        <td class="nowrap">${escapeHtml(r.notes||"")}</td>
      `;
      tbody.appendChild(tr);
    }

    renderDetail(hrSorted);
    renderWorkOnlyBox(woSorted);
  }

  function renderDetail(sortedResults) {
    const box = $("#detailBox");
    box.innerHTML = "";

    for (const r of sortedResults) {
      const w = getWorkerByKey(r.workerKey);
      const by = r.breakdown || { FULL:0, HALF:0, LATE:0, EARLY:0, OUT:0 };
      const dailyMinutes = r.dailyMinutes;

      const card = document.createElement("div");
      card.className = "msg";

      const wage = r.wage;
      const b = wage.breakdown || {};

      const line = (label, mins) => {
        const dhm = minutesToDHM(mins, dailyMinutes);
        return `<li>${label}: ${fmtDHM(dhm)} <span class='muted'>(${mins}분)</span></li>`;
      };

      card.innerHTML = `
        <div><b>${escapeHtml(r.name)}</b> (${escapeHtml(r.workerKey)}) · ${escapeHtml(r.job||"")}</div>
        <div class="muted">부여 ${r.grantedDays == null ? "(미입력)" : r.grantedDays.toFixed(1)+"일"} / 사용 ${fmtDHM(r.usedDhm)} / 미사용 ${r.unusedDhm ? fmtDHM(r.unusedDhm) : "(미입력)"}</div>
        <hr />
        <div><b>연차 사용(유형별)</b></div>
        <ul>
          ${line("연차", by.FULL)}
          ${line("반일연차", by.HALF)}
          ${line("지각", by.LATE)}
          ${line("조퇴", by.EARLY)}
          ${line("외출", by.OUT)}
        </ul>
        <div><b>통상임금(자동/수기)</b></div>
        <ul>
          <li>시간당: <b>${formatMoney(wage.hourly)}</b>원 <span class="muted">(2026.2.28. 기준 근속수당 반영)</span></li>
          ${wage.monthly == null ? "" : `<li>월 통상임금(추정): ${formatMoney(wage.monthly)}원 / 월 소정시간: ${formatMoney(wage.monthlyHours)}시간</li>`}
          ${b.note ? `<li class='muted'>※ ${escapeHtml(b.note)}</li>` : ""}
          ${b.basePay != null ? `<li class='muted'>구성(참고): 기본급 ${formatMoney(b.basePay)}, 근속 ${formatMoney(b.serviceAllowance)}, 급식비 ${formatMoney(b.mealAllowance)}, 직무수당합 ${formatMoney((b.hazard||0)+(b.mealOps||0)+(b.license||0)+(b.techInfo||0)+(b.specialDuty||0)+(b.custom||0))}, 상여(월) ${formatMoney(b.bonusMonthly||0)}, 명절(월) ${formatMoney(b.holidayMonthly||0)}</li>` : ""}
        </ul>
      `;

      box.appendChild(card);
    }
  }

  // =============================
  // (추가) 인사기록 미존재 인원: 별도 표/세부내역
  // =============================
  function renderWorkOnlyBox(workOnlyResultsOrNull) {
    const box = $("#workOnlyBox");
    const summaryEl = $("#workOnlySummary");
    const tbody = $("#workOnlyResultTable tbody");
    const dtbody = $("#workOnlyDetailTable tbody");

    const woWorkers = Array.from(state.workOnlyWorkers.values());
    if (!woWorkers.length) {
      box.classList.add("hidden");
      tbody.innerHTML = "";
      dtbody.innerHTML = "";
      return;
    }

    box.classList.remove("hidden");

    const woResults = workOnlyResultsOrNull
      ? workOnlyResultsOrNull
      : buildResultsFor(
          woWorkers,
          state.options.includeWorkOnly,
          state.options.includeWorkOnly ? "인사기록 미존재(포함)" : "집계 제외(인사기록 미존재)"
        ).sort((a,b) => (a.name||"").localeCompare(b.name||"", "ko"));

    const sumWo = woResults.reduce((acc, r) => acc + (Number(r.pay||0)), 0);

    setMsg(summaryEl, state.options.includeWorkOnly ? "ok" : "warn", `
      <div><b>복무상황에만 있는 인원</b>: ${woResults.length}명</div>
      <div class="muted">
        현재 설정: ${state.options.includeWorkOnly ? "<b>계산 포함</b>" : "<b>집계 제외</b>"} ·
        ${state.options.includeWorkOnly ? `합계(10원 절사 후): <b>${formatMoney(sumWo)}</b>원` : "※ 체크하면 계산에 포함됩니다."}
      </div>
      <div class="muted">※ 이 인원들은 인사기록이 없어서 <b>직종/최초임용일/부여연차</b>를 수기로 입력해야 계산이 정확합니다.</div>
    `);

    // 요약/입력 테이블
    tbody.innerHTML = "";
    for (const r of woResults) {
      const w = state.workOnlyWorkers.get(r.workerKey);
      const tr = document.createElement("tr");

      tr.innerHTML = `
        <td class="nowrap">${escapeHtml(r.workerKey)}</td>
        <td class="nowrap">${escapeHtml(r.name)}</td>
        <td class="nowrap">
          <input type="text" data-wo="${escapeHtml(r.workerKey)}" data-field="job" value="${escapeHtml(w?.job||"")}" placeholder="직종" />
        </td>
        <td class="nowrap">
          <input type="text" data-wo="${escapeHtml(r.workerKey)}" data-field="hireDate" value="${w?.hireDateUTC ? utcToYmd(w.hireDateUTC) : ""}" placeholder="YYYY-MM-DD" />
        </td>
        <td class="right nowrap">
          <input type="number" step="0.1" min="0" data-wo="${escapeHtml(r.workerKey)}" data-field="dailyHours" value="${w?.dailyHours ?? DEFAULT_DAILY_HOURS}" />
        </td>
        <td class="right nowrap">
          <input type="number" step="0.1" min="0" data-wo="${escapeHtml(r.workerKey)}" data-field="weeklyHours" value="${w?.weeklyHours ?? (Number(w?.dailyHours||DEFAULT_DAILY_HOURS)*5)}" />
        </td>
        <td class="right nowrap">
          <input type="number" step="0.1" min="0" data-wo="${escapeHtml(r.workerKey)}" data-field="grantedDays" value="${w?.grantedDays ?? ""}" placeholder="예: 15" />
        </td>
        <td class="right nowrap">${fmtDHM(r.usedDhm)}</td>
        <td class="right nowrap">${r.unusedDhm ? `<b>${fmtDHM(r.unusedDhm)}</b>` : ""}</td>
        <td class="right nowrap">${formatMoney(r.wage.hourly)}</td>
        <td class="right nowrap">${r.pay == null ? "" : `<b>${formatMoney(r.pay)}</b>`}</td>
        <td class="nowrap">${escapeHtml(r.notes||"")}</td>
        <td class="center nowrap"><button class="btn btn-lightgrey" data-wo-del="${escapeHtml(r.workerKey)}">삭제</button></td>
      `;
      tbody.appendChild(tr);
    }

    // workOnly 입력 반영
    tbody.querySelectorAll("input[data-wo]").forEach(inp => {
      inp.addEventListener("change", () => {
        const key = inp.getAttribute("data-wo");
        const field = inp.getAttribute("data-field");
        const w = state.workOnlyWorkers.get(key);
        if (!w) return;

        if (field === "job") {
          w.job = inp.value.trim();
        }
        if (field === "hireDate") {
          const d = parseDateLoose(inp.value);
          w.hireDateUTC = d;
        }
        if (field === "dailyHours") {
          const v = safeNum(inp.value, NaN);
          if (Number.isFinite(v) && v > 0) w.dailyHours = v;
        }
        if (field === "weeklyHours") {
          const v = safeNum(inp.value, NaN);
          if (Number.isFinite(v) && v > 0) w.weeklyHours = v;
        }
        if (field === "grantedDays") {
          const v = inp.value.trim();
          w.grantedDays = v === "" ? null : safeNum(v, null);
        }

        state.workOnlyWorkers.set(key, w);
        if (state.lastRunAt) runCalculation(false);
      });
    });

    tbody.querySelectorAll("button[data-wo-del]").forEach(btn => {
      btn.addEventListener("click", () => {
        const key = btn.getAttribute("data-wo-del");
        state.workOnlyWorkers.delete(key);
        state.leaveRecords = state.leaveRecords.filter(r => r.workerKey !== key);
        state.reviewRecords = state.reviewRecords.filter(r => r.workerKey !== key);
        renderReviewRecords();
        renderWorkOnlyBox(null);
        if (state.lastRunAt) runCalculation(false);
      });
    });

    // 원본(세부내역) 테이블
    dtbody.innerHTML = "";
    const woKeys = new Set(Array.from(state.workOnlyWorkers.keys()));
    const records = state.leaveRecords
      .filter(r => woKeys.has(r.workerKey))
      .sort((a,b) => {
        const an = (a.name||"").localeCompare(b.name||"", "ko");
        if (an !== 0) return an;
        return (a.startUTC?.getTime?.() || 0) - (b.startUTC?.getTime?.() || 0);
      });

    for (const rec of records) {
      const w = getWorkerByKey(rec.workerKey);
      const dailyMinutes = Math.round(Number(w?.dailyHours || DEFAULT_DAILY_HOURS) * 60);
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td class="nowrap">${escapeHtml(rec.workerKey)}</td>
        <td class="nowrap">${escapeHtml(rec.name)}</td>
        <td class="nowrap">${escapeHtml(rec.type)}</td>
        <td class="nowrap">${utcToYmd(rec.startUTC)} ~ ${utcToYmd(rec.endUTC)}</td>
        <td class="right nowrap">${fmtDHM(minutesToDHM(rec.minutes, dailyMinutes))}</td>
        <td class="right nowrap">${escapeHtml(String(rec.minutes))}</td>
        <td class="nowrap">${escapeHtml(rec.method||"")}</td>
        <td class="nowrap">${escapeHtml(rec.rawDur||"")}</td>
        <td class="nowrap">${escapeHtml(rec.filename||"")}</td>
      `;
      dtbody.appendChild(tr);
    }
  }

  // =============================
  // 엑셀 다운로드
  // =============================
  function downloadXlsx() {
    ensureXLSX();

    const usage = summarizeLeaveByWorker();

    // 1) 인사기록 대상(메인)
    const rows = [];
    rows.push([
      "나이스개인번호","성명","직종","최초임용일","1일시간","주시간",
      "근속년수(2026-02-28)","부여연차(일)","사용(분)","사용(표시)","미사용(분)","미사용(표시)",
      "시간당통상임금","미사용수당(10원절사)","비고"
    ]);

    const sorted = Array.from(state.workers.values()).sort((a,b) => (a.name||"").localeCompare(b.name||"", "ko"));

    for (const w of sorted) {
      const dailyMinutes = Math.round(Number(w.dailyHours || DEFAULT_DAILY_HOURS) * 60);
      const grantedDays = (w.grantedDays == null || !Number.isFinite(Number(w.grantedDays))) ? null : Number(w.grantedDays);
      const grantedMinutes = (grantedDays == null) ? null : Math.round(grantedDays * dailyMinutes);
      const usedMinutes = usage.get(w.key)?.total || 0;
      const unusedMinutes = (grantedMinutes == null) ? null : Math.max(0, grantedMinutes - usedMinutes);

      const usedDhm = minutesToDHM(usedMinutes, dailyMinutes);
      const unusedDhm = (unusedMinutes == null) ? null : minutesToDHM(unusedMinutes, dailyMinutes);

      const wage = computeOrdinaryWage(w);
      let pay = null;
      if (unusedMinutes != null) {
        pay = floorTo10Won(unusedMinutes * (Number(wage.hourlyRaw || wage.hourly || 0) / 60));
      }

      const serviceYears = computeServiceYearsAt(PAY_WAGE_DATE, w.hireDateUTC);

      const notes = [];
      if (grantedDays == null) notes.push("부여연차 미입력");
      if (!w.job) notes.push("직종 없음");
      if (!w.hireDateUTC) notes.push("최초임용일 없음");
      const reviewCount = usage.get(w.key)?.reviewCount || 0;
      if (reviewCount > 0) notes.push(`검토필요 ${reviewCount}건`);
      if (w.hourlyOverride != null) notes.push("통상임금 수기");

      rows.push([
        w.key,
        w.name || "",
        w.job || "",
        w.hireDateUTC ? utcToYmd(w.hireDateUTC) : "",
        w.dailyHours ?? DEFAULT_DAILY_HOURS,
        w.weeklyHours ?? (Number(w.dailyHours||DEFAULT_DAILY_HOURS)*5),
        serviceYears,
        grantedDays == null ? "" : grantedDays,
        usedMinutes,
        fmtDHM(usedDhm),
        unusedMinutes == null ? "" : unusedMinutes,
        unusedDhm ? fmtDHM(unusedDhm) : "",
        wage.hourly,
        pay == null ? "" : pay,
        notes.join(" · ")
      ]);
    }

    // 2) 복무상황만 인원(별도 시트)
    const woRows = [];
    woRows.push([
      "나이스개인번호","성명","직종","최초임용일","1일시간","주시간",
      "근속년수(2026-02-28)","부여연차(일)","사용(분)","사용(표시)","미사용(분)","미사용(표시)",
      "시간당통상임금","미사용수당(10원절사)","비고"
    ]);

    const woSorted = Array.from(state.workOnlyWorkers.values()).sort((a,b) => (a.name||"").localeCompare(b.name||"", "ko"));

    for (const w of woSorted) {
      const dailyMinutes = Math.round(Number(w.dailyHours || DEFAULT_DAILY_HOURS) * 60);
      const grantedDays = (w.grantedDays == null || !Number.isFinite(Number(w.grantedDays))) ? null : Number(w.grantedDays);
      const grantedMinutes = (grantedDays == null) ? null : Math.round(grantedDays * dailyMinutes);
      const usedMinutes = usage.get(w.key)?.total || 0;
      const unusedMinutes = (grantedMinutes == null) ? null : Math.max(0, grantedMinutes - usedMinutes);

      const usedDhm = minutesToDHM(usedMinutes, dailyMinutes);
      const unusedDhm = (unusedMinutes == null) ? null : minutesToDHM(unusedMinutes, dailyMinutes);

      const wage = computeOrdinaryWage(w);
      let pay = null;
      if (state.options.includeWorkOnly && unusedMinutes != null) {
        pay = floorTo10Won(unusedMinutes * (Number(wage.hourlyRaw || wage.hourly || 0) / 60));
      }

      const serviceYears = computeServiceYearsAt(PAY_WAGE_DATE, w.hireDateUTC);

      const notes = [];
      notes.push(state.options.includeWorkOnly ? "인사기록 미존재(포함)" : "집계 제외(인사기록 미존재)");
      if (grantedDays == null) notes.push("부여연차 미입력");
      if (!w.job) notes.push("직종 없음");
      if (!w.hireDateUTC) notes.push("최초임용일 없음");
      const reviewCount = usage.get(w.key)?.reviewCount || 0;
      if (reviewCount > 0) notes.push(`검토필요 ${reviewCount}건`);
      if (w.hourlyOverride != null) notes.push("통상임금 수기");

      woRows.push([
        w.key,
        w.name || "",
        w.job || "",
        w.hireDateUTC ? utcToYmd(w.hireDateUTC) : "",
        w.dailyHours ?? DEFAULT_DAILY_HOURS,
        w.weeklyHours ?? (Number(w.dailyHours||DEFAULT_DAILY_HOURS)*5),
        serviceYears,
        grantedDays == null ? "" : grantedDays,
        usedMinutes,
        fmtDHM(usedDhm),
        unusedMinutes == null ? "" : unusedMinutes,
        unusedDhm ? fmtDHM(unusedDhm) : "",
        wage.hourly,
        pay == null ? "" : pay,
        notes.join(" · ")
      ]);
    }

    const wb = XLSX.utils.book_new();
    const ws = XLSX.utils.aoa_to_sheet(rows);
    XLSX.utils.book_append_sheet(wb, ws, "미사용연차수당");

    const wsWo = XLSX.utils.aoa_to_sheet(woRows);
    XLSX.utils.book_append_sheet(wb, wsWo, "복무상황만_대상");

    // 원본 연차 기록
    const recRows = [];
    recRows.push(["개인번호","성명","유형","기간시작","기간종료","사용분","판독방법","원본값","파일"]);
    for (const r of state.leaveRecords) {
      recRows.push([
        r.workerKey,
        r.name,
        r.type,
        utcToYmd(r.startUTC),
        utcToYmd(r.endUTC),
        r.minutes,
        r.method,
        r.rawDur || "",
        r.filename
      ]);
    }
    const ws2 = XLSX.utils.aoa_to_sheet(recRows);
    XLSX.utils.book_append_sheet(wb, ws2, "연차사용_원본");

    const out = XLSX.write(wb, { bookType: "xlsx", type: "array" });
    const blob = new Blob([out], { type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" });

    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "2025회계_연차미사용수당_계산결과.xlsx";
    document.body.appendChild(a);
    a.click();
    a.remove();
  }

  // =============================
  // Drag & Drop 바인딩
  // =============================
  function bindDropZone(zoneEl, inputEl, onFiles) {
    zoneEl.addEventListener("click", () => inputEl.click());

    ["dragenter","dragover"].forEach(evt => {
      zoneEl.addEventListener(evt, (e) => {
        e.preventDefault();
        e.stopPropagation();
        zoneEl.classList.add("dragover");
      });
    });

    ["dragleave","drop"].forEach(evt => {
      zoneEl.addEventListener(evt, (e) => {
        e.preventDefault();
        e.stopPropagation();
        zoneEl.classList.remove("dragover");
      });
    });

    zoneEl.addEventListener("drop", (e) => {
      const files = Array.from(e.dataTransfer.files || []);
      if (!files.length) return;
      onFiles(files);
    });

    inputEl.addEventListener("change", () => {
      const files = Array.from(inputEl.files || []);
      if (!files.length) return;
      onFiles(files);
    });
  }

  // =============================
  // 고급설정 반영
  // =============================
  function fillConstInputs() {
    const c = state.constants;

    $("#cType1").value = c.basePay40.type1;
    $("#cType2").value = c.basePay40.type2;
    $("#cType1Under").value = c.basePay40.type1Under;

    $("#cWelfareInst").value = c.basePay40.welfareInst;
    $("#cClinical").value = c.basePay40.clinical;
    $("#cClinic").value = c.basePay40.clinic;
    $("#cJinhak").value = c.basePay40.jinhak;
    $("#cSports").value = c.basePay40.sports;

    $("#cMeal").value = c.mealAllowance;
    $("#cServiceStep").value = c.serviceStep;
    $("#cServiceCap").value = c.serviceCapYears;

    $("#cBonusDefault").value = c.annualBonusDefault;
    $("#cBonusSpecial1").value = c.annualBonusSpecial1;
    $("#cHoliday").value = c.annualHoliday;

    $("#cSpecialHourly").value = c.specialHourly;

    setMsg($("#constMsg"), "", "상수를 수정하고 <b>수기 입력한 설정 반영하기</b>를 누르세요.");
  }

  function applyConstInputs() {
    const c = state.constants;

    c.basePay40.type1 = safeNum($("#cType1").value, c.basePay40.type1);
    c.basePay40.type2 = safeNum($("#cType2").value, c.basePay40.type2);
    c.basePay40.type1Under = safeNum($("#cType1Under").value, c.basePay40.type1Under);

    c.basePay40.welfareInst = safeNum($("#cWelfareInst").value, c.basePay40.welfareInst);
    c.basePay40.clinical = safeNum($("#cClinical").value, c.basePay40.clinical);
    c.basePay40.clinic = safeNum($("#cClinic").value, c.basePay40.clinic);
    c.basePay40.jinhak = safeNum($("#cJinhak").value, c.basePay40.jinhak);
    c.basePay40.sports = safeNum($("#cSports").value, c.basePay40.sports);

    c.mealAllowance = safeNum($("#cMeal").value, c.mealAllowance);
    c.serviceStep = safeNum($("#cServiceStep").value, c.serviceStep);
    c.serviceCapYears = safeNum($("#cServiceCap").value, c.serviceCapYears);

    c.annualBonusDefault = safeNum($("#cBonusDefault").value, c.annualBonusDefault);
    c.annualBonusSpecial1 = safeNum($("#cBonusSpecial1").value, c.annualBonusSpecial1);
    c.annualHoliday = safeNum($("#cHoliday").value, c.annualHoliday);

    c.specialHourly = safeNum($("#cSpecialHourly").value, c.specialHourly);

    setMsg($("#constMsg"), "ok", "고급설정이 반영되었습니다.");

    if (state.lastRunAt) runCalculation(false);
  }

  function resetConstants() {
    state.constants = deepClone(DEFAULT_CONST);
    fillConstInputs();
    setMsg($("#constMsg"), "warn", "기본값으로 되돌렸습니다.");
    if (state.lastRunAt) runCalculation(false);
  }

  // =============================
  // 이벤트 바인딩
  // =============================
  function bindEvents() {
    // HR 드롭존 (다중 파일)
    bindDropZone($("#hrDrop"), $("#hrFile"), (files) => {
      const ok = files.filter(f => /\.(xlsx|xls)$/i.test(f.name));
      state.selectedFiles.hr = ok;
      if (!ok.length) {
        setMsg($("#hrMsg"), "err", "엑셀 파일(.xlsx/.xls)만 업로드 가능합니다.");
        return;
      }
      setMsg($("#hrMsg"), "warn", `인사기록 파일 ${ok.length}개 선택됨. <b>인사정보 내역추출</b> 버튼을 눌러주세요.`);
    });

    // Work 드롭존
    bindDropZone($("#workDrop"), $("#workFiles"), (files) => {
      const ok = files.filter(f => /\.(xlsx|xls|csv)$/i.test(f.name));
      state.selectedFiles.work = ok;
      if (!ok.length) {
        setMsg($("#workMsg"), "err", "엑셀(.xlsx/.xls) 또는 CSV(.csv) 파일만 업로드 가능합니다.");
        return;
      }
      setMsg($("#workMsg"), "warn", `근무상황 파일 ${ok.length}개 선택됨. <b>연차 사용내역 집계</b> 버튼을 눌러주세요.`);
    });

    $("#btnLoadHr").addEventListener("click", async () => {
      const files = state.selectedFiles.hr.length ? state.selectedFiles.hr : Array.from($("#hrFile").files || []);
      await handleLoadHrFiles(files);
    });

    $("#btnLoadWork").addEventListener("click", async () => {
      const files = state.selectedFiles.work.length ? state.selectedFiles.work : Array.from($("#workFiles").files || []);
      if (!files.length) { setMsg($("#workMsg"), "err", "근무상황 파일을 선택하거나 드래그하여 업로드하세요."); return; }

      try {
        await loadWorkFiles(files);
      } catch (e) {
        setMsg($("#workMsg"), "err", `<b>오류</b>: ${escapeHtml(e.message)}`);
      }
    });

    $("#btnClearWork").addEventListener("click", () => {
      state.leaveRecords = [];
      state.reviewRecords = [];
      state.workOnlyWorkers.clear();
      renderReviewRecords();
      renderWorkOnlyBox(null);
      setMsg($("#workMsg"), "warn", "근무상황(연차 사용내역) 집계를 초기화했습니다.");
      if (state.lastRunAt) runCalculation(false);
    });

    $("#btnClearAll").addEventListener("click", () => {
      state.workers.clear();
      state.workOnlyWorkers.clear();
      state.leaveRecords = [];
      state.reviewRecords = [];
      state.lastRunAt = null;
      state.selectedFiles.hr = [];
      state.selectedFiles.work = [];

      renderWorkersTable();
      renderReviewRecords();
      renderResults([], []);
      renderWorkOnlyBox(null);

      setMsg($("#hrMsg"), "warn", "전체 초기화 완료");
      setMsg($("#workMsg"), "", "근무상황을 업로드해주세요.");
      setMsg($("#runMsg"), "", "계산 실행 버튼을 눌러주세요.");
    });

    $("#optIncludeBonus").addEventListener("change", () => {
      state.options.includeBonus = $("#optIncludeBonus").checked;
      if (state.lastRunAt) runCalculation(false);
    });

    $("#optIncludeHoliday").addEventListener("change", () => {
      state.options.includeHoliday = $("#optIncludeHoliday").checked;
      if (state.lastRunAt) runCalculation(false);
    });

    // (추가) 인사기록 미존재 인원 포함 여부
    $("#optIncludeWorkOnly").addEventListener("change", () => {
      state.options.includeWorkOnly = $("#optIncludeWorkOnly").checked;
      if (state.lastRunAt) runCalculation(false);
      else renderWorkOnlyBox(null);
    });

    $("#btnRun").addEventListener("click", () => runCalculation(true));
    $("#btnDownload").addEventListener("click", () => {
      try { downloadXlsx(); } catch (e) { alert(e.message); }
    });

    $("#btnResetConstants").addEventListener("click", resetConstants);
    $("#btnApplyConstants").addEventListener("click", applyConstInputs);
  }

  function init() {
    setMsg($("#hrMsg"), "", "인사기록 파일을 업로드해주세요.");
    setMsg($("#workMsg"), "", "근무상황 파일을 업로드해주세요.");
    setMsg($("#runMsg"), "", "인사 및 근무상황 입력 후 계산 버튼을 눌러주세요.");
    $("#optIncludeWorkOnly").checked = false;
    state.options.includeWorkOnly = false;

    fillConstInputs();
    renderWorkersTable();
    renderReviewRecords();
    renderResults([], []);
    renderWorkOnlyBox(null);
    bindEvents();
  }

  init();

})();
</script>

<script src="/static/global-loader.js?v=1"></script>
<script src="/static/footer.js"></script>
<script src="/static/disable-copy.js"></script>

</body>
</html>