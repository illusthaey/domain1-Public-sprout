<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>교육공무직 인사발령 공석 검출기</title>

  <link id="commonStyle" rel="stylesheet" href="/static/style.css" />
  <script>
    (function () {
      const link = document.getElementById("commonStyle");
      if (!link) return;
      link.addEventListener("error", function () {
        const alt = document.createElement("link");
        alt.rel = "stylesheet";
        alt.href = "static/style.css";
        document.head.appendChild(alt);
        console.warn("[style] /static/style.css 로드 실패 → static/style.css 로 폴백");
      });
    })();
  </script>

  <style>
    /* 페이지 전용(최소) */
    .tool-card { margin: 24px 0; }
    .tool-card + .tool-card { margin-top: 24px; }

    .pill {
      display: inline-block;
      padding: 2px 10px;
      border-radius: 999px;
      border: 1px solid #d4d4d8;
      background: #f9fafb;
      font-size: 0.9rem;
      line-height: 1.4;
      white-space: nowrap;
    }
    .pill.red { border-color: #fecaca; background: #fef2f2; color: #991b1b; }
    .pill.blue { border-color: #bfdbfe; background: #eff6ff; color: #1d4ed8; }
    .pill.gray { border-color: #e5e7eb; background: #f9fafb; color: #6b7280; }

    .diff.pos { color: #b91c1c; font-weight: 700; }
    .diff.neg { color: #1d4ed8; font-weight: 700; }
    .diff.zero { color: #6b7280; }

    .kbd {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.95rem;
      border: 1px solid #e5e7eb;
      background: #f9fafb;
      padding: 2px 6px;
      border-radius: 6px;
    }

    /* 파일 input 숨김(라벨 버튼으로 클릭) */
    #fileInput { display:none; }

    /* 클릭 가능한 행 */
    tr.clickable:hover { background:#f3f4f6; cursor:pointer; }

    /* 로그 */
    #logBox { white-space: pre-wrap; margin: 0; }

    /* 선택 강조 */
    tr.is-selected { outline: 2px solid rgba(0,0,0,0.18); outline-offset: -2px; }

    /* 카드 헤더 정렬 */
    .card-head {
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap: 12px;
      flex-wrap: wrap;
    }
    .card-title { margin: 0; }
    .card-actions {
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: flex-end;
    }

    .sticky-note {
      background: #fff;
      border: 1px solid #e5e5e5;
      border-radius: 12px;
      padding: 10px 12px;
    }

    .clean-list { list-style: none; margin: 0; padding: 0; }
    .clean-list li { margin: 8px 0; }
    .clean-list .who { font-weight: 700; color: #111; }
    .clean-list .meta { display:block; color:#555; font-size: 0.95rem; margin-top:2px; }

    /* 스크롤 컨테이너 + 틀고정 */
    .sticky-wrap {
      max-height: 520px;
      overflow: auto;
      border-radius: 12px;
    }

    table.sticky-table thead th {
      position: sticky;
      top: 0;
      z-index: 5;
      background: #f9fafb;
      box-shadow: 0 1px 0 #e5e7eb;
    }

    table.sticky-table th:first-child,
    table.sticky-table td:first-child {
      position: sticky;
      left: 0;
      z-index: 4;
      background: #fff;
      box-shadow: 1px 0 0 #e5e7eb;
    }

    /* 좌상단(헤더+1열 교차) */
    table.sticky-table thead th:first-child {
      z-index: 6;
      background: #f9fafb;
    }

    /* 모바일에서 테이블 보기 */
    .table-wrap table { min-width: 760px; }

    @media (max-width: 640px) {
      .sticky-wrap { max-height: 460px; }
    }
  </style>
</head>

<body>

  <header class="site-header">
    <div class="shell">
      <h1>교육공무직 인사발령 공석(결원 의심) 검출</h1>
      <p class="subtitle">
        엑셀을 업로드하면 <span class="kbd">전출/퇴직(출발)</span> 대비 <span class="kbd">전입(도착)</span>이 부족한 학교(부서)를
        <b>“결원 의심(정원 확인 필요)”</b>로 표시합니다.
      </p>
    </div>
  </header>

  <main class="container">

    <!-- 1) 업로드 -->
    <section class="tool-card">
      <div class="tool-head card-head">
        <div>
          <h2 class="card-title">1) 엑셀 업로드</h2>
          <p class="tool-sub">
            기본(원주형) 매핑: <span class="kbd">A=연번</span>, <span class="kbd">B=성명</span>, <span class="kbd">C=직종</span>, <span class="kbd">D=전입(부서)</span>, <span class="kbd">F=전출/퇴직(부서)</span>, <span class="kbd">H=비고</span>
          </p>
        </div>
        <div class="card-actions">
          <label class="btn" for="fileInput">파일 선택</label>
          <input id="fileInput" type="file" accept=".xlsx,.xls" />
          <button id="btnAnalyze" class="btn primary">분석 실행</button>
          <button id="btnClear" class="btn ghost">초기화</button>
        </div>
      </div>

      <hr/>

      <div class="grid two">
        <div class="sticky-note">
          <p id="fileMeta" class="muted" style="margin:0;">아직 파일이 없습니다.</p>
          <p id="libWarn" class="note muted" style="display:none; margin:10px 0 0;"></p>

          <div class="help muted" style="margin-top:10px;">
            <ul>
              <li>이 결과는 <b>“결원 확정”</b>이 아니라 <b>“결원 의심 → 정원 확인 필요”</b>입니다.</li>
              <li><span class="pill red">정원 확인 필요</span>는 <b>전출/퇴직 − 전입</b>이 <b>양수</b>일 때 표시합니다.</li>
              <li><span class="pill red">전입없음(Y)</span>는 “전출/퇴직은 있는데 전입이 0”인 경우입니다.</li>
              <li>아래 표들은 <b>1행(헤더) + 1열(직종/시트)</b>이 틀고정됩니다.</li>
            </ul>
          </div>
        </div>

        <div>
          <details class="shot-details">
            <summary class="shot-summary">고급 설정: 자동 감지 / 컬럼 매핑 / TO(직종 묶음) 규칙</summary>
            <div class="card" style="margin-top:10px;">
              <div class="grid two">
                <div class="field">
                  <label class="row gap" style="margin-top:6px;">
                    <input id="optAutoDetect" type="checkbox" checked />
                    <span class="muted"><b>자동 컬럼 감지(추천)</b> · 시트마다 헤더 위치가 달라도 찾아봅니다</span>
                  </label>
                  <p class="note" style="margin-top:8px;">
                    ※ 자동 감지는 보통 “성명/번호/직종/부서/비고” 패턴을 이용합니다. 실패하면 아래 수동 매핑을 사용합니다.
                  </p>
                </div>

                <div class="field">
                  <label class="row gap" style="margin-top:6px;">
                    <input id="optNormalize" type="checkbox" checked />
                    <span class="muted">학교명 공백/개행 정리</span>
                  </label>
                </div>
              </div>

              <hr style="margin:16px 0;"/>

              <p class="muted" style="margin-top:0;">수동 매핑(모든 시트에 동일 적용). 데이터 행은 기본적으로 <span class="kbd">연번(순번)</span> 컬럼이 숫자인 행만 사용합니다.</p>

              <div class="grid three">
                <div class="field">
                  <label class="muted">연번(순번) 컬럼</label>
                  <input id="colSeq" type="text" value="A" maxlength="3" />
                </div>
                <div class="field">
                  <label class="muted">성명 컬럼</label>
                  <input id="colName" type="text" value="B" maxlength="3" />
                </div>
                <div class="field">
                  <label class="muted">직종 컬럼(한 시트에 직종이 섞여있을 때)</label>
                  <input id="colJob" type="text" value="C" maxlength="3" />
                </div>
                <div class="field">
                  <label class="muted">전입(도착) ‘부서/학교’ 컬럼</label>
                  <input id="colIn" type="text" value="D" maxlength="3" />
                </div>
                <div class="field">
                  <label class="muted">전출/퇴직(출발) ‘부서/학교’ 컬럼</label>
                  <input id="colOut" type="text" value="F" maxlength="3" />
                </div>
                <div class="field">
                  <label class="muted">비고 컬럼</label>
                  <input id="colNote" type="text" value="H" maxlength="3" />
                </div>
              </div>

              <hr style="margin:16px 0;"/>

              <div class="field">
                <label class="muted"><b>TO(직종 묶음) 규칙</b> (선택)</label>
                <p class="note" style="margin:8px 0 8px;">
                  다른 지역은 “직종별 시트”가 아닐 수도 있고, 정원(TO) 단위로 직종을 묶어 봐야 할 때가 있어요.
                  아래에 규칙을 적으면 <b>TO그룹 단위</b>로도 집계가 가능합니다.
                </p>
                <textarea id="groupRules" rows="5" placeholder="예시\n행정TO = 교무행정사, 행정실무사\n늘봄 = 늘봄학교전담사*\n(쉼표로 구분, * 는 부분일치)"></textarea>
                <div class="row gap" style="margin-top:10px; flex-wrap:wrap;">
                  <button id="btnApplyGroups" class="btn btn-lightgrey">그룹 규칙 적용</button>
                  <button id="btnFillGroupSample" class="btn ghost">예시 채우기</button>
                  <span id="groupHint" class="muted"></span>
                </div>
              </div>
            </div>
          </details>
        </div>
      </div>
    </section>

    <!-- 2) 직종/TO 그룹 요약(메인 분석표) -->
    <section class="tool-card" id="jobSummarySection" style="display:none;">
      <div class="tool-head card-head">
        <div>
          <h2 class="card-title">2) 인사발령 내역 분석(직종/TO 기준)</h2>
          <p class="tool-sub">1행 헤더 + 1열(직종/그룹) 틀고정. 클릭하면 아래 상세가 해당 단위로 이동합니다.</p>
        </div>
        <div class="card-actions">
          <button id="btnDownloadUnitSuspect" class="btn btn-lightgrey">현재 요약 CSV</button>
        </div>
      </div>

      <hr/>

      <div class="row gap" style="margin:0 0 10px; flex-wrap:wrap;">
        <span class="muted">집계 단위</span>
        <select id="unitModeSelect">
          <option value="job" selected>직종(추천)</option>
          <option value="group">TO 그룹(규칙 적용 시)</option>
          <option value="sheet">시트(원본)</option>
        </select>
        <span id="unitStats" class="muted"></span>
      </div>

      <div class="table-wrap sticky-wrap">
        <table class="sheetlike sticky-table" id="jobSummaryTable">
          <thead>
            <tr>
              <th id="unitColTitle">직종</th>
              <th class="numeric">전입</th>
              <th class="numeric">전출/퇴직</th>
              <th class="numeric">정원 확인 필요 학교</th>
              <th class="numeric">정원 확인 필요 인원</th>
              <th class="numeric">순증가 학교</th>
              <th class="numeric">순증가 인원</th>
              <th class="numeric">총차이(전출-전입)</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>

      <p class="muted">※ “정원 확인 필요 인원”은 <b>전출/퇴직 − 전입</b>의 합(양수만)입니다.</p>
    </section>

    <!-- 3) 시트별 요약(참고) -->
    <section class="tool-card" id="sheetSummarySection" style="display:none;">
      <div class="tool-head card-head">
        <div>
          <h2 class="card-title">3) 시트별 요약(참고)</h2>
          <p class="tool-sub">직종별 시트가 잘 나뉜 서식이면 2)와 거의 동일합니다.</p>
        </div>
        <div class="card-actions">
          <button id="btnDownloadAllNet" class="btn btn-lightgrey">전체(순증감) CSV</button>
        </div>
      </div>

      <hr/>

      <div class="table-wrap sticky-wrap">
        <table class="sheetlike sticky-table" id="sheetSummaryTable">
          <thead>
            <tr>
              <th>시트</th>
              <th class="numeric">전입</th>
              <th class="numeric">전출/퇴직</th>
              <th class="numeric">정원 확인 필요 학교</th>
              <th class="numeric">정원 확인 필요 인원</th>
              <th class="numeric">순증가 학교</th>
              <th class="numeric">순증가 인원</th>
              <th class="numeric">총차이(전출-전입)</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </section>

    <!-- 4) 전체 정원 확인 필요 목록 -->
    <section class="tool-card" id="allSuspectSection" style="display:none;">
      <div class="tool-head card-head">
        <div>
          <h2 class="card-title">4) 전체 정원 확인 필요 목록</h2>
          <p class="tool-sub">엑셀 전체에서 “결원 의심(정원 확인 필요)”만 모아 보여줍니다.</p>
        </div>
        <div class="card-actions">
          <input id="allFilter" type="text" placeholder="학교/부서 검색 (예: 반곡중)" />
          <button id="btnDownloadAllCurrent" class="btn btn-lightgrey">현재 목록 CSV</button>
        </div>
      </div>

      <hr/>

      <p id="allStats" class="muted" style="margin-top:0;"></p>

      <div class="table-wrap sticky-wrap">
        <table class="sheetlike sticky-table" id="allTable">
          <thead>
            <tr>
              <th>직종</th>
              <th>시트</th>
              <th>학교(부서)</th>
              <th class="numeric">전출</th>
              <th class="numeric">전입</th>
              <th class="numeric">정원 확인 필요(전출-전입)</th>
              <th class="numeric">전입없음</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>

      <p class="muted">행을 클릭하면 아래 “학교 상세”에서 전입/전출 명단을 확인할 수 있습니다.</p>
    </section>

    <!-- 5) 상세 -->
    <section class="tool-card" id="detailSection" style="display:none;">
      <div class="tool-head card-head">
        <div>
          <h2 class="card-title">5) 상세(단위별 → 학교별)</h2>
          <p class="tool-sub">단위(직종/그룹/시트)를 고르고, 학교를 클릭하면 명단을 확인할 수 있습니다.</p>
        </div>
        <div class="card-actions">
          <span class="muted">단위</span>
          <select id="unitSelect"></select>

          <span class="muted">보기</span>
          <select id="modeSelect">
            <option value="suspect">정원 확인 필요(결원 의심)</option>
            <option value="all">전체</option>
            <option value="surplus">순증가(전입&gt;전출)</option>
            <option value="balanced">균형(전입=전출)</option>
          </select>
        </div>
      </div>

      <hr/>

      <div class="grid two">
        <div>
          <div class="row gap" style="margin-bottom:10px; flex-wrap:wrap;">
            <input id="schoolFilter" type="text" placeholder="학교/부서 검색 (예: 반곡중)" />
            <button id="btnDownloadCsv" class="btn btn-lightgrey">현재 목록 CSV</button>
          </div>

          <p id="unitDetailStats" class="muted" style="margin:0 0 10px;"></p>

          <div class="table-wrap sticky-wrap">
            <table class="sheetlike sticky-table" id="detailTable">
              <thead>
                <tr>
                  <th>학교(부서)</th>
                  <th class="numeric">전출</th>
                  <th class="numeric">전입</th>
                  <th class="numeric">차이(전출-전입)</th>
                  <th class="numeric">전입없음</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>

          <p class="muted">행 클릭 → 오른쪽에서 명단 확인</p>
        </div>

        <div class="card" id="schoolDetailCard">
          <h3 class="local-h3 local-tight">학교 상세</h3>
          <p class="muted" style="margin-top:0;">왼쪽에서 학교(부서)를 선택하세요.</p>
        </div>
      </div>
    </section>

    <!-- 로그 -->
    <section class="tool-card">
      <div class="tool-head">
        <h2 class="tool-title">처리 로그</h2>
        <p class="tool-sub">CSS/엑셀 파서 로드/분석 진행 상황을 확인할 수 있습니다.</p>
      </div>
      <hr/>
      <pre id="logBox" class="muted"></pre>
    </section>
  </main>

  <footer class="site-footer">
    <div class="shell">
      <p>※ 이 도구는 “전출/퇴직 &amp; 전입” 집계로 <b>정원 확인 필요 후보</b>를 빠르게 찾기 위한 화면입니다. 최종 결원 여부는 정원/배치 기준 확인이 필요합니다.</p>
    </div>
  </footer>

<script>
(() => {
  "use strict";

  // ---------------------------
  // DOM helpers
  // ---------------------------
  const $ = (sel) => document.querySelector(sel);

  const el = {
    fileInput: $("#fileInput"),
    fileMeta: $("#fileMeta"),
    btnAnalyze: $("#btnAnalyze"),
    btnClear: $("#btnClear"),
    libWarn: $("#libWarn"),

    optAutoDetect: $("#optAutoDetect"),
    optNormalize: $("#optNormalize"),

    colSeq: $("#colSeq"),
    colName: $("#colName"),
    colJob: $("#colJob"),
    colIn: $("#colIn"),
    colOut: $("#colOut"),
    colNote: $("#colNote"),

    groupRules: $("#groupRules"),
    btnApplyGroups: $("#btnApplyGroups"),
    btnFillGroupSample: $("#btnFillGroupSample"),
    groupHint: $("#groupHint"),

    jobSummarySection: $("#jobSummarySection"),
    unitModeSelect: $("#unitModeSelect"),
    unitStats: $("#unitStats"),
    unitColTitle: $("#unitColTitle"),
    jobSummaryBody: $("#jobSummaryTable tbody"),
    btnDownloadUnitSuspect: $("#btnDownloadUnitSuspect"),

    sheetSummarySection: $("#sheetSummarySection"),
    sheetSummaryBody: $("#sheetSummaryTable tbody"),
    btnDownloadAllNet: $("#btnDownloadAllNet"),

    allSuspectSection: $("#allSuspectSection"),
    allFilter: $("#allFilter"),
    allStats: $("#allStats"),
    allTableBody: $("#allTable tbody"),
    btnDownloadAllCurrent: $("#btnDownloadAllCurrent"),

    detailSection: $("#detailSection"),
    unitSelect: $("#unitSelect"),
    modeSelect: $("#modeSelect"),
    schoolFilter: $("#schoolFilter"),
    unitDetailStats: $("#unitDetailStats"),
    detailTableBody: $("#detailTable tbody"),
    btnDownloadCsv: $("#btnDownloadCsv"),
    schoolDetailCard: $("#schoolDetailCard"),

    logBox: $("#logBox"),
  };

  // ---------------------------
  // State
  // ---------------------------
  const state = {
    file: null,
    workbookName: "",
    analyzed: false,

    sheets: new Map(), // sheetName -> unitData
    sheetOrder: [],

    jobs: new Map(),   // jobName -> unitData
    jobOrder: [],

    groups: new Map(), // groupName -> unitData (TO 그룹)
    groupOrder: [],

    groupRulesParsed: null, // {groups: [{name, patterns:[...]}, ...]}

    unitMode: "job", // job | group | sheet
    selectedUnit: "",
    selectedSchool: "",

    lastUnitSummaryList: [], // 요약 CSV 용
    lastDetailList: [],      // 상세 CSV 용
    lastAllList: [],         // 전체 정원 확인 필요 CSV 용
  };

  // ---------------------------
  // Logging
  // ---------------------------
  function log(line) {
    const ts = new Date().toLocaleTimeString();
    el.logBox.textContent += `[${ts}] ${line}\n`;
    el.logBox.scrollTop = el.logBox.scrollHeight;
  }
  function clearLog() { el.logBox.textContent = ""; }

  // ---------------------------
  // Utilities
  // ---------------------------
  function escapeHtml(s) {
    return String(s ?? "")
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/\"/g, "&quot;")
      .replace(/'/g, "&#039;");
  }

  function bytesToHuman(bytes) {
    if (!Number.isFinite(bytes)) return "-";
    const units = ["B","KB","MB","GB"];
    let v = bytes, i = 0;
    while (v >= 1024 && i < units.length - 1) { v /= 1024; i++; }
    return `${v.toFixed(i === 0 ? 0 : 1)} ${units[i]}`;
  }

  function colToIndex(col) {
    const s = String(col ?? "").trim().toUpperCase();
    if (!s) return null;
    let n = 0;
    for (let i = 0; i < s.length; i++) {
      const code = s.charCodeAt(i);
      if (code < 65 || code > 90) return null;
      n = n * 26 + (code - 64);
    }
    return n - 1;
  }

  function indexToCol(idx) {
    if (!Number.isFinite(idx) || idx < 0) return "";
    let n = idx + 1;
    let out = "";
    while (n > 0) {
      const r = (n - 1) % 26;
      out = String.fromCharCode(65 + r) + out;
      n = Math.floor((n - 1) / 26);
    }
    return out;
  }

  function toIntLike(v) {
    if (typeof v === "number" && Number.isFinite(v)) return Math.trunc(v);
    const s = String(v ?? "").trim();
    if (!s) return null;
    if (/^\d+$/.test(s)) return parseInt(s, 10);
    return null;
  }

  function normalizeSchoolName(v, enabled) {
    if (!v) return "";
    const s = String(v);
    if (!enabled) return s.trim();
    return s.replace(/\s+/g, " ").trim();
  }

  function downloadCsv(filename, rows2d) {
    const bom = "\uFEFF"; // Excel 한글 깨짐 방지
    const csv = rows2d.map(row => row.map(cell => {
      const raw = String(cell ?? "");
      const escaped = raw.replace(/\"/g, '""');
      return `"${escaped}"`;
    }).join(",")).join("\n");

    const blob = new Blob([bom + csv], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1200);
  }

  function normalizeKey(s) {
    return String(s ?? "").replace(/\s+/g, "").trim();
  }

  // ---------------------------
  // XLSX loader (로컬 → CDN 폴백)
  // ---------------------------
  function loadScript(src) {
    return new Promise((resolve, reject) => {
      const s = document.createElement("script");
      s.src = src;
      s.onload = () => resolve(true);
      s.onerror = () => reject(new Error("script load fail: " + src));
      document.head.appendChild(s);
    });
  }

  async function ensureXLSX() {
    if (window.XLSX) return true;
    const sources = [
      "/static/xlsx.full.min.js",
      "static/xlsx.full.min.js",
      "https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"
    ];
    for (const src of sources) {
      try {
        log(`엑셀 파서 로드 시도: ${src}`);
        await loadScript(src);
        if (window.XLSX) {
          log("엑셀 파서 로드 완료 ✅");
          return true;
        }
      } catch {
        log(`로드 실패: ${src}`);
      }
    }
    return false;
  }

  function setLibWarning(ok) {
    if (ok) {
      el.libWarn.style.display = "none";
      el.btnAnalyze.disabled = false;
      return;
    }
    el.libWarn.style.display = "";
    el.libWarn.textContent =
      "⚠️ 엑셀 파서(XLSX)가 로드되지 않았습니다. " +
      "폐쇄망이면 /static/xlsx.full.min.js 를 프로젝트에 추가하세요. (또는 인터넷 환경에서 CDN 사용)";
    el.btnAnalyze.disabled = true;
  }

  // ---------------------------
  // Layout detection (자동 컬럼 감지)
  // ---------------------------
  function cellStr(v) {
    return String(v ?? "").replace(/\s+/g, " ").trim();
  }

  function cellKey(v) {
    // '성 명', '부 서' 처럼 띄어쓴 헤더도 동일하게 잡기 위해 공백을 제거합니다.
    return normalizeKey(cellStr(v));
  }

  function forwardFill(keys) {
    // 병합셀(merged cell) 때문에 중간이 빈 경우가 많아서,
    // 왼쪽 값을 오른쪽으로 '흘려보내는' 방식으로 헤더 힌트를 보강합니다.
    const out = [];
    let last = "";
    for (const k of keys) {
      if (k) { last = k; out.push(k); }
      else { out.push(last); }
    }
    return out;
  }

  function countHeaderSignals(keys, RE) {
    let c = 0;
    for (const k of keys) {
      if (!k) continue;
      if (RE.seq.test(k) || RE.name.test(k) || RE.job.test(k) || RE.note.test(k) || RE.place.test(k)) c++;
    }
    return c;
  }

  function findIdxPrefer(primaryKeys, secondaryKeys, re) {
    // 1) 필드 라벨로 보이는 행(대개 하단 행)을 우선
    for (let i = 0; i < primaryKeys.length; i++) {
      if (primaryKeys[i] && re.test(primaryKeys[i])) return i;
    }
    // 2) 그 다음 상단 행
    for (let i = 0; i < secondaryKeys.length; i++) {
      if (secondaryKeys[i] && re.test(secondaryKeys[i])) return i;
    }
    return -1;
  }

  function detectLayout(rows) {
    // 목표: 엑셀 서식이 지역마다 달라도
    // - 2단 헤더(임용사항/현직 + 하단에 직종/부서) 형태
    // - 1단 헤더(전입부서/전출부서) 형태
    // - '성 명', '부 서' 같이 띄어쓰기된 헤더
    // 를 최대한 자동으로 잡아냅니다.

    const RE = {
      seq: /(연번|순번|일련|번호)/,
      name: /(성명|이름)/,
      job: /(직종|직종명|직명)/,
      note: /(비고|특이|사유)/,
      place: /(부서|근무처|근무지|기관|학교|소속)/,

      // 방향 힌트(전입=도착, 전출/퇴직=출발)
      inHint: /(임용|전입|발령후|신규|도착|변경후|임용사항|전보후)/,
      outHint: /(현직|현근무|현근무처|전출|퇴직|발령전|출발|변경전|종전|전보전)/,
    };

    const maxScan = Math.min(rows.length, 60);
    let best = null;

    for (let r = 0; r < maxScan; r++) {
      const topRow = rows[r] || [];
      const botRow = rows[r + 1] || [];

      const n = Math.max(topRow.length, botRow.length);
      if (n <= 0) continue;

      const topKeys = Array.from({ length: n }, (_, i) => cellKey(topRow[i]));
      const botKeys = Array.from({ length: n }, (_, i) => cellKey(botRow[i]));
      const topFF = forwardFill(topKeys);

      // 어떤 행이 '실제 필드 라벨(성명/직종/부서...)'인지 추정
      const topCnt = countHeaderSignals(topKeys, RE);
      const botCnt = countHeaderSignals(botKeys, RE);

      const fieldKeys = (botCnt >= topCnt) ? botKeys : topKeys;
      const otherKeys = (fieldKeys === botKeys) ? topKeys : botKeys;

      const seqIdx = findIdxPrefer(fieldKeys, otherKeys, RE.seq);
      const nameIdx = findIdxPrefer(fieldKeys, otherKeys, RE.name);
      const jobIdx = findIdxPrefer(fieldKeys, otherKeys, RE.job);
      const noteIdx = findIdxPrefer(fieldKeys, otherKeys, RE.note);

      // 근무처/부서(학교) 컬럼 후보: 필드 라벨 행을 우선 사용
      let placeCols = [];
      for (let i = 0; i < n; i++) {
        if (fieldKeys[i] && RE.place.test(fieldKeys[i])) placeCols.push(i);
      }
      if (placeCols.length < 2) {
        placeCols = [];
        for (let i = 0; i < n; i++) {
          if ((topKeys[i] && RE.place.test(topKeys[i])) || (botKeys[i] && RE.place.test(botKeys[i]))) {
            placeCols.push(i);
          }
        }
      }

      if (seqIdx < 0 || nameIdx < 0 || placeCols.length < 2) continue;

      // 전입/전출 컬럼 결정: 상단(그룹헤더) + 필드라벨을 합쳐 방향 힌트 점수화
      const scored = placeCols.map((i) => {
        const combined = (topFF[i] || "") + (fieldKeys[i] || "");
        let inScore = 0;
        let outScore = 0;

        if (RE.inHint.test(combined)) inScore += 3;
        if (RE.outHint.test(combined)) outScore += 3;

        if (fieldKeys[i]) {
          if (RE.inHint.test(fieldKeys[i])) inScore += 2;
          if (RE.outHint.test(fieldKeys[i])) outScore += 2;
        }
        if (topFF[i]) {
          if (RE.inHint.test(topFF[i])) inScore += 2;
          if (RE.outHint.test(topFF[i])) outScore += 2;
        }

        return { i, inScore, outScore };
      });

      const inSorted = [...scored].sort((a, b) =>
        (b.inScore - a.inScore) ||
        (a.outScore - b.outScore) ||
        (a.i - b.i)
      );

      const outSorted = [...scored].sort((a, b) =>
        (b.outScore - a.outScore) ||
        (a.inScore - b.inScore) ||
        (a.i - b.i)
      );

      let inIdx = inSorted[0]?.i ?? -1;
      let outIdx = outSorted[0]?.i ?? -1;

      if (inIdx === outIdx) {
        outIdx = outSorted.find(x => x.i !== inIdx)?.i ?? -1;
      }
      if (inIdx === outIdx || inIdx < 0 || outIdx < 0) {
        // 힌트가 애매하면 "왼쪽=전입, 오른쪽=전출"로 단순 가정
        inIdx = placeCols[0];
        outIdx = placeCols[1];
      }

      const score =
        (seqIdx >= 0 ? 2 : 0) +
        (nameIdx >= 0 ? 2 : 0) +
        ((inIdx >= 0 && outIdx >= 0 && inIdx !== outIdx) ? 2 : 0) +
        (jobIdx >= 0 ? 1 : 0) +
        (noteIdx >= 0 ? 1 : 0);

      if (!best || score > best.score) {
        best = {
          headerIdx: r,
          subIdx: r + 1,
          seqIdx,
          nameIdx,
          jobIdx,
          inIdx,
          outIdx,
          noteIdx: noteIdx >= 0 ? noteIdx : -1,
          detected: true,
          score,
        };
      }
    }

    return best;
  }

// ---------------------------
  // Unit data
  // ---------------------------
  function makeUnitData(name, kind) {
    return {
      name,
      kind, // sheet | job | group
      moves: [],
      schools: new Map(), // school -> {inCount,outCount,inMoves,outMoves}
      sourceSheets: new Set(),
      summary: null,
    };
  }

  function getSchool(unit, school) {
    if (!unit.schools.has(school)) {
      unit.schools.set(school, { inCount: 0, outCount: 0, inMoves: [], outMoves: [] });
    }
    return unit.schools.get(school);
  }

  function addMoveToUnit(unit, move, normOn) {
    unit.moves.push(move);
    unit.sourceSheets.add(move.sheetName);

    const inSchool = normalizeSchoolName(move.inSchool, normOn);
    const outSchool = normalizeSchoolName(move.outSchool, normOn);

    if (inSchool) {
      const s = getSchool(unit, inSchool);
      s.inCount++;
      s.inMoves.push(move);
    }
    if (outSchool) {
      const s = getSchool(unit, outSchool);
      s.outCount++;
      s.outMoves.push(move);
    }
  }

  function finalizeSummary(unit) {
    let incomingTotal = 0;
    let outgoingTotal = 0;
    let suspectSchools = 0;
    let suspectPositions = 0;
    let surplusSchools = 0;
    let surplusPositions = 0;

    for (const [, info] of unit.schools) {
      incomingTotal += info.inCount;
      outgoingTotal += info.outCount;
      const diff = info.outCount - info.inCount;
      if (diff > 0) { suspectSchools++; suspectPositions += diff; }
      if (diff < 0) { surplusSchools++; surplusPositions += (-diff); }
    }

    unit.summary = {
      name: unit.name,
      kind: unit.kind,
      recordCount: unit.moves.length,
      incomingTotal,
      outgoingTotal,
      suspectSchools,
      suspectPositions,
      surplusSchools,
      surplusPositions,
      netDiff: outgoingTotal - incomingTotal,
      sheetCount: unit.sourceSheets.size,
    };
  }

  // ---------------------------
  // TO group rules
  // ---------------------------
  function parseGroupRules(text) {
    const lines = String(text ?? "").split(/\r?\n/);
    const groups = [];

    for (let raw of lines) {
      raw = raw.replace(/(#|\/\/).*$/, "").trim();
      if (!raw) continue;

      let sep = null;
      for (const s of ["=", ":", "->", "⇒"]) {
        if (raw.includes(s)) { sep = s; break; }
      }
      if (!sep) continue;

      const parts = raw.split(sep);
      if (parts.length < 2) continue;

      const name = parts[0].trim();
      const rhs = parts.slice(1).join(sep).trim();
      if (!name || !rhs) continue;

      const patterns = rhs.split(",").map(x => x.trim()).filter(Boolean);
      if (!patterns.length) continue;

      groups.push({ name, patterns });
    }

    return { groups };
  }

  function matchPattern(jobName, pattern) {
    const j = normalizeKey(jobName);
    const p = String(pattern ?? "").trim();
    if (!p) return false;

    // 간단 와일드카드(*) 지원
    if (p.includes("*")) {
      const esc = p.replace(/[.+?^${}()|[\]\\]/g, "\\$&").replace(/\*/g, ".*");
      const re = new RegExp("^" + esc + "$", "i");
      return re.test(jobName) || re.test(j);
    }

    // 기본: 공백 제거 후 동일
    return normalizeKey(p) === j;
  }

  function buildGroupsFromRules() {
    state.groups.clear();
    state.groupOrder = [];

    const parsed = state.groupRulesParsed;
    if (!parsed || !parsed.groups || !parsed.groups.length) {
      // 규칙 없으면 그룹=직종과 동일
      for (const [jobName, jobUnit] of state.jobs.entries()) {
        const g = makeUnitData(jobName, "group");
        for (const mv of jobUnit.moves) g.moves.push(mv);
        // schools는 재집계(정규화 옵션 영향 동일)
        g.schools = new Map();
        g.sourceSheets = new Set(jobUnit.sourceSheets);
        // moves 기반으로 다시 채우기
        for (const mv of jobUnit.moves) {
          // addMoveToUnit는 unit.moves push도 하므로 여기서는 school만 채움
          const inS = mv.inSchool;
          const outS = mv.outSchool;
          if (inS) {
            const s = getSchool(g, normalizeSchoolName(inS, el.optNormalize.checked));
            s.inCount++; s.inMoves.push(mv);
          }
          if (outS) {
            const s = getSchool(g, normalizeSchoolName(outS, el.optNormalize.checked));
            s.outCount++; s.outMoves.push(mv);
          }
        }
        finalizeSummary(g);
        state.groups.set(jobName, g);
        state.groupOrder.push(jobName);
      }
      el.groupHint.textContent = "(규칙 없음) → TO 그룹 = 직종";
      return;
    }

    const jobToGroup = new Map();
    for (const jobName of state.jobOrder) {
      let found = null;
      for (const g of parsed.groups) {
        if (g.patterns.some(p => matchPattern(jobName, p))) { found = g.name; break; }
      }
      jobToGroup.set(jobName, found || jobName);
    }

    // 그룹 생성
    for (const jobName of state.jobOrder) {
      const groupName = jobToGroup.get(jobName) || jobName;
      if (!state.groups.has(groupName)) state.groups.set(groupName, makeUnitData(groupName, "group"));
      const groupUnit = state.groups.get(groupName);
      const jobUnit = state.jobs.get(jobName);
      if (!jobUnit) continue;

      // moves 추가
      for (const mv of jobUnit.moves) {
        groupUnit.moves.push(mv);
      }
      for (const sn of jobUnit.sourceSheets) groupUnit.sourceSheets.add(sn);

      // schools 병합
      for (const [school, info] of jobUnit.schools.entries()) {
        const s = getSchool(groupUnit, school);
        s.inCount += info.inCount;
        s.outCount += info.outCount;
        s.inMoves.push(...info.inMoves);
        s.outMoves.push(...info.outMoves);
      }
    }

    // summary
    state.groupOrder = [...state.groups.keys()].sort((a,b) => a.localeCompare(b, "ko"));
    for (const [, u] of state.groups) finalizeSummary(u);

    el.groupHint.textContent = `그룹 ${state.groups.size}개 적용됨`;
  }

  // ---------------------------
  // Analysis
  // ---------------------------
  async function analyzeCurrentFile() {
    clearLog();

    if (!state.file) {
      log("파일이 선택되지 않았습니다.");
      return;
    }

    const ok = await ensureXLSX();
    setLibWarning(ok);
    if (!ok) {
      log("XLSX 라이브러리 없음 → 분석 중단");
      return;
    }

    log(`분석 시작: ${state.file.name}`);

    // 수동 컬럼
    const seqIdxManual = colToIndex(el.colSeq.value);
    const nameIdxManual = colToIndex(el.colName.value);
    const jobIdxManual = colToIndex(el.colJob.value);
    const inIdxManual = colToIndex(el.colIn.value);
    const outIdxManual = colToIndex(el.colOut.value);
    const noteIdxManual = colToIndex(el.colNote.value);

    const badCols = [
      ["연번", seqIdxManual],
      ["성명", nameIdxManual],
      ["직종", jobIdxManual],
      ["전입(부서)", inIdxManual],
      ["전출(부서)", outIdxManual],
      ["비고", noteIdxManual],
    ].filter(([, idx]) => idx === null);

    if (badCols.length) {
      log("컬럼 입력이 잘못되었습니다: " + badCols.map(([k]) => k).join(", "));
      return;
    }

    const normOn = el.optNormalize.checked;
    const autoOn = el.optAutoDetect.checked;

    const buf = await state.file.arrayBuffer();
    const wb = XLSX.read(buf, { type: "array" });

    state.workbookName = state.file.name;
    state.sheets.clear();
    state.jobs.clear();
    state.groups.clear();

    state.sheetOrder = wb.SheetNames.slice();
    state.jobOrder = [];

    log(`시트 ${state.sheetOrder.length}개 발견: ${state.sheetOrder.join(", ")}`);

    // 1) 시트 단위 파싱
    for (const sheetName of state.sheetOrder) {
      const ws = wb.Sheets[sheetName];
      const rows = XLSX.utils.sheet_to_json(ws, { header: 1, defval: "" });

      // 레이아웃 결정
      let layout = null;
      if (autoOn) {
        layout = detectLayout(rows);
        if (layout) {
          log(`- [${sheetName}] 자동감지 OK: seq=${indexToCol(layout.seqIdx)}, name=${indexToCol(layout.nameIdx)}, job=${layout.jobIdx>=0?indexToCol(layout.jobIdx):"(없음)"}, in=${indexToCol(layout.inIdx)}, out=${indexToCol(layout.outIdx)}, note=${layout.noteIdx>=0?indexToCol(layout.noteIdx):"(없음)"}`);
        } else {
          log(`- [${sheetName}] 자동감지 실패 → 수동 매핑 사용`);
        }
      }

      const seqIdx = layout ? layout.seqIdx : seqIdxManual;
      const nameIdx = layout ? layout.nameIdx : nameIdxManual;
      const jobIdx = layout ? layout.jobIdx : jobIdxManual;
      const inIdx = layout ? layout.inIdx : inIdxManual;
      const outIdx = layout ? layout.outIdx : outIdxManual;
      const noteIdx = layout ? layout.noteIdx : noteIdxManual;

      const sheetUnit = makeUnitData(sheetName, "sheet");

      let recordCount = 0;
      for (let r = 0; r < rows.length; r++) {
        const row = rows[r] || [];

        const seq = toIntLike(row[seqIdx]);
        if (seq === null) continue; // 헤더/공백 제외

        recordCount++;

        const name = String(row[nameIdx] ?? "").trim();
        const rawJob = jobIdx >= 0 ? String(row[jobIdx] ?? "").trim() : "";
        const jobName = rawJob || sheetName;

        const inSchool = normalizeSchoolName(row[inIdx], normOn);
        const outSchool = normalizeSchoolName(row[outIdx], normOn);
        const note = noteIdx >= 0 ? String(row[noteIdx] ?? "").trim() : "";

        const move = {
          sheetName,
          jobName,
          seq,
          name,
          inSchool,
          outSchool,
          note,
          rowIndex: r + 1,
        };

        // sheet
        addMoveToUnit(sheetUnit, move, normOn);

        // job
        if (!state.jobs.has(jobName)) {
          state.jobs.set(jobName, makeUnitData(jobName, "job"));
          state.jobOrder.push(jobName);
        }
        addMoveToUnit(state.jobs.get(jobName), move, normOn);
      }

      // 시트 summary
      finalizeSummary(sheetUnit);
      state.sheets.set(sheetName, sheetUnit);

      log(`  → [${sheetName}] 기록 ${recordCount}건, 전입 ${sheetUnit.summary.incomingTotal}, 전출/퇴직 ${sheetUnit.summary.outgoingTotal}, 정원 확인 필요 ${sheetUnit.summary.suspectPositions}`);
    }

    // 직종/그룹 summary
    for (const [, u] of state.jobs) finalizeSummary(u);

    // 직종 정렬(한국어)
    state.jobOrder = [...new Set(state.jobOrder)].sort((a,b) => a.localeCompare(b, "ko"));

    // 그룹 규칙 적용
    state.groupRulesParsed = parseGroupRules(el.groupRules.value);
    buildGroupsFromRules();

    state.analyzed = true;

    // 기본 모드: job
    state.unitMode = "job";
    el.unitModeSelect.value = state.unitMode;

    // 렌더
    renderUnitSummary();
    renderSheetSummary();
    renderAllSuspect();
    initUnitSelect();
    renderDetail(state.selectedUnit || getDefaultUnitName());

    // 섹션 표시
    el.jobSummarySection.style.display = "";
    el.sheetSummarySection.style.display = "";
    el.allSuspectSection.style.display = "";
    el.detailSection.style.display = "";

    log("분석 완료 ✅");
  }

  function getDefaultUnitName() {
    if (state.unitMode === "job") return state.jobOrder[0] || "";
    if (state.unitMode === "group") return state.groupOrder[0] || "";
    return state.sheetOrder[0] || "";
  }

  function getUnitMapAndOrder() {
    if (state.unitMode === "job") return { map: state.jobs, order: state.jobOrder, title: "직종" };
    if (state.unitMode === "group") return { map: state.groups, order: state.groupOrder, title: "TO 그룹" };
    return { map: state.sheets, order: state.sheetOrder, title: "시트" };
  }

  // ---------------------------
  // Rendering
  // ---------------------------
  function renderUnitSummary() {
    const { map, order, title } = getUnitMapAndOrder();
    el.unitColTitle.textContent = title;

    el.jobSummaryBody.innerHTML = "";
    const frag = document.createDocumentFragment();

    const list = [];

    for (const name of order) {
      const u = map.get(name);
      if (!u || !u.summary) continue;
      const s = u.summary;

      list.push(s);

      const tr = document.createElement("tr");
      tr.className = "clickable";
      tr.dataset.unit = name;

      const netPill =
        s.netDiff > 0 ? `<span class="pill red">+${s.netDiff}</span>` :
        s.netDiff < 0 ? `<span class="pill blue">${s.netDiff}</span>` :
        `<span class="pill gray">0</span>`;

      tr.innerHTML = `
        <td><b>${escapeHtml(name)}</b>${state.unitMode === "job" && s.sheetCount > 1 ? ` <span class="pill gray">시트 ${s.sheetCount}</span>` : ""}</td>
        <td class="numeric">${s.incomingTotal}</td>
        <td class="numeric">${s.outgoingTotal}</td>
        <td class="numeric">${s.suspectSchools}</td>
        <td class="numeric">${s.suspectPositions}</td>
        <td class="numeric">${s.surplusSchools}</td>
        <td class="numeric">${s.surplusPositions}</td>
        <td class="numeric">${netPill}</td>
      `;

      tr.addEventListener("click", () => {
        state.selectedUnit = name;
        el.unitSelect.value = name;
        renderDetail(name);
        document.getElementById("detailSection")?.scrollIntoView({ behavior: "smooth", block: "start" });
      });

      frag.appendChild(tr);
    }

    el.jobSummaryBody.appendChild(frag);

    state.lastUnitSummaryList = list;
    el.unitStats.innerHTML = `총 <b>${order.length}</b>${title === "시트" ? "개" : "개"}`;

    // 단위 선택 리스트도 동기화
    initUnitSelect();
  }

  function renderSheetSummary() {
    el.sheetSummaryBody.innerHTML = "";
    const frag = document.createDocumentFragment();

    for (const sheetName of state.sheetOrder) {
      const u = state.sheets.get(sheetName);
      if (!u || !u.summary) continue;
      const s = u.summary;

      const tr = document.createElement("tr");
      tr.className = "clickable";
      tr.dataset.sheet = sheetName;

      const netPill =
        s.netDiff > 0 ? `<span class="pill red">+${s.netDiff}</span>` :
        s.netDiff < 0 ? `<span class="pill blue">${s.netDiff}</span>` :
        `<span class="pill gray">0</span>`;

      tr.innerHTML = `
        <td><b>${escapeHtml(sheetName)}</b></td>
        <td class="numeric">${s.incomingTotal}</td>
        <td class="numeric">${s.outgoingTotal}</td>
        <td class="numeric">${s.suspectSchools}</td>
        <td class="numeric">${s.suspectPositions}</td>
        <td class="numeric">${s.surplusSchools}</td>
        <td class="numeric">${s.surplusPositions}</td>
        <td class="numeric">${netPill}</td>
      `;

      tr.addEventListener("click", () => {
        state.unitMode = "sheet";
        el.unitModeSelect.value = "sheet";
        renderUnitSummary();

        state.selectedUnit = sheetName;
        el.unitSelect.value = sheetName;
        renderDetail(sheetName);
        document.getElementById("detailSection")?.scrollIntoView({ behavior: "smooth", block: "start" });
      });

      frag.appendChild(tr);
    }

    el.sheetSummaryBody.appendChild(frag);
  }

  function initUnitSelect() {
    const { order } = getUnitMapAndOrder();
    el.unitSelect.innerHTML = "";
    const frag = document.createDocumentFragment();

    for (const name of order) {
      const opt = document.createElement("option");
      opt.value = name;
      opt.textContent = name;
      frag.appendChild(opt);
    }
    el.unitSelect.appendChild(frag);

    if (!state.selectedUnit || !order.includes(state.selectedUnit)) {
      state.selectedUnit = getDefaultUnitName();
    }
    if (state.selectedUnit) el.unitSelect.value = state.selectedUnit;
  }

  function renderAllSuspect() {
    const q = (el.allFilter.value || "").trim();
    const rows = [];

    // 직종 단위로 모으되, 시트 정보도 함께 표시
    for (const jobName of state.jobOrder) {
      const jobUnit = state.jobs.get(jobName);
      if (!jobUnit) continue;

      for (const [school, info] of jobUnit.schools.entries()) {
        const diff = info.outCount - info.inCount;
        if (diff <= 0) continue;
        if (q && !school.includes(q)) continue;

        // 이 학교 관련 move들에서 시트명을 모아 표시(최대 3개)
        const sheetSet = new Set();
        for (const m of info.outMoves) sheetSet.add(m.sheetName);
        for (const m of info.inMoves) sheetSet.add(m.sheetName);
        const sheetList = [...sheetSet].sort((a,b)=>a.localeCompare(b,"ko"));

        rows.push({
          jobName,
          sheetText: sheetList.slice(0, 3).join(", ") + (sheetList.length > 3 ? ` 외 ${sheetList.length - 3}` : ""),
          school,
          outC: info.outCount,
          inC: info.inCount,
          diff,
          noIncoming: (info.inCount === 0 && info.outCount > 0),
          info,
        });
      }
    }

    rows.sort((a, b) => {
      if (b.diff !== a.diff) return b.diff - a.diff;
      const j = a.jobName.localeCompare(b.jobName, "ko");
      if (j !== 0) return j;
      return a.school.localeCompare(b.school, "ko");
    });

    state.lastAllList = rows;

    el.allStats.innerHTML =
      `정원 확인 필요 <b>${rows.length}</b>건` +
      (q ? ` · 필터: <span class="pill gray">${escapeHtml(q)}</span>` : "");

    el.allTableBody.innerHTML = "";
    const frag = document.createDocumentFragment();

    for (const r of rows) {
      const tr = document.createElement("tr");
      tr.className = "clickable";
      tr.dataset.job = r.jobName;
      tr.dataset.school = r.school;

      tr.innerHTML = `
        <td><b>${escapeHtml(r.jobName)}</b></td>
        <td>${escapeHtml(r.sheetText || "-")}</td>
        <td>${escapeHtml(r.school)}</td>
        <td class="numeric">${r.outC}</td>
        <td class="numeric">${r.inC}</td>
        <td class="numeric"><span class="pill red">+${r.diff}</span></td>
        <td class="numeric">${r.noIncoming ? '<span class="pill red">Y</span>' : '<span class="pill gray">-</span>'}</td>
      `;

      tr.addEventListener("click", () => {
        // 상세 단위는 직종으로 이동
        state.unitMode = "job";
        el.unitModeSelect.value = "job";
        renderUnitSummary();

        state.selectedUnit = r.jobName;
        el.unitSelect.value = r.jobName;
        renderDetail(r.jobName);

        renderSchoolDetail({ unitName: r.jobName, unitKind: "job", school: r.school, info: r.info });

        setTimeout(() => highlightSchoolRow(r.school), 0);
        document.getElementById("detailSection")?.scrollIntoView({ behavior: "smooth", block: "start" });
      });

      frag.appendChild(tr);
    }

    el.allTableBody.appendChild(frag);
  }

  function highlightSchoolRow(school) {
    const trs = [...el.detailTableBody.querySelectorAll("tr")];
    trs.forEach(t => t.classList.remove("is-selected"));
    const hit = trs.find(t => t.dataset.school === school);
    if (hit) hit.classList.add("is-selected");
  }

  function renderDetail(unitName) {
    if (!unitName) return;

    const { map, title } = getUnitMapAndOrder();
    const unit = map.get(unitName);
    if (!unit || !unit.summary) return;

    state.selectedUnit = unitName;
    state.selectedSchool = "";

    const mode = el.modeSelect.value;
    const q = (el.schoolFilter.value || "").trim();
    const schools = [];

    for (const [school, info] of unit.schools.entries()) {
      const outC = info.outCount;
      const inC = info.inCount;
      const diff = outC - inC;
      const noIncoming = inC === 0 && outC > 0;

      if (q && !school.includes(q)) continue;
      if (mode === "suspect" && diff <= 0) continue;
      if (mode === "surplus" && diff >= 0) continue;
      if (mode === "balanced" && diff !== 0) continue;

      schools.push({ school, outC, inC, diff, noIncoming, info });
    }

    schools.sort((a, b) => {
      if (mode === "suspect") {
        if (b.diff !== a.diff) return b.diff - a.diff;
      } else if (mode === "surplus") {
        if (a.diff !== b.diff) return a.diff - b.diff;
      } else {
        const ad = Math.abs(a.diff), bd = Math.abs(b.diff);
        if (bd !== ad) return bd - ad;
      }
      return a.school.localeCompare(b.school, "ko");
    });

    state.lastDetailList = schools;

    const s = unit.summary;
    const modeLabel =
      mode === "suspect" ? "정원 확인 필요" :
      mode === "surplus" ? "순증가" :
      mode === "balanced" ? "균형" : "전체";

    el.unitDetailStats.innerHTML =
      `<b>${escapeHtml(unitName)}</b> <span class="pill gray">${escapeHtml(title)}</span>` +
      ` · 기록 ${s.recordCount}건 · 전입 ${s.incomingTotal} / 전출·퇴직 ${s.outgoingTotal}` +
      ` · 정원 확인 필요 인원 ${s.suspectPositions}` +
      ` · 현재보기: <span class="pill gray">${modeLabel} ${schools.length}건</span>`;

    el.detailTableBody.innerHTML = "";
    const frag = document.createDocumentFragment();

    for (const row of schools) {
      const tr = document.createElement("tr");
      tr.className = "clickable";
      tr.dataset.school = row.school;

      const diffClass = row.diff > 0 ? "pos" : row.diff < 0 ? "neg" : "zero";
      const diffText = row.diff > 0 ? `+${row.diff}` : String(row.diff);

      tr.innerHTML = `
        <td>${escapeHtml(row.school)}</td>
        <td class="numeric">${row.outC}</td>
        <td class="numeric">${row.inC}</td>
        <td class="numeric"><span class="diff ${diffClass}">${escapeHtml(diffText)}</span></td>
        <td class="numeric">${row.noIncoming ? '<span class="pill red">Y</span>' : '<span class="pill gray">-</span>'}</td>
      `;

      tr.addEventListener("click", () => {
        state.selectedSchool = row.school;
        renderSchoolDetail({ unitName, unitKind: state.unitMode, school: row.school, info: row.info });

        [...el.detailTableBody.querySelectorAll("tr")].forEach(x => x.classList.remove("is-selected"));
        tr.classList.add("is-selected");
      });

      frag.appendChild(tr);
    }

    el.detailTableBody.appendChild(frag);
  }

  function renderSchoolDetail(payload) {
    if (!payload) {
      el.schoolDetailCard.innerHTML = `
        <h3 class="local-h3 local-tight">학교 상세</h3>
        <p class="muted" style="margin-top:0;">왼쪽에서 학교(부서)를 선택하세요.</p>
      `;
      return;
    }

    const { unitName, unitKind, school, info } = payload;
    const diff = info.outCount - info.inCount;

    const badge =
      diff > 0 ? `<span class="pill red">결원 의심(정원 확인 필요) +${diff}</span>` :
      diff < 0 ? `<span class="pill blue">순증가 ${-diff}</span>` :
      `<span class="pill gray">균형 0</span>`;

    const outList = info.outMoves
      .slice()
      .sort((a,b) => a.seq - b.seq)
      .map(m => `
        <li>
          <span class="who">${escapeHtml(m.name || "(이름없음)")}</span>
          <span class="meta">→ ${escapeHtml(m.inSchool || "-")}
            ${m.note ? ` <span class="pill gray">${escapeHtml(m.note)}</span>` : ""}
            ${m.jobName && unitKind !== "job" ? ` <span class="pill gray">${escapeHtml(m.jobName)}</span>` : ""}
          </span>
        </li>
      `).join("");

    const inList = info.inMoves
      .slice()
      .sort((a,b) => a.seq - b.seq)
      .map(m => `
        <li>
          <span class="who">${escapeHtml(m.name || "(이름없음)")}</span>
          <span class="meta">← ${escapeHtml(m.outSchool || "-")}
            ${m.note ? ` <span class="pill gray">${escapeHtml(m.note)}</span>` : ""}
            ${m.jobName && unitKind !== "job" ? ` <span class="pill gray">${escapeHtml(m.jobName)}</span>` : ""}
          </span>
        </li>
      `).join("");

    el.schoolDetailCard.innerHTML = `
      <div class="row between" style="flex-wrap:wrap; margin-bottom:8px;">
        <h3 class="local-h3 local-tight" style="margin:0;">${escapeHtml(school)}</h3>
        ${badge}
      </div>
      <p class="muted" style="margin-top:0;">
        단위: <b>${escapeHtml(unitName)}</b> · 전출/퇴직 <b>${info.outCount}</b> · 전입 <b>${info.inCount}</b>
      </p>

      <div class="grid two">
        <div class="card">
          <h4 class="local-h4 local-tight" style="margin:0;">전출/퇴직 명단</h4>
          <p class="muted" style="margin:6px 0 0;">(이 학교를 떠나는 사람들)</p>
          <ul class="clean-list">${outList || `<li class="muted">없음</li>`}</ul>
        </div>
        <div class="card">
          <h4 class="local-h4 local-tight" style="margin:0;">전입 명단</h4>
          <p class="muted" style="margin:6px 0 0;">(이 학교로 오는 사람들)</p>
          <ul class="clean-list">${inList || `<li class="muted">없음</li>`}</ul>
        </div>
      </div>

      <p class="note">
        ※ <b>결원 의심(정원 확인 필요)</b>는 “전출/퇴직 &gt; 전입” 집계 기반의 후보입니다. 직종/근무형태/정원·배치 기준에 따라 달라질 수 있으니 정원 확인이 필요합니다.
      </p>
    `;
  }

  // ---------------------------
  // Events
  // ---------------------------
  el.fileInput.addEventListener("change", () => {
    const f = el.fileInput.files && el.fileInput.files[0];
    state.file = f || null;
    state.analyzed = false;

    if (!state.file) {
      el.fileMeta.textContent = "아직 파일이 없습니다.";
      return;
    }

    el.fileMeta.innerHTML =
      `<b>${escapeHtml(state.file.name)}</b> · ${bytesToHuman(state.file.size)} · 수정 ${escapeHtml(new Date(state.file.lastModified).toLocaleString())}`;
    log(`파일 선택: ${state.file.name}`);
  });

  el.btnAnalyze.addEventListener("click", () => {
    analyzeCurrentFile().catch(err => {
      console.error(err);
      log("에러: " + (err && err.message ? err.message : String(err)));
    });
  });

  el.btnClear.addEventListener("click", () => {
    state.file = null;
    state.analyzed = false;

    state.sheets.clear();
    state.jobs.clear();
    state.groups.clear();

    state.sheetOrder = [];
    state.jobOrder = [];
    state.groupOrder = [];

    state.selectedUnit = "";
    state.selectedSchool = "";

    state.lastUnitSummaryList = [];
    state.lastDetailList = [];
    state.lastAllList = [];

    el.fileInput.value = "";
    el.fileMeta.textContent = "아직 파일이 없습니다.";

    el.jobSummarySection.style.display = "none";
    el.sheetSummarySection.style.display = "none";
    el.allSuspectSection.style.display = "none";
    el.detailSection.style.display = "none";

    el.jobSummaryBody.innerHTML = "";
    el.sheetSummaryBody.innerHTML = "";
    el.allTableBody.innerHTML = "";
    el.detailTableBody.innerHTML = "";
    el.unitSelect.innerHTML = "";

    el.schoolFilter.value = "";
    el.allFilter.value = "";

    renderSchoolDetail(null);

    clearLog();
    log("초기화 완료");
  });

  el.unitModeSelect.addEventListener("change", () => {
    if (!state.analyzed) return;

    state.unitMode = el.unitModeSelect.value;
    renderUnitSummary();

    state.selectedUnit = getDefaultUnitName();
    initUnitSelect();
    renderDetail(state.selectedUnit);
  });

  el.unitSelect.addEventListener("change", () => {
    renderDetail(el.unitSelect.value);
  });

  el.modeSelect.addEventListener("change", () => {
    renderDetail(state.selectedUnit);
  });

  el.schoolFilter.addEventListener("input", () => {
    renderDetail(state.selectedUnit);
  });

  el.allFilter.addEventListener("input", () => {
    if (!state.analyzed) return;
    renderAllSuspect();
  });

  el.btnApplyGroups.addEventListener("click", () => {
    state.groupRulesParsed = parseGroupRules(el.groupRules.value);
    buildGroupsFromRules();
    if (!state.analyzed) return;

    // 그룹 모드라면 즉시 반영
    if (state.unitMode === "group") {
      renderUnitSummary();
      state.selectedUnit = getDefaultUnitName();
      initUnitSelect();
      renderDetail(state.selectedUnit);
    }
    log("TO 그룹 규칙 적용 완료");
  });

  el.btnFillGroupSample?.addEventListener("click", () => {
    const sample = [
      "# 예시(기관별 TO 기준은 다를 수 있어요. 필요에 맞게 수정)",
      "급식 = 영양사, 조리사, 조리실무사*",
      "늘봄 = 방과후전담사*, 늘봄학교전담사*, 유치원방과후교육사*",
    ].join("\n");
    el.groupRules.value = sample;
    el.groupHint.textContent = "예시 입력됨 → '그룹 규칙 적용'을 눌러 반영";
    log("TO 그룹 규칙 예시를 채웠습니다. 필요에 맞게 수정 후 적용하세요.");
  });

  // CSV downloads
  el.btnDownloadCsv.addEventListener("click", () => {
    if (!state.analyzed || !state.selectedUnit) {
      log("다운로드할 데이터가 없습니다.");
      return;
    }

    const mode = el.modeSelect.value;
    const q = (el.schoolFilter.value || "").trim();
    const filename = `${state.workbookName}_${state.unitMode}_${state.selectedUnit}_${mode}${q ? "_filter" : ""}.csv`.replace(/[\\/:*?"<>|]/g, "_");

    const rows = [["단위", "학교(부서)", "전출", "전입", "차이(전출-전입)", "전입없음"]];
    for (const r of state.lastDetailList) {
      rows.push([state.selectedUnit, r.school, r.outC, r.inC, r.diff, r.noIncoming ? "Y" : ""]);
    }
    downloadCsv(filename, rows);
    log(`CSV 다운로드: ${filename}`);
  });

  el.btnDownloadAllCurrent.addEventListener("click", () => {
    if (!state.analyzed) {
      log("다운로드할 데이터가 없습니다.");
      return;
    }
    const q = (el.allFilter.value || "").trim();
    const filename = `${state.workbookName}_전체정원 확인 필요${q ? "_filter" : ""}.csv`.replace(/[\\/:*?"<>|]/g, "_");

    const rows = [["직종", "시트", "학교(부서)", "정원 확인 필요(전출-전입)", "전출", "전입", "전입없음"]];
    for (const r of state.lastAllList) {
      rows.push([r.jobName, r.sheetText, r.school, r.diff, r.outC, r.inC, r.noIncoming ? "Y" : ""]);
    }
    downloadCsv(filename, rows);
    log(`CSV 다운로드: ${filename}`);
  });

  el.btnDownloadAllNet.addEventListener("click", () => {
    if (!state.analyzed) {
      log("다운로드할 데이터가 없습니다.");
      return;
    }
    const rows = [["시트", "학교(부서)", "전출", "전입", "차이(전출-전입)"]];
    for (const sheetName of state.sheetOrder) {
      const sd = state.sheets.get(sheetName);
      if (!sd) continue;
      for (const [school, info] of sd.schools.entries()) {
        const diff = info.outCount - info.inCount;
        rows.push([sheetName, school, info.outCount, info.inCount, diff]);
      }
    }
    const filename = `${state.workbookName}_전체순증감.csv`.replace(/[\\/:*?"<>|]/g, "_");
    downloadCsv(filename, rows);
    log(`CSV 다운로드: ${filename}`);
  });

  el.btnDownloadUnitSuspect.addEventListener("click", () => {
    if (!state.analyzed) {
      log("다운로드할 데이터가 없습니다.");
      return;
    }

    const { order, title, map } = getUnitMapAndOrder();
    const filename = `${state.workbookName}_${title}_요약.csv`.replace(/[\\/:*?"<>|]/g, "_");

    const rows = [[title, "전입", "전출/퇴직", "정원 확인 필요 학교", "정원 확인 필요 인원", "순증가 학교", "순증가 인원", "총차이(전출-전입)"]];
    for (const name of order) {
      const u = map.get(name);
      if (!u || !u.summary) continue;
      const s = u.summary;
      rows.push([name, s.incomingTotal, s.outgoingTotal, s.suspectSchools, s.suspectPositions, s.surplusSchools, s.surplusPositions, s.netDiff]);
    }

    downloadCsv(filename, rows);
    log(`CSV 다운로드: ${filename}`);
  });

  // ---------------------------
  // Init
  // ---------------------------
  async function init() {
    log("페이지 로드 완료");
    log("엑셀 업로드 후 '분석 실행'을 누르세요.");

    const ok = await ensureXLSX();
    setLibWarning(ok);

    // CSS/버튼 스타일 감지(디버깅용)
    const probe = document.createElement("button");
    probe.className = "btn";
    probe.style.position = "absolute";
    probe.style.left = "-9999px";
    probe.textContent = "probe";
    document.body.appendChild(probe);
    const br = getComputedStyle(probe).borderRadius;
    document.body.removeChild(probe);
    log(`버튼 스타일 체크: .btn border-radius = ${br} (회색/각진이면 CSS 미적용 가능성)`);
  }

  document.addEventListener("DOMContentLoaded", init);
})();
</script>

<a href="/" class="btn">메인으로 돌아가기</a>

<script src="/static/disable-copy.js"></script>
<script src="/static/footer.js"></script>
<script src="/static/global-loader.js?v=1"></script>
  
</body>
</html>
