<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>2026학년도 연차유급휴가 부여일수 계산기</title>

  <style>
/* ======= (기존 static-style.css 내용 인라인) ======= */
/* 박스 모델 통일 */
* { box-sizing: border-box; }

/* 기본 타이포 & 반응형 글자 크기 */
html { font-size: 16px; }
@media (max-width: 600px) { html { font-size: 15px; } }

body {
  margin: 0; padding: 0;
  background: #fff; color: #111;
  font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue",
    Arial, "Apple SD Gothic Neo", "Noto Sans KR", "맑은 고딕", sans-serif;
  line-height: 1.5;
  word-break: keep-all;
}
a { text-decoration: none; color: inherit; }

body h1 {
  font-size: 2.2rem;
  margin: 28px 0 18px;
  text-align: center !important;
  color: #111;
  font-weight: 700;
}
body h2 {
  font-size: 1.6rem;
  margin: 28px 0 12px;
  color: #222;
  font-weight: 700;
}
body h3 {
  font-size: 1.4rem;
  margin: 20px 0 10px;
  color: #222;
  font-weight: 600;
}
body h4 {
  font-size: 1.2rem;
  margin: 16px 0 8px;
  color: #333;
  font-weight: 600;
}

body p, body li, body div, body span {
  font-size: 1.1rem;
  line-height: 1.65;
  color: #333;
}
body p { margin: 14px 0; }
body li { margin: 4px 0; line-height: 1.55; }
ul, ol { margin: 12px 0 18px; padding-left: 22px; }
body .muted { font-size: 0.95rem; color: #666; }

.local-h2 { font-size: 1.3rem !important; }
.local-h3 { font-size: 1.1rem !important; }
.local-large { font-size: 1.2rem !important; }
.local-small { font-size: 0.9rem !important; }
.local-tight { margin-bottom: 6px !important; }
.local-accent { color: #0051a8 !important; }

.shell { max-width: 880px; margin: 0 auto; }
main { margin: 0 auto; }

.sub { margin: 0.25rem 0 0; font-size: 1rem; color: #555; }

.site-header { background: #fff; border-bottom: 1px solid #e8e8ef; }
.site-header .shell { padding: 16px; }

.section {
  border: 1px solid #e5e5e5;
  border-radius: 12px;
  padding: 20px 22px;
  margin: 18px 0;
  background: #fff;
}
.card {
  border: 1px solid #e5e5e5;
  border-radius: 10px;
  padding: 14px 16px;
  margin: 14px 0;
  background: #fafafa;
}

.row { display:flex; align-items:center; gap:8px; }
.row.between { justify-content: space-between; }
.row.gap { gap: 10px; }

.grid { display:grid; gap:12px; }
.grid.two { grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); }
.grid.three { grid-template-columns: repeat(auto-fit, minmax(210px, 1fr)); }

@media (max-width: 640px) {
  .row { flex-wrap: wrap; align-items: flex-start; }
  .grid.two, .grid.three { grid-template-columns: 1fr; }
}

.btn {
  display:inline-block;
  padding: 10px 16px;
  border-radius: 12px;
  border: 1px solid #222;
  font-weight: 600;
  font-size: 1rem;
  color: #111;
  background: #fff;
  cursor: pointer;
}
.btn + .btn { margin-left: 10px; }
.btn:hover { background: #f3f4f6; }
.btn.primary { background:#111; color:#fff; }
.btn.primary:hover { background:#000; }
.btn.ghost { background:#f9fafb; border-color:#d4d4d8; }
.btn.ghost:hover { background:#eef2ff; }
.btn-lightgrey {
  padding: 8px 14px;
  border-radius: 10px;
  background: #f3f4f6;
  border: 1px solid #d4d4d8;
}

.home-link-wrap {
  max-width: 880px;
  margin: 16px auto 0;
  padding: 0 16px;
  display: flex;
  justify-content: flex-start;
  gap: 8px;
  flex-wrap: wrap;
}

input, select, button, textarea { font: inherit; }
input[type="text"], input[type="number"], input[type="time"], input[type="date"], select, textarea {
  padding: 10px 12px;
  border: 1px solid #d9d9e3;
  border-radius: 12px;
  background: #f9fafb;
  outline: none;
  min-width: 0;
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.02);
}
input:focus, select:focus, textarea:focus {
  border-color: #b4b4d0;
  box-shadow: 0 0 0 2px rgba(180, 180, 208, 0.25);
  background: #fff;
}
input:disabled, select:disabled, textarea:disabled {
  background: #f6f7fb;
  color: #888;
}
.numeric { text-align: right; }

hr { border-top: 1px solid #ddd; margin: 26px 0; opacity: 0.9; }
body h2 + hr { margin-top: 10px !important; }

.table-wrap { width: 100%; max-width: 100%; overflow-x: auto; -webkit-overflow-scrolling: touch; margin: 12px 0; padding-bottom: 6px; }
.table-wrap table { min-width: 800px; border-collapse: collapse; }

.sheetlike { width: 100%; border-collapse: collapse; font-size: 1rem; background: #fff; }
.sheetlike th, .sheetlike td { border: 1px solid #e5e7eb; padding: 8px 10px; }
.sheetlike th { background: #f9fafb; font-weight: 600; }

.container { max-width: 880px; margin: 0 auto; padding: 24px 16px; }
.subtitle { margin: 0 0 12px; color: #444; font-size: 0.98rem; text-align: center; }

.site-footer {
  margin-top: 64px;
  padding: 24px 16px;
  border-top: 1px solid #e5e7eb;
  background: #fafafa;
  color: #6b7280;
  font-size: 0.875rem;
}
.site-footer .shell {
  max-width: 1024px;
  margin: 0 auto;
  text-align: center;
  line-height: 1.6;
}

/* ======= (기존 인라인 스타일들 유지/통합) ======= */
.msg { border:1px solid #e5e5e5; border-radius:12px; padding:10px 12px; background:#fafafa; }
.msg.ok { border-color:#b7eb8f; background:#f6ffed; }
.msg.warn { border-color:#ffd666; background:#fffbe6; }
.msg.err { border-color:#ffccc7; background:#fff2f0; }

.pill { display:inline-block; padding:2px 8px; border-radius:999px; font-size:0.92rem; border:1px solid #ddd; background:#fff; }
.pill.ok { border-color:#b7eb8f; }
.pill.warn { border-color:#ffd666; }
.pill.err { border-color:#ffccc7; }

.kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size:0.95rem; background:#f3f4f6; border:1px solid #e5e7eb; padding:1px 6px; border-radius:6px; }

details > summary { cursor:pointer; font-weight:700; color:#111; }
details > summary:hover { text-decoration: underline; }
.hidden { display:none !important; }

.table-compact th, .table-compact td { padding: 6px 8px; }
.right { text-align:right; }
.center { text-align:center; }
.nowrap { white-space: nowrap; }

.stack { display:flex; flex-direction:column; gap:10px; }
.mini { font-size:0.95rem; color:#555; }

.danger-line { border-left: 4px solid #ff4d4f; padding-left: 10px; }
.warn-line { border-left: 4px solid #faad14; padding-left: 10px; }

table select { min-width: 140px; }

.site-header .shell,
.site-header h1,
.site-header .subtitle { text-align:left !important; }

/* Drag & Drop */
.dropzone {
  border: 2px dashed #d4d4d8;
  border-radius: 14px;
  padding: 14px 16px;
  background: #fafafa;
  cursor: pointer;
  transition: all 0.15s ease;
}
.dropzone:hover { background:#f3f4f6; }
.dropzone.dragover { border-color: #111; background: #eef2ff; }
.dz-title { font-weight: 700; color:#111; margin:0 0 4px; }
.dz-desc { margin:0; color:#555; font-size:0.95rem; }

/* 다운로드 실패 시 Base64 모달 */
.modal {
  position: fixed;
  inset: 0;
  z-index: 9999;
  display: none;
}
.modal.on { display: block; }
.modal-backdrop {
  position:absolute; inset:0;
  background: rgba(0,0,0,0.55);
}
.modal-panel{
  position: absolute;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  width: min(960px, 94vw);
  max-height: 88vh;
  overflow: auto;
  background: #fff;
  border-radius: 14px;
  border: 1px solid #e5e7eb;
  padding: 14px 14px 18px;
}
.modal-panel h3 { margin: 6px 0 8px; }
.modal-panel .muted { margin: 6px 0 10px; }
.modal-panel textarea{
  width: 100%;
  min-height: 260px;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  font-size: 0.95rem;
  padding: 10px 12px;
  border-radius: 12px;
  border: 1px solid #d1d5db;
  background: #f9fafb;
}
.modal-actions{ display:flex; gap:8px; flex-wrap: wrap; margin-top: 10px; }
  </style>
</head>

<body>
  <header class="site-header">
    <div class="shell">
      <h1>2026학년도 교육공무직 연차 유급휴가 부여일수 계산기 (내부망 접속용)</h1>
      <p class="subtitle">
        ·2025.3.1.~2026.2.28. 근무 실적을 바탕으로, 2026학년도에 사용할 연차 유급휴가 부여일수를 계산합니다. (산정 기준일자: 2026.3.1.) <br/>
        ·외부 서버/DB/외부 API 없음 · CDN 없음 · 이 HTML 한 파일로만 동작하도록 구성 <br/>
        ※업로드한 파일은 저장되지 않습니다. (브라우저에서만 처리)
      </p>
    </div>
  </he슈. <br/>
      </p>

      <div class="card">
        <div class="row gap">
          <label class="row"><input type="radio" name="hrMode" value="file" checked /> 파일 업로드</label>
          <label class="row"><input type="radio" name="hrMode" value="manual" /> 수기 입력</label>
        </div>

        <div id="hrFileBox" style="margin-top:12px;">
          <div class="grid two">
            <div>
              <div class="dropzone" id="hrDrop">
                <p class="dz-title">인사기록 파일 업로드 (.xlsx/.csv/.xls)</p>
                <p class="dz-desc">(드래그 & 드롭 가능)</p>
              </div>
              <input type="file" id="hrFile" accept=".xlsx,.xls,.csv" class="hidden" multiple />
              <div class="muted" style="margin-top:8px;">※ 파일 선택 후 <b>인사 정보 반영하기</b>를 눌러주세요.</div>
            </div>
          </div>

          <div class="row gap" style="margin-top:10px;">
            <button class="btn primary" id="btnLoadHr">인사 정보 반영하기</button>
            <button class="btn" id="btnClearHr">내역 초기화</button>
          </div>
          <div id="hrMsg" class="msg" style="margin-top:12px;"></div>
        </div>

        <div id="hrManualBox" class="hidden" style="margin-top:12px;">
          <h3 class="local-h3">대상자 수기 등록</h3>

          <div class="grid three">
            <label class="stack">
              <span class="mini">성명(필수)</span>
              <input type="text" id="mName" placeholder="홍길동" />
            </label>
            <label class="stack">
              <span class="mini">나이스 개인번호(선택)</span>
              <input type="text" id="mPid" placeholder="예시: K1234567" />
            </label>
            <label class="stack">
              <span class="mini">최초임용일(필수)</span>
              <input type="date" id="mHire" />
            </label>

            <label class="stack">
              <span class="mini">직군</span>
              <select id="mGroup">
                <option value="regular">교육공무직</option>
                <option value="special">특수운영직군</option>
              </select>
            </label>

            <label class="stack">
              <span class="mini">근무형태</span>
              <select id="mPattern">
                <option value="always">상시 근무자</option>
                <option value="emergency">방학 중 비상시 근로자</option>
              </select>
            </label>

            <label class="stack">
              <span class="mini">1일 소정근로시간</span>
              <input type="number" id="mDailyHours" value="8" min="1" max="12" step="1" class="numeric" />
            </label>
          </div>

          <div class="row gap" style="margin-top:10px;">
            <button class="btn primary" id="btnAddWorker">대상자 추가</button>
            <button class="btn" id="btnClearWorkers">대상자 전체 삭제</button>
          </div>

          <div class="table-wrap">
            <table class="sheetlike table-compact" id="workersTable">
              <thead>
                <tr>
                  <th class="nowrap">나이스개인번호</th>
                  <th class="nowrap">성명</th>
                  <th class="nowrap">개인번호</th>
                  <th class="nowrap">직군</th>
                  <th class="nowrap">근무형태</th>
                  <th class="nowrap">최초임용일</th>
                  <th class="nowrap right">1일시간</th>
                  <th class="nowrap right">근속연수 (2026.3.1.기준)</th>
                  <th class="nowrap center">삭제</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>

          <div id="hrManualMsg" class="msg" style="margin-top:12px;"></div>
        </div>
      </div>
    </section>

    <section class="section">
      <h2>3. 근무상황(복무) 입력</h2>
      <p class="muted">
        ·나이스 근무상황목록 파일 업로드(권장: .xlsx). CSV도 가능.<br/>
        ·파일 업로드 시 전체 복무 사항 자동 취합·분류함.<br/>
        <span class="muted">※ <b>연차 사용일수 집계</b>는 <b>결재상태가 “완결”인 건만</b> 집계합니다.</span>
      </p>

      <div class="card">
        <div class="row gap">
          <label class="row"><input type="radio" name="workMode" value="file" checked /> 파일 업로드</label>
          <label class="row"><input type="radio" name="workMode" value="manual" /> 수기 입력</label>
        </div>

        <div id="workFileBox" style="margin-top:12px;">
          <div class="grid two">
            <div>
              <div class="dropzone" id="workDrop">
                <p class="dz-title">근무상황목록 파일 업로드 (.xlsx/.csv/.xls)</p>
                <p class="dz-desc">(여러 개 가능 · 드래그 & 드롭 가능)</p>
              </div>
              <input type="file" id="workFiles" accept=".xlsx,.xls,.csv" multiple class="hidden" />
              <div class="muted" style="margin-top:8px;">※ 파일 선택 후 <b>복무사항 불러오기</b>를 눌러주세요.</div>
            </div>

            <div class="msg warn">
              <div><b>안내</b></div>
              <ul>
                <li>복무를 잘못 낸 경우를 대비해서 모든 복무 내역을 취합·분류함.</li>
                <li>자동으로 분류하기 애매한 항목은 "검토"로 표시함. (개별 확인 필요)</li>
              </ul>
            </div>
          </div>

          <div class="row gap" style="margin-top:10px;">
            <button class="btn primary" id="btnLoadWork">복무사항 불러오기</button>
            <button class="btn" id="btnClearWork">전체 초기화</button>
          </div>
          <div id="workMsg" class="msg" style="margin-top:12px;"></div>
        </div>

        <div id="workManualBox" class="hidden" style="margin-top:12px;">
          <h3 class="local-h3">복무사항 수기 입력</h3>
          <p class="muted">·수기 입력 모드는 기본적으로 "정상근무" 전제. 예외사항 입력에 사용하세요.</p>

          <div class="grid three">
            <label class="stack">
              <span class="mini">근로자 선택하기</span>
              <select id="wSelect"></select>
            </label>
            <label class="stack">
              <span class="mini">시작일자</span>
              <input type="date" id="wStart" />
            </label>
            <label class="stack">
              <span class="mini">종료일자</span>
              <input type="date" id="wEnd" />
            </label>

            <label class="stack">
              <span class="mini">복무 종류</span>
              <input type="text" id="wType" placeholder="질병휴직 / 결근 / 연가 등" />
            </label>

            <label class="stack">
              <span class="mini">복무 사유</span>
              <input type="text" id="wReason" placeholder="필요 시 입력" />
            </label>

            <label class="stack">
              <span class="mini">분류 방법 선택</span>
              <select id="wClass">
                <option value="auto">자동 판별</option>
                <option value="deemed">출근 간주 (분자 포함)</option>
                <option value="excluded">제외 기간 (분모·분자 제외)</option>
                <option value="absence">결근 간주</option>
                <option value="review">확인 필요 (미분류)</option>
              </select>
            </label>
          </div>

          <div class="row gap" style="margin-top:10px;">
            <label class="row">
              <input type="checkbox" id="wCredit" />
              비상시 직종의 방학중 근무 (우선채용 등)
            </label>
            <button class="btn primary" id="btnAddRecord">복무내역 추가</button>
            <button class="btn" id="btnClearManualRecords">전체 초기화</button>
          </div>

          <div id="workManualMsg" class="msg" style="margin-top:12px;"></div>
        </div>
      </div>
    </section>

    <section class="section">
      <h2>4. 연차 유급휴가 부여일수 계산 실행</h2>

      <div class="card">
        <div class="grid two">
          <div class="msg">
            <div><b>비상시근로자의 출근율</b></div>
            <ol>
              <li>출근율(학기중): 비상시근로자 기준으로 산정</li>
              <li>출근율(연간): 연간 기준으로 산정(상시근로자와 동일한 분모)</li>
              <li>출근율(비례산정): <b>학기중 출근율 80% 미만인 경우에만</b> 산정(제외기간 제거)</li>
            </ol>
            <div class="muted">※상시근로자는 연간 출근율이 80% 미만일 때만 비례산정 출근율을 산정합니다.</div>
          </div>

          <div class="msg">
            <div><b>계산조건 기본 설정</b></div>
            <ul>
              <li>복무실적 산정기간: 2025.3.1.~2026.2.28.</li>
              <li>연차일수 부여 기준일자: 2026.3.1.</li>
              <li>토요일은 분모에서 제외</li>
              <li>비례산정은 소수점 둘째 자리에서 반올림한 후 시간 단위로 환산함.</li>
            </ul>
          </div>
        </div>

        <div class="row gap" style="margin-top:12px;">
          <button class="btn primary" id="btnRun">계산 실행하기</button>
          <button class="btn" id="btnDownload">계산 결과 엑셀 저장(.xlsx)</button>
        </div>

        <div id="runMsg" class="msg" style="margin-top:12px;"></div>
      </div>
    </section>

    <section class="section">
      <h2>5. 연차 부여일수 계산 결과</h2>

      <div id="resultSummary" class="msg">계산 실행 버튼 먼저 눌러주세요.</div>

      <div class="table-wrap">
        <table class="sheetlike table-compact" id="resultTable">
          <thead>
            <tr>
              <th class="nowrap">나이스 개인번호</th>
              <th class="nowrap">성명</th>
              <th class="nowrap">직군</th>
              <th class="nowrap">근무형태</th>
              <th class="nowrap right">근속</th>
              <th class="nowrap right">출근율(학기중)</th>
              <th class="nowrap right">출근율(연간)</th>
              <th class="nowrap right">출근율(비례산정)</th>
              <th class="nowrap right">기본+가산(출근/근속)</th>
              <th class="nowrap right">최종부여</th>
              <th class="nowrap">판정</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>

      <h3>개인별 상세(복무 취합/분류 포함)</h3>

      <div id="detailNotice" class="msg warn hidden" style="margin-top:10px;">
        <div><b>안내 사항</b></div>
        <ul>
          <li>“검토”로 분류된 항목은 담당자가 직접 반영 여부를 확인하세요.</li>
          <li>비상시근로자의 방학중 근무(분자 가산)는 “방학기간과 겹치는 유급근무”에만 체크하기를 권장합니다.</li>
          <li>연차 사용일수 집계는 결재상태가 <b>“완결”</b>인 내역만 집계합니다.</li>
        </ul>
      </div>

      <div id="detailBox" class="stack"></div>
    </section>
  </main>

  <div class="home-link-wrap">
    <a class="btn" href="#" id="btnScrollTop">맨 위로</a>
  </div>

  <footer class="site-footer">
    <div class="shell">
      <div>오프라인 단일파일 버전 · 외부 서버/DB/API 없음 · 브라우저에서만 처리</div>
      <div class="muted">XLSX 업로드는 최신 Edge/Chrome에서 가장 잘 동작합니다.</div>
    </div>
  </footer>

  <!-- 다운로드 실패 Base64 우회 모달 -->
  <div class="modal" id="b64Modal" aria-hidden="true">
    <div class="modal-backdrop" id="b64Backdrop"></div>
    <div class="modal-panel">
      <h3>다운로드가 차단되어 Base64로 우회 출력했습니다</h3>
      <p class="muted">
        아래 Base64 문자열을 파일로 저장 후, Windows에서 다음 중 하나로 복구할 수 있습니다.<br/>
        1) PowerShell: <span class="kbd">[IO.File]::WriteAllBytes('out.xlsx',[Convert]::FromBase64String((Get-Content out.b64 -Raw)))</span><br/>
        2) certutil: Base64를 out.b64로 저장 후 <span class="kbd">certutil -decode out.b64 out.xlsx</span><br/>
      </p>
      <textarea id="b64Text" spellcheck="false"></textarea>
      <div class="modal-actions">
        <button class="btn primary" id="btnCopyB64">Base64 복사</button>
        <button class="btn" id="btnDownloadB64">out.b64로 저장</button>
        <button class="btn" id="btnCloseB64">닫기</button>
      </div>
    </div>
  </div>

<script>
(() => {
  "use strict";

  // ==========================
  // 0) 아주 얕은 폴리필
  // ==========================
  if (!String.prototype.replaceAll) {
    // 구형 환경 대비 (IE 모드 같은 곳)
    // eslint-disable-next-line no-extend-native
    String.prototype.replaceAll = function(search, replacement) {
      const target = String(this);
      if (search instanceof RegExp) return target.replace(search, replacement);
      return target.split(String(search)).join(String(replacement));
    };
  }

  // ==========================
  // 1) 미니 XLSX (읽기/쓰기)
  //    - 읽기: xlsx(zip+deflate) → 첫 시트 rows
  //    - 쓰기: store(zip, 무압축) + OOXML 최소 구성
  // ==========================
  const MiniXLSX = (() => {
    const te = new TextEncoder();
    const td = new TextDecoder("utf-8");

    function encXml(s) {
      return String(s ?? "")
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&apos;");
    }

    function u16(n){ return new Uint8Array([n & 255, (n >>> 8) & 255]); }
    function u32(n){ return new Uint8Array([n & 255, (n >>> 8) & 255, (n >>> 16) & 255, (n >>> 24) & 255]); }

    function crc32(buf){
      let c = ~0;
      for (let i = 0; i < buf.length; i++) {
        c ^= buf[i];
        for (let k = 0; k < 8; k++) c = (c >>> 1) ^ (0xEDB88320 & (-(c & 1)));
      }
      return (~c) >>> 0;
    }

    function concatU8(chunks){
      const total = chunks.reduce((a,b)=>a + b.length, 0);
      const out = new Uint8Array(total);
      let off = 0;
      for (const c of chunks) { out.set(c, off); off += c.length; }
      return out;
    }

    // ---- ZIP store(무압축) 생성 ----
    function zipStore(entries){
      // entries: [{name, data(Uint8Array)}]
      const files = [];
      const cdir = [];
      let offset = 0;

      for (const e of entries) {
        const nameBytes = te.encode(e.name);
        const data = e.data;
        const crc = crc32(data);
        const size = data.length;

        // Local file header
        const local = concatU8([
          u32(0x04034b50),     // signature
          u16(20),             // version needed
          u16(0),              // flags
          u16(0),              // compression (0=store)
          u16(0), u16(0),      // mod time/date
          u32(crc),
          u32(size),
          u32(size),
          u16(nameBytes.length),
          u16(0),
          nameBytes
        ]);

        files.push(local, data);

        // Central directory header
        const central = concatU8([
          u32(0x02014b50),
          u16(20), u16(20),
          u16(0),
          u16(0),
          u16(0), u16(0),
          u32(crc),
          u32(size),
          u32(size),
          u16(nameBytes.length),
          u16(0),
          u16(0),
          u16(0),
          u16(0),
          u32(0),
          u32(offset),
          nameBytes
        ]);
        cdir.push(central);

        offset += local.length + data.length;
      }

      const cdirBlob = concatU8(cdir);
      const cdirOffset = offset;
      const cdirSize = cdirBlob.length;
      const count = entries.length;

      const eocd = concatU8([
        u32(0x06054b50),
        u16(0), u16(0),
        u16(count),
        u16(count),
        u32(cdirSize),
        u32(cdirOffset),
        u16(0)
      ]);

      return concatU8([...files, cdirBlob, eocd]);
    }

    function colName(n){
      let s = "";
      let x = n + 1;
      while (x > 0) {
        const r = (x - 1) % 26;
        s = String.fromCharCode(65 + r) + s;
        x = Math.floor((x - 1) / 26);
      }
      return s;
    }

    function sanitizeSheetName(name, fallback){
      let n = String(name || fallback || "Sheet").trim();
      n = n.replace(/[\\\/\?\*\[\]\:]/g, "_");
      if (n.length > 31) n = n.slice(0, 31);
      if (!n) n = "Sheet";
      return n;
    }

    function buildWorksheetXml(rows){
      // rows: 2D array
      let maxR = 0, maxC = 0;
      for (let r = 0; r < rows.length; r++) {
        const row = rows[r] || [];
        let last = -1;
        for (let c = row.length - 1; c >= 0; c--) {
          const v = row[c];
          if (v !== "" && v != null) { last = c; break; }
        }
        if (last >= 0) {
          maxR = Math.max(maxR, r + 1);
          maxC = Math.max(maxC, last + 1);
        }
      }
      const dim = (maxR && maxC) ? `A1:${colName(maxC - 1)}${maxR}` : "A1";

      const out = [];
      out.push(`<?xml version="1.0" encoding="UTF-8" standalone="yes"?>`);
      out.push(`<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main">`);
      out.push(`<dimension ref="${dim}"/>`);
      out.push(`<sheetData>`);

      for (let r = 0; r < rows.length; r++) {
        const row = rows[r] || [];
        let last = -1;
        for (let c = row.length - 1; c >= 0; c--) {
          const v = row[c];
          if (v !== "" && v != null) { last = c; break; }
        }
        if (last < 0) continue;

        const rr = r + 1;
        out.push(`<row r="${rr}">`);
        for (let c = 0; c <= last; c++) {
          const v = row[c];
          if (v === "" || v == null) continue;
          const ref = `${colName(c)}${rr}`;

          if (typeof v === "number" && Number.isFinite(v)) {
            out.push(`<c r="${ref}"><v>${String(v)}</v></c>`);
          } else {
            const txt = encXml(String(v));
            out.push(`<c r="${ref}" t="inlineStr"><is><t>${txt}</t></is></c>`);
          }
        }
        out.push(`</row>`);
      }

      out.push(`</sheetData>`);
      out.push(`</worksheet>`);
      return te.encode(out.join(""));
    }

    function buildWorkbookXml(sheetNames){
      const out = [];
      out.push(`<?xml version="1.0" encoding="UTF-8" standalone="yes"?>`);
      out.push(`<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">`);
      out.push(`<sheets>`);
      for (let i = 0; i < sheetNames.length; i++) {
        const id = i + 1;
        const name = encXml(sheetNames[i]);
        out.push(`<sheet name="${name}" sheetId="${id}" r:id="rId${id}"/>`);
      }
      out.push(`</sheets>`);
      out.push(`</workbook>`);
      return te.encode(out.join(""));
    }

    function buildWorkbookRels(sheetCount){
      const out = [];
      out.push(`<?xml version="1.0" encoding="UTF-8" standalone="yes"?>`);
      out.push(`<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">`);
      for (let i = 0; i < sheetCount; i++) {
        const id = i + 1;
        out.push(`<Relationship Id="rId${id}" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet${id}.xml"/>`);
      }
      out.push(`<Relationship Id="rIdStyles" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/>`);
      out.push(`</Relationships>`);
      return te.encode(out.join(""));
    }

    function buildRootRels(){
      const out = [];
      out.push(`<?xml version="1.0" encoding="UTF-8" standalone="yes"?>`);
      out.push(`<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">`);
      out.push(`<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/>`);
      out.push(`</Relationships>`);
      return te.encode(out.join(""));
    }

    function buildContentTypes(sheetCount){
      const out = [];
      out.push(`<?xml version="1.0" encoding="UTF-8" standalone="yes"?>`);
      out.push(`<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">`);
      out.push(`<Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>`);
      out.push(`<Default Extension="xml" ContentType="application/xml"/>`);
      out.push(`<Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"/>`);
      for (let i = 0; i < sheetCount; i++) {
        const id = i + 1;
        out.push(`<Override PartName="/xl/worksheets/sheet${id}.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml"/>`);
      }
      out.push(`<Override PartName="/xl/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml"/>`);
      out.push(`</Types>`);
      return te.encode(out.join(""));
    }

    function buildStylesXml(){
      const s =
`<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main">
  <fonts count="1">
    <font>
      <sz val="11"/>
      <color theme="1"/>
      <name val="Calibri"/>
      <family val="2"/>
    </font>
  </fonts>
  <fills count="2">
    <fill><patternFill patternType="none"/></fill>
    <fill><patternFill patternType="gray125"/></fill>
  </fills>
  <borders count="1">
    <border><left/><right/><top/><bottom/><diagonal/></border>
  </borders>
  <cellStyleXfs count="1">
    <xf numFmtId="0" fontId="0" fillId="0" borderId="0"/>
  </cellStyleXfs>
  <cellXfs count="1">
    <xf numFmtId="0" fontId="0" fillId="0" borderId="0" xfId="0"/>
  </cellXfs>
  <cellStyles count="1">
    <cellStyle name="Normal" xfId="0" builtinId="0"/>
  </cellStyles>
  <dxfs count="0"/>
  <tableStyles count="0" defaultTableStyle="TableStyleMedium9" defaultPivotStyle="PivotStyleLight16"/>
</styleSheet>`;
      return te.encode(s);
    }

    function writeWorkbook(sheets){
      // sheets: [{name, rows(2D array)}]
      const safeNames = sheets.map((s, i) => sanitizeSheetName(s.name, `Sheet${i+1}`));
      const entries = [];

      entries.push({ name: "[Content_Types].xml", data: buildContentTypes(sheets.length) });
      entries.push({ name: "_rels/.rels", data: buildRootRels() });
      entries.push({ name: "xl/workbook.xml", data: buildWorkbookXml(safeNames) });
      entries.push({ name: "xl/_rels/workbook.xml.rels", data: buildWorkbookRels(sheets.length) });
      entries.push({ name: "xl/styles.xml", data: buildStylesXml() });

      for (let i = 0; i < sheets.length; i++) {
        const id = i + 1;
        const xml = buildWorksheetXml(sheets[i].rows || []);
        entries.push({ name: `xl/worksheets/sheet${id}.xml`, data: xml });
      }

      return zipStore(entries);
    }

    // ---- XLSX 읽기(첫 시트) ----
    function dvU16(dv, o){ return dv.getUint16(o, true); }
    function dvU32(dv, o){ return dv.getUint32(o, true); }

    function findEOCD(bytes){
      // End of central directory: 0x06054b50
      const max = Math.max(0, bytes.length - (0xFFFF + 22));
      for (let i = bytes.length - 22; i >= max; i--) {
        if (bytes[i] === 0x50 && bytes[i+1] === 0x4b && bytes[i+2] === 0x05 && bytes[i+3] === 0x06) return i;
      }
      return -1;
    }

    async function inflateRaw(u8){
      if (!("DecompressionStream" in window)) {
        throw new Error("이 브라우저는 XLSX 업로드 파싱(DecompressionStream)을 지원하지 않습니다. CSV로 변환하거나 최신 Edge/Chrome을 사용하세요.");
      }
      // zip deflate = raw deflate
      let ds = null;
      try {
        ds = new DecompressionStream("deflate-raw");
      } catch (e) {
        // 일부 환경에서 deflate-raw 미지원일 수 있어 deflate도 시도
        try { ds = new DecompressionStream("deflate"); }
        catch (e2) { throw new Error("이 브라우저는 deflate 압축 해제를 지원하지 않습니다. 최신 Edge/Chrome 권장"); }
      }
      const stream = new Blob([u8]).stream().pipeThrough(ds);
      const ab = await new Response(stream).arrayBuffer();
      return new Uint8Array(ab);
    }

    async function unzipAll(buffer){
      const bytes = new Uint8Array(buffer);
      const dv = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);

      const eocdOff = findEOCD(bytes);
      if (eocdOff < 0) throw new Error("ZIP(=XLSX) 구조를 찾지 못했습니다.");

      const totalEntries = dvU16(dv, eocdOff + 10);
      const cdSize = dvU32(dv, eocdOff + 12);
      const cdOffset = dvU32(dv, eocdOff + 16);

      let p = cdOffset;
      const files = new Map();

      for (let i = 0; i < totalEntries; i++) {
        const sig = dvU32(dv, p);
        if (sig !== 0x02014b50) break;

        const comp = dvU16(dv, p + 10);
        const csize = dvU32(dv, p + 20);
        const usize = dvU32(dv, p + 24);
        const nlen = dvU16(dv, p + 28);
        const xlen = dvU16(dv, p + 30);
        const clen = dvU16(dv, p + 32);
        const lhoff = dvU32(dv, p + 42);

        const nameBytes = bytes.slice(p + 46, p + 46 + nlen);
        const name = td.decode(nameBytes);

        // local header parse to find data start
        const lfNlen = dvU16(dv, lhoff + 26);
        const lfXlen = dvU16(dv, lhoff + 28);
        const dataStart = lhoff + 30 + lfNlen + lfXlen;

        const compData = bytes.slice(dataStart, dataStart + csize);

        let out;
        if (comp === 0) out = compData;
        else if (comp === 8) out = await inflateRaw(compData);
        else throw new Error("지원하지 않는 ZIP 압축 방식: " + comp);

        // usize가 0으로 오는 이상한 파일도 있어서 out 기준으로 둠
        files.set(name, out);

        p += 46 + nlen + xlen + clen;
        if (p > cdOffset + cdSize) break;
      }

      return files;
    }

    function xmlDoc(bytes){
      const txt = td.decode(bytes);
      return new DOMParser().parseFromString(txt, "application/xml");
    }

    function getTextBytes(files, path){
      const b = files.get(path);
      if (!b) return null;
      return td.decode(b);
    }

    function colToIndex(col){
      // "A" -> 0, "B"->1 ... "AA"->26
      let n = 0;
      for (let i = 0; i < col.length; i++){
        n = n * 26 + (col.charCodeAt(i) - 64);
      }
      return n - 1;
    }

    function pickFirstSheetPath(files){
      const wbBytes = files.get("xl/workbook.xml");
      const relBytes = files.get("xl/_rels/workbook.xml.rels");
      if (!wbBytes || !relBytes) throw new Error("XLSX 내부 구성(workbook.xml)을 찾지 못했습니다.");

      const wb = xmlDoc(wbBytes);
      const sheets = wb.getElementsByTagName("sheet");
      if (!sheets || !sheets.length) throw new Error("XLSX에 sheet가 없습니다.");

      const first = sheets[0];
      const rid = first.getAttribute("r:id") || first.getAttribute("id") || first.getAttribute("rId");
      if (!rid) throw new Error("첫 시트 r:id를 찾지 못했습니다.");

      const rel = xmlDoc(relBytes);
      const rels = rel.getElementsByTagName("Relationship");
      let target = null;
      for (const r of rels) {
        if (r.getAttribute("Id") === rid) {
          target = r.getAttribute("Target");
          break;
        }
      }
      if (!target) throw new Error("workbook.xml.rels에서 첫 시트 타겟을 찾지 못했습니다.");

      // target은 보통 "worksheets/sheet1.xml"
      if (target.startsWith("/")) target = target.slice(1);
      if (!target.startsWith("xl/")) target = "xl/" + target;

      return target;
    }

    function parseSharedStrings(files){
      const ssBytes = files.get("xl/sharedStrings.xml");
      if (!ssBytes) return null;

      const doc = xmlDoc(ssBytes);
      const sis = doc.getElementsByTagName("si");
      const arr = [];
      for (const si of sis) {
        // <si><t>...</t></si> 또는 <si><r><t>..</t></r>...</si>
        const t = si.getElementsByTagName("t");
        let s = "";
        for (const tt of t) s += tt.textContent || "";
        arr.push(s);
      }
      return arr;
    }

    function sheetToRows(sheetBytes, sharedStrings){
      const doc = xmlDoc(sheetBytes);
      const rows = [];

      const rowNodes = doc.getElementsByTagName("row");
      for (const rowNode of rowNodes) {
        const rAttr = rowNode.getAttribute("r");
        const rIdx = rAttr ? (parseInt(rAttr, 10) - 1) : rows.length;
        if (!rows[rIdx]) rows[rIdx] = [];

        const cells = rowNode.getElementsByTagName("c");
        for (const c of cells) {
          const ref = c.getAttribute("r") || "";
          const m = ref.match(/^([A-Z]+)(\d+)$/);
          if (!m) continue;

          const col = colToIndex(m[1]);
          const t = c.getAttribute("t") || "";

          let v = "";
          if (t === "s") {
            const vNode = c.getElementsByTagName("v")[0];
            const idx = vNode ? parseInt(vNode.textContent || "0", 10) : 0;
            v = (sharedStrings && sharedStrings[idx] != null) ? sharedStrings[idx] : "";
          } else if (t === "inlineStr") {
            const tNode = c.getElementsByTagName("t")[0];
            v = tNode ? (tNode.textContent || "") : "";
          } else if (t === "b") {
            const vNode = c.getElementsByTagName("v")[0];
            v = (vNode && vNode.textContent === "1") ? "TRUE" : "FALSE";
          } else {
            const vNode = c.getElementsByTagName("v")[0];
            v = vNode ? (vNode.textContent || "") : "";
          }

          // raw:false처럼 문자열 위주로
          rows[rIdx][col] = v;
        }
      }

      // 빈행은 빈 배열로 채워질 수 있음 → 그대로 두면 기존 로직이 필터링함
      return rows.map(r => Array.isArray(r) ? r : []);
    }

    async function xlsxFirstSheetToRows(buffer){
      const files = await unzipAll(buffer);
      const sheetPath = pickFirstSheetPath(files);
      const sheetBytes = files.get(sheetPath);
      if (!sheetBytes) throw new Error("첫 시트 XML을 찾지 못했습니다: " + sheetPath);

      const ss = parseSharedStrings(files);
      return sheetToRows(sheetBytes, ss);
    }

    return {
      writeWorkbook,
      xlsxFirstSheetToRows
    };
  })();

  // ==========================
  // 2) 다운로드(보안환경 우회 포함)
  // ==========================
  function blobToBase64(blob){
    return new Promise((resolve, reject) => {
      const fr = new FileReader();
      fr.onload = () => {
        const dataUrl = String(fr.result || "");
        const b64 = dataUrl.includes(",") ? dataUrl.split(",")[1] : dataUrl;
        resolve(b64);
      };
      fr.onerror = () => reject(new Error("Base64 변환 실패"));
      fr.readAsDataURL(blob);
    });
  }

  function openB64Modal(b64){
    const modal = document.querySelector("#b64Modal");
    const ta = document.querySelector("#b64Text");
    ta.value = b64 || "";
    modal.classList.add("on");
    modal.setAttribute("aria-hidden", "false");
  }

  function closeB64Modal(){
    const modal = document.querySelector("#b64Modal");
    modal.classList.remove("on");
    modal.setAttribute("aria-hidden", "true");
  }

  async function saveBlobSmart(blob, filename){
    // 1) File System Access API (다운로드 차단 환경에서 제일 잘 뚫리는 편)
    if (window.showSaveFilePicker) {
      try {
        const handle = await window.showSaveFilePicker({
          suggestedName: filename,
          types: [{
            description: "Excel",
            accept: { "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": [".xlsx"] }
          }]
        });
        const w = await handle.createWritable();
        await w.write(blob);
        await w.close();
        return true;
      } catch (e) {
        // 사용자가 취소하면 그냥 false
      }
    }

    // 2) IE/레거시 Edge
    if (navigator.msSaveOrOpenBlob) {
      navigator.msSaveOrOpenBlob(blob, filename);
      return true;
    }

    // 3) a[download]
    try {
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 8000);
      return true;
    } catch (e) {}

    return false;
  }

  async function saveOrShowBase64(blob, filename){
    const ok = await saveBlobSmart(blob, filename);
    if (ok) return;

    // 다운로드 전면차단이면 Base64로라도 던져줌
    const b64 = await blobToBase64(blob);
    openB64Modal(b64);
  }

  // ==========================
  // 3) 기존 계산기 로직 (SheetJS 제거 버전)
  // ==========================
  const PERIOD_START = ymdToUTC("2025-03-01");
  const PERIOD_END   = ymdToUTC("2026-02-28"); // inclusive
  const GRANT_DATE   = ymdToUTC("2026-03-01");

  const DEFAULT_DAILY_HOURS = 8;

  const CLASS_LABEL = {
    deemed: "출근간주",
    excluded: "산정제외",
    absence: "결근성",
    review: "검토",
    auto: "자동"
  };

  const RULES_2026 = {
    excludedKeywords: [
      "질병휴직", "가족돌봄휴직", "노조전임", "유학휴직", "행방불명",
      "파업", "쟁의", "휴업", "사용자귀책"
    ],
    absenceKeywords: [
      "결근", "무단", "연차초과", "미승인", "무급결근"
    ],
    deemedKeywords: [
      "연가", "연차", "공가", "특별휴가", "경조", "유급병가", "병가",
      "산재", "요양", "출산", "유산", "사산", "배우자출산",
      "예비군", "민방위", "동원", "공민권", "보상휴가", "보상휴무", "휴일대체",
      "가족돌봄휴가", "생리휴가", "난임", "임신기", "육아기"
    ],
    creditKeywords: [
      "방학", "급식실", "청소", "우선채용", "산업안전", "직무연수", "연수", "교육"
    ],
    reviewKeywords: [
      "재량휴업", "개교기념", "단축", "외근", "출장", "조합", "노조", "대체"
    ]
  };

  const state = {
    calendar: {
      summerStart: null,
      summerEnd: null,
      winterStart: null,
      winterEnd: null,
      applied: false,
      sets: null,
    },
    workers: new Map(),
    records: [],
    results: [],
    lastRunAt: null,
    selectedFiles: { hr: [], work: [] },
  };

  const $ = (sel) => document.querySelector(sel);
  const $$ = (sel) => Array.from(document.querySelectorAll(sel));

  function setMsg(el, cls, html) {
    el.className = `msg ${cls || ""}`.trim();
    el.innerHTML = html;
  }

  function escapeHtml(s) {
    return String(s ?? "")
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  function ymdToUTC(ymd) {
    const [y, m, d] = ymd.split("-").map(Number);
    return new Date(Date.UTC(y, m - 1, d));
  }

  function utcToYmd(date) {
    const y = date.getUTCFullYear();
    const m = String(date.getUTCMonth() + 1).padStart(2, "0");
    const d = String(date.getUTCDate()).padStart(2, "0");
    return `${y}-${m}-${d}`;
  }

  function addDaysUTC(date, days) {
    return new Date(date.getTime() + days * 86400000);
  }

  function clampToPeriod(date) {
    if (date < PERIOD_START) return PERIOD_START;
    if (date > PERIOD_END) return PERIOD_END;
    return date;
  }

  function isSaturdayUTC(date) {
    return date.getUTCDay() === 6;
  }

  function normalizeRange(start, end) {
    if (!start || !end) return null;
    if (end < start) [start, end] = [end, start];
    start = clampToPeriod(start);
    end = clampToPeriod(end);
    if (end < PERIOD_START || start > PERIOD_END) return null;
    return { start, end };
  }

  function buildCalendarSets() {
    const fullSet = new Set();
    const vacationSet = new Set();

    for (let d = PERIOD_START; d <= PERIOD_END; d = addDaysUTC(d, 1)) {
      if (isSaturdayUTC(d)) continue;
      fullSet.add(utcToYmd(d));
    }

    const ss = state.calendar.summerStart;
    const se = state.calendar.summerEnd;
    const ws = state.calendar.winterStart;
    const we = state.calendar.winterEnd;

    const vacRanges = [];
    const r1 = (ss && se) ? normalizeRange(ss, se) : null;
    const r2 = (ws && we) ? normalizeRange(ws, we) : null;
    if (r1) vacRanges.push(r1);
    if (r2) vacRanges.push(r2);

    for (const r of vacRanges) {
      for (let d = r.start; d <= r.end; d = addDaysUTC(d, 1)) {
        if (isSaturdayUTC(d)) continue;
        const ymd = utcToYmd(d);
        if (fullSet.has(ymd)) vacationSet.add(ymd);
      }
    }

    const semesterSet = new Set();
    for (const ymd of fullSet) {
      if (!vacationSet.has(ymd)) semesterSet.add(ymd);
    }

    state.calendar.sets = {
      fullSet,
      vacationSet,
      semesterSet,
      fullCount: fullSet.size,
      vacCount: vacationSet.size,
      semCount: semesterSet.size
    };
  }

  function renderCalendarSummary() {
    const el = $("#calendarSummary");
    const sets = state.calendar.sets;

    if (!state.calendar.applied || !sets) {
      setMsg(el, "warn", `
        <div><b>학사일정 미적용</b></div>
        <div class="muted">여름/겨울방학을 입력하고 <span class="kbd">학사일정 적용</span>을 눌러주세요.</div>
      `);
      return;
    }

    const ss = state.calendar.summerStart ? utcToYmd(state.calendar.summerStart) : "-";
    const se = state.calendar.summerEnd ? utcToYmd(state.calendar.summerEnd) : "-";
    const ws = state.calendar.winterStart ? utcToYmd(state.calendar.winterStart) : "-";
    const we = state.calendar.winterEnd ? utcToYmd(state.calendar.winterEnd) : "-";

    setMsg(el, "ok", `
      <div><b>학사일정 적용 완료</b></div>
      <ul>
        <li>여름방학: ${ss} ~ ${se}</li>
        <li>겨울방학: ${ws} ~ ${we}</li>
      </ul>
      <ul>
        <li>연간 총일수(토요일 제외): <b>${sets.fullCount}</b>일</li>
        <li>방학일수(토요일 제외): <b>${sets.vacCount}</b>일</li>
        <li>학기 총일수(토요일 제외, 방학 제외): <b>${sets.semCount}</b>일</li>
      </ul>
      <div class="muted">※ 방학 입력이 없으면 비상시 출근율(학기중/연간) 산정 정확도가 저하됩니다.</div>
    `);
  }

  function workerKeyOf(name, pid) {
    const p = (pid || "").trim();
    if (p) return p;
    return (name || "").trim();
  }

  function computeServiceYears(hireDateUTC) {
    if (!hireDateUTC) return 0;
    const y = GRANT_DATE.getUTCFullYear() - hireDateUTC.getUTCFullYear();
    const m = GRANT_DATE.getUTCMonth() - hireDateUTC.getUTCMonth();
    const d = GRANT_DATE.getUTCDate() - hireDateUTC.getUTCDate();
    let years = y;
    if (m < 0 || (m === 0 && d < 0)) years -= 1;
    return Math.max(0, years);
  }

  function addOrUpdateWorker(w) {
    if (!w.key) w.key = workerKeyOf(w.name, w.pid);
    if (!w.key) throw new Error("대상자 나이스 개인번호 생성 실패");

    const prev = state.workers.get(w.key);
    const merged = prev ? { ...prev, ...w } : w;

    merged.serviceYears = computeServiceYears(merged.hireDateUTC);
    merged.addDays = Math.floor(Math.max(0, merged.serviceYears - 1) / 2); // 3년차부터 2년에 1일

    state.workers.set(merged.key, merged);
  }

  function renderWorkersTable() {
    const tbody = $("#workersTable tbody");
    tbody.innerHTML = "";

    const arr = Array.from(state.workers.values())
      .sort((a, b) => (a.name || "").localeCompare(b.name || "", "ko"));

    for (const w of arr) {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td class="nowrap">${escapeHtml(w.key)}</td>
        <td class="nowrap">${escapeHtml(w.name)}</td>
        <td class="nowrap">${escapeHtml(w.pid || "")}</td>
        <td class="nowrap">${w.group === "special" ? "특수운영직군" : "교육공무직"}</td>
        <td class="nowrap">${w.pattern === "emergency" ? "방학중 비상시" : "상시"}</td>
        <td class="nowrap">${w.hireDateUTC ? utcToYmd(w.hireDateUTC) : ""}</td>
        <td class="right nowrap">${escapeHtml(String(w.dailyHours ?? DEFAULT_DAILY_HOURS))}</td>
        <td class="right nowrap">${escapeHtml(String(w.serviceYears ?? 0))}년</td>
        <td class="center nowrap"><button class="btn btn-lightgrey" data-del="${escapeHtml(w.key)}">삭제</button></td>
      `;
      tbody.appendChild(tr);
    }

    tbody.querySelectorAll("button[data-del]").forEach(btn => {
      btn.addEventListener("click", () => {
        const key = btn.getAttribute("data-del");
        state.workers.delete(key);
        state.records = state.records.filter(r => r.workerKey !== key);
        renderWorkersTable();
        renderWorkerSelect();
      });
    });

    setMsg($("#hrManualMsg"), arr.length ? "ok" : "warn", `
      <div><b>대상자 수</b>: ${arr.length}명</div>
      <div class="muted">※ 수기 입력 시, 근무상황(복무)도 수기 입력으로 충분히 산정 가능합니다.</div>
    `);
  }

  function renderWorkerSelect() {
    const sel = $("#wSelect");
    sel.innerHTML = "";
    const arr = Array.from(state.workers.values())
      .sort((a,b) => (a.name||"").localeCompare(b.name||"", "ko"));

    if (arr.length === 0) {
      const opt = document.createElement("option");
      opt.value = "";
      opt.textContent = "대상자 없음(인사정보 입력 필요)";
      sel.appendChild(opt);
      sel.disabled = true;
      return;
    }

    sel.disabled = false;
    for (const w of arr) {
      const opt = document.createElement("option");
      opt.value = w.key;
      opt.textContent = `${w.name} (${w.key}) · ${w.group==="special"?"특수":"일반"}/${w.pattern==="emergency"?"비상시":"상시"}`;
      sel.appendChild(opt);
    }
  }

  function nextRecordId() {
    return "R" + Math.random().toString(36).slice(2, 10) + Date.now().toString(36);
  }

  function includesAny(text, keywords) {
    const s = String(text || "").replace(/\s+/g, "");
    return keywords.some(k => s.includes(String(k).replace(/\s+/g, "")));
  }

  function autoClassify(type, reason) {
    const t = String(type || "");
    const r = String(reason || "");
    const hay = (t + " " + r).trim();
    if (!hay) return "review";
    if (includesAny(hay, RULES_2026.excludedKeywords)) return "excluded";
    if (includesAny(hay, RULES_2026.absenceKeywords)) return "absence";
    if (includesAny(hay, RULES_2026.deemedKeywords)) return "deemed";
    if (includesAny(hay, RULES_2026.reviewKeywords)) return "review";
    return "review";
  }

  function autoCreditGuess(type, reason) {
    const hay = (String(type||"") + " " + String(reason||"")).trim();
    if (!hay) return false;
    return includesAny(hay, RULES_2026.creditKeywords);
  }

  function rangeOverlapsVacation(startUTC, endUTC) {
    if (!state.calendar.sets) return false;
    for (let d = startUTC; d <= endUTC; d = addDaysUTC(d, 1)) {
      const ymd = utcToYmd(d);
      if (state.calendar.sets.vacationSet.has(ymd)) return true;
    }
    return false;
  }

  function addRecord(rec) {
    const range = normalizeRange(rec.startUTC, rec.endUTC);
    if (!range) throw new Error("복무 기간이 기준기간과 겹치지 않습니다.");

    const r = {
      id: nextRecordId(),
      workerKey: rec.workerKey,
      startUTC: range.start,
      endUTC: range.end,
      type: rec.type || "",
      reason: rec.reason || "",
      minutes: (rec.minutes == null ? null : Number(rec.minutes)),
      rawDur: rec.rawDur || "",
      approvalStatus: rec.approvalStatus || "",
      sourceFile: rec.sourceFile || "",
      autoClass: autoClassify(rec.type, rec.reason),
      finalClass: rec.finalClass || null,
      credit: !!rec.credit
    };

    if (!r.credit && state.calendar.sets) {
      const anyVac = rangeOverlapsVacation(r.startUTC, r.endUTC);
      if (anyVac && autoCreditGuess(r.type, r.reason)) r.credit = true;
    }

    state.records.push(r);
  }

  function recordClass(r) {
    return r.finalClass || r.autoClass || "review";
  }

  function computeRecordMinutesOnSet(r, dateSet, dailyMinutes) {
    let count = 0;
    for (let d = r.startUTC; d <= r.endUTC; d = addDaysUTC(d, 1)) {
      const ymd = utcToYmd(d);
      if (!dateSet.has(ymd)) continue;
      count += 1;
    }
    if (count === 0) return 0;

    if (r.minutes == null) return count * dailyMinutes;

    const cap = count * dailyMinutes;
    const v = Number(r.minutes) || 0;
    return Math.max(0, Math.min(cap, v));
  }

  function safeDiv(a, b) {
    if (!b || b <= 0) return 0;
    return a / b;
  }

  // ==========================
  // 연차 사용일수(완결만) 집계
  // ==========================
  function normalizeText(s) {
    return String(s || "").replace(/\s+/g, "").trim();
  }

  function isFinalApprovedStatus(statusRaw) {
    const t = normalizeText(statusRaw);
    if (!t) return false;
    if (/(취소|회수|반려|철회|삭제)/.test(t)) return false;
    return t.includes("완결");
  }

  function classifyAnnualLeaveKind(typeRaw) {
    const t = normalizeText(typeRaw);
    if (!t) return null;

    if (/(병가|병지각|병조퇴|병외출|유급병가|무급병가|질병)/.test(t) || t.startsWith("병")) return null;

    if (t.includes("반일연차") || t.includes("반차") || t.includes("반일연가")) return "HALF";

    const isAnnual = (t.includes("연차") || t === "연가" || t.includes("연가"));
    if (!isAnnual) return null;

    if (t.includes("지각")) return "LATE";
    if (t.includes("조퇴")) return "EARLY";
    if (t.includes("외출")) return "OUT";

    return "FULL";
  }

  function minutesToDHM(mins, dailyMinutes) {
    const m = Math.max(0, Math.round(mins || 0));
    const dm = Math.max(1, Math.round(dailyMinutes || 480));

    const days = Math.floor(m / dm);
    const rem = m - days * dm;
    const hours = Math.floor(rem / 60);
    const minutes = rem - hours * 60;

    return { days, hours, minutes };
  }

  function fmtDHM(x) {
    if (!x) return "0일";
    const parts = [];
    parts.push(`${x.days}일`);
    if (x.hours) parts.push(`${x.hours}시간`);
    if (x.minutes) parts.push(`${x.minutes}분`);
    return parts.join(" ");
  }

  function computeAnnualLeaveUsageSummary(workerKey, dailyMinutes) {
    if (!state.calendar.sets) buildCalendarSets();
    const sets = state.calendar.sets;

    const byKind = { FULL:0, HALF:0, LATE:0, EARLY:0, OUT:0 };
    let total = 0;

    const recs = state.records.filter(r => r.workerKey === workerKey);
    for (const r of recs) {
      const kind = classifyAnnualLeaveKind(r.type);
      if (!kind) continue;
      if (!isFinalApprovedStatus(r.approvalStatus)) continue;

      const mins = computeRecordMinutesOnSet(r, sets.fullSet, dailyMinutes);
      total += mins;
      byKind[kind] += mins;
    }

    return { total, byKind };
  }

  // ==========================
  // 출근율/연차부여 계산
  // ==========================
  function baseDaysForWorker(w) {
    const isEmergency = (w.pattern === "emergency");
    const isSpecial = (w.group === "special");
    if (!isEmergency) return 15;
    return isSpecial ? 11 : 12;
  }

  function bonusDaysForWorker(w, rates) {
    if (w.pattern !== "emergency") return 0;
    const rSem = rates.rateSemester ?? 0;
    return (rSem >= 0.8) ? 3 : 0;
  }

  function totalStandardDays(w, baseDays, bonusDays) {
    const add = w.addDays ?? 0;
    return Math.min(25, baseDays + (bonusDays || 0) + add);
  }

  function calcRatesForWorker(w) {
    const dailyHours = Number(w.dailyHours || DEFAULT_DAILY_HOURS);
    const dailyMinutes = dailyHours * 60;

    if (!state.calendar.sets) buildCalendarSets();
    const sets = state.calendar.sets;

    const workerRecords = state.records.filter(r => r.workerKey === w.key);

    let excludedFull = 0, absenceFull = 0;
    let excludedSem = 0, absenceSem = 0;
    let creditVac = 0;

    for (const r of workerRecords) {
      const cls = recordClass(r);

      const mFull = computeRecordMinutesOnSet(r, sets.fullSet, dailyMinutes);
      if (cls === "excluded") excludedFull += mFull;
      if (cls === "absence") absenceFull += mFull;

      const mSem = computeRecordMinutesOnSet(r, sets.semesterSet, dailyMinutes);
      if (cls === "excluded") excludedSem += mSem;
      if (cls === "absence") absenceSem += mSem;

      if (r.credit) {
        const mVac = computeRecordMinutesOnSet(r, sets.vacationSet, dailyMinutes);
        creditVac += mVac;
      }
    }

    const fullTotal = sets.fullCount * dailyMinutes;

    if (w.pattern !== "emergency") {
      const attended = Math.max(0, fullTotal - excludedFull - absenceFull);
      const rateFull = safeDiv(attended, fullTotal);

      const rateProportional = (rateFull < 0.8)
        ? safeDiv(attended, Math.max(1, fullTotal - excludedFull))
        : null;

      return {
        dailyMinutes,
        fullTotal,
        semTotal: null,
        excludedFull, absenceFull,
        excludedSem: null, absenceSem: null,
        creditVac: null,
        attendedFull: attended,
        attendedSem: null,
        rateSemester: null,
        rateFull,
        rateProportional
      };
    }

    const semTotal = sets.semCount * dailyMinutes;
    const attendedSem = Math.max(0, semTotal - excludedSem - absenceSem);
    const attendedFull = Math.max(0, attendedSem + creditVac);

    const rateSemester = safeDiv(attendedSem, semTotal);
    const rateFull = safeDiv(attendedFull, fullTotal);

    const rateProportional = (rateSemester < 0.8)
      ? safeDiv(attendedSem, Math.max(1, semTotal - excludedSem))
      : null;

    return {
      dailyMinutes,
      fullTotal,
      semTotal,
      excludedFull, absenceFull,
      excludedSem, absenceSem,
      creditVac,
      attendedFull,
      attendedSem,
      rateSemester,
      rateFull,
      rateProportional
    };
  }

  function roundToOneDecimalDays(days) {
    return Math.round(days * 10) / 10;
  }

  function daysToDaysHours(days, dailyHours) {
    const d = Math.floor(days);
    const frac = days - d;
    let h = Math.round(frac * dailyHours);
    let dd = d;
    if (h >= dailyHours) { dd += 1; h = 0; }
    return { days: dd, hours: h };
  }

  function toYm(dateUTC) {
    const y = dateUTC.getUTCFullYear();
    const m = String(dateUTC.getUTCMonth() + 1).padStart(2, "0");
    return `${y}-${m}`;
  }

  function startOfMonthUTC(dateUTC) {
    return new Date(Date.UTC(dateUTC.getUTCFullYear(), dateUTC.getUTCMonth(), 1));
  }

  function startOfNextMonthUTC(dateUTC) {
    return new Date(Date.UTC(dateUTC.getUTCFullYear(), dateUTC.getUTCMonth() + 1, 1));
  }

  function firstFullMonthStartUTC(hireUTC) {
    if (!hireUTC) return PERIOD_START;
    const ms = startOfMonthUTC(hireUTC);
    if (hireUTC.getUTCDate() === 1) return ms;
    return startOfNextMonthUTC(hireUTC);
  }

  function enumerateMonths(startUTC, endUTC) {
    const res = [];
    let y = startUTC.getUTCFullYear();
    let m = startUTC.getUTCMonth() + 1;
    const ey = endUTC.getUTCFullYear();
    const em = endUTC.getUTCMonth() + 1;

    while (y < ey || (y === ey && m <= em)) {
      res.push(`${y}-${String(m).padStart(2,"0")}`);
      m += 1;
      if (m === 13) { m = 1; y += 1; }
    }
    return res;
  }

  function anyAbsenceInMonth(absenceDates, ym) {
    for (const ymd of absenceDates) {
      if (ymd.startsWith(ym + "-")) return true;
    }
    return false;
  }

  function anyAbsenceInRange(absenceDates, startUTC, endUTC) {
    if (!startUTC || !endUTC) return false;
    const r = normalizeRange(startUTC, endUTC);
    if (!r) return false;
    for (let d = r.start; d <= r.end; d = addDaysUTC(d, 1)) {
      if (isSaturdayUTC(d)) continue;
      const ymd = utcToYmd(d);
      if (absenceDates.has(ymd)) return true;
    }
    return false;
  }

  function calcMonthlyAccrual(w) {
    const dailyHours = Number(w.dailyHours || DEFAULT_DAILY_HOURS);
    const dailyMinutes = dailyHours * 60;

    const workerRecords = state.records.filter(r => r.workerKey === w.key && recordClass(r) === "absence");
    const sets = state.calendar.sets;

    const absenceDates = new Set();

    for (const r of workerRecords) {
      for (let d = r.startUTC; d <= r.endUTC; d = addDaysUTC(d, 1)) {
        if (isSaturdayUTC(d)) continue;
        const ymd = utcToYmd(d);
        if (!sets || sets.fullSet.has(ymd)) absenceDates.add(ymd);
      }
    }

    let accrualStart = PERIOD_START;
    if (w.hireDateUTC) {
      const hire = w.hireDateUTC;
      if (hire > PERIOD_START) {
        accrualStart = firstFullMonthStartUTC(hire);
      }
    }
    if (accrualStart < PERIOD_START) accrualStart = PERIOD_START;

    if (w.pattern !== "emergency") {
      const months = enumerateMonths(accrualStart, PERIOD_END);
      let okCount = 0;
      for (const ym of months) {
        const hasAbs = anyAbsenceInMonth(absenceDates, ym);
        if (!hasAbs) okCount += 1;
      }
      const capped = Math.min(11, okCount);
      const spanText = months.length ? `${months[0]}~${months[months.length - 1]}` : "해당없음";
      return { days: capped, hours: 0, note: `개근월수(상시): ${okCount}개월 중 ${capped}일(최대11) 부여 · 산정월(${spanText})` };
    }

    const bucketMonths = ["2025-03","2025-04","2025-05","2025-06","2025-09","2025-10","2025-11"];
    const startYM = toYm(accrualStart);

    let ok = 0;
    let vacBucketsAdded = 0;

    for (const ym of bucketMonths) {
      if (ym < startYM) continue;
      const hasAbs = anyAbsenceInMonth(absenceDates, ym);
      if (!hasAbs) ok += 1;
    }

    if (state.calendar.applied && sets && sets.vacCount > 0) {
      const vacs = [];
      if (state.calendar.summerStart && state.calendar.summerEnd) {
        const r = normalizeRange(state.calendar.summerStart, state.calendar.summerEnd);
        if (r) vacs.push({ name: "여름방학", start: r.start, end: r.end });
      }
      if (state.calendar.winterStart && state.calendar.winterEnd) {
        const r = normalizeRange(state.calendar.winterStart, state.calendar.winterEnd);
        if (r) vacs.push({ name: "겨울방학", start: r.start, end: r.end });
      }

      for (const v of vacs) {
        if (v.start < accrualStart) continue;
        const hasAbs = anyAbsenceInRange(absenceDates, v.start, v.end);
        if (!hasAbs) { ok += 1; vacBucketsAdded += 1; }
      }
    }

    const capped = Math.min(9, ok);
    const noteParts = [];
    noteParts.push(`개근월수(비상시): 버킷 ${ok}개 중 ${capped}일(최대9) 부여`);
    noteParts.push(`산정 시작월: ${startYM}`);
    if (!state.calendar.applied || !sets || sets.vacCount === 0) noteParts.push("방학 미입력: 방학버킷(최대2) 미반영");
    else noteParts.push(`방학버킷 반영: ${vacBucketsAdded}개`);
    return { days: capped, hours: 0, note: noteParts.join(" · ") };
  }

  function calcGrantForWorker(w) {
    const rates = calcRatesForWorker(w);

    const baseDays = baseDaysForWorker(w);
    const bonusDays = bonusDaysForWorker(w, rates);
    const standard = totalStandardDays(w, baseDays, bonusDays);

    const serviceYears = w.serviceYears ?? 0;
    const isEmergency = (w.pattern === "emergency");

    if (serviceYears < 1) {
      const monthly = calcMonthlyAccrual(w);
      return {
        workerKey: w.key,
        baseDays,
        bonusDays: 0,
        addDays: w.addDays ?? 0,
        standardDays: totalStandardDays(w, baseDays, 0),
        finalDays: monthly.days,
        finalHours: monthly.hours,
        method: "신규(1년 미만) 1개월 개근 1일",
        note: monthly.note,
        rates
      };
    }

    if (!isEmergency) {
      const rate1 = rates.rateFull ?? 0;
      const rateP = rates.rateProportional ?? 0;

      if (rate1 >= 0.8) {
        return { workerKey: w.key, baseDays, bonusDays: 0, addDays: w.addDays ?? 0, standardDays: standard, finalDays: standard, finalHours: 0, method: "정상부여(연간 출근율 80% 이상)", note: "", rates };
      }

      if (rates.rateProportional != null && rateP >= 0.8) {
        const fullDays = state.calendar.sets ? state.calendar.sets.fullCount : 0;
        const excludedDays = Math.round((rates.excludedFull ?? 0) / rates.dailyMinutes);
        const ratio = safeDiv(Math.max(0, fullDays - excludedDays), Math.max(1, fullDays));
        const raw = standard * ratio;
        const rounded = roundToOneDecimalDays(raw);
        const dh = daysToDaysHours(rounded, (w.dailyHours || DEFAULT_DAILY_HOURS));
        return { workerKey: w.key, baseDays, bonusDays: 0, addDays: w.addDays ?? 0, standardDays: standard, finalDays: dh.days, finalHours: dh.hours, method: "비례부여(비례산정 출근율 80% 충족)", note: `비례: ${standard} × (${fullDays - excludedDays}/${fullDays}) = ${rounded}일`, rates };
      }

      const monthly = calcMonthlyAccrual(w);
      return { workerKey: w.key, baseDays, bonusDays: 0, addDays: w.addDays ?? 0, standardDays: standard, finalDays: monthly.days, finalHours: monthly.hours, method: "80% 미달 → 개근월수(1개월 1일)", note: monthly.note, rates };
    }

    const rateSem = rates.rateSemester ?? 0;
    const rateP = rates.rateProportional ?? 0;

    if (rateSem >= 0.8) {
      return { workerKey: w.key, baseDays, bonusDays, addDays: w.addDays ?? 0, standardDays: standard, finalDays: standard, finalHours: 0, method: "정상부여(학기중 출근율 80% 이상)", note: "", rates };
    }

    if (rates.rateProportional != null && rateP >= 0.8) {
      const semDays = state.calendar.sets ? state.calendar.sets.semCount : 0;
      const excludedDays = Math.round((rates.excludedSem ?? 0) / rates.dailyMinutes);
      const ratio = safeDiv(Math.max(0, semDays - excludedDays), Math.max(1, semDays));
      const raw = standard * ratio;
      const rounded = roundToOneDecimalDays(raw);
      const dh = daysToDaysHours(rounded, (w.dailyHours || DEFAULT_DAILY_HOURS));
      return { workerKey: w.key, baseDays, bonusDays: 0, addDays: w.addDays ?? 0, standardDays: standard, finalDays: dh.days, finalHours: dh.hours, method: "비례부여(비례산정 출근율 80% 충족)", note: `비례: ${standard} × (${semDays - excludedDays}/${semDays}) = ${rounded}일`, rates };
    }

    const monthly = calcMonthlyAccrual(w);
    return { workerKey: w.key, baseDays, bonusDays: 0, addDays: w.addDays ?? 0, standardDays: standard, finalDays: monthly.days, finalHours: monthly.hours, method: "80% 미달 → 개근월수(1개월 1일)", note: monthly.note, rates };
  }

  function pct(x) {
    return (x * 100).toFixed(1) + "%";
  }

  function minutesToDays(mins, dailyMinutes) {
    const days = (mins / dailyMinutes);
    const rounded = Math.round(days * 10) / 10;
    const dh = daysToDaysHours(rounded, dailyMinutes/60);
    return (dh.hours > 0) ? `${dh.days}일 ${dh.hours}시간` : `${dh.days}일`;
  }

  function formatStdCompact(r) {
    const parts = [];
    parts.push(String(r.baseDays ?? 0));
    if (r.bonusDays) parts.push(String(r.bonusDays));
    if (r.addDays) parts.push(String(r.addDays));
    return `${parts.join("+")}=${r.standardDays ?? 0}`;
  }

  function renderRecordRow(rec) {
    const auto = rec.autoClass || "review";
    const fin = rec.finalClass || "auto";
    const range = `${utcToYmd(rec.startUTC)} ~ ${utcToYmd(rec.endUTC)}`;
    const opt = (value, label) => `<option value="${value}" ${fin===value ? "selected":""}>${label}</option>`;

    return `
      <tr>
        <td class="nowrap">${escapeHtml(range)}</td>
        <td class="nowrap">${escapeHtml(rec.type || "")}</td>
        <td class="nowrap">${escapeHtml(rec.reason || "")}</td>
        <td class="nowrap">${escapeHtml(rec.approvalStatus || "")}</td>
        <td class="nowrap">${escapeHtml(CLASS_LABEL[auto] || auto)}</td>
        <td class="nowrap">
          <select data-rec-id="${rec.id}" data-field="finalClass">
            ${opt("auto","자동(기본)")}
            ${opt("deemed","출근간주")}
            ${opt("excluded","산정제외")}
            ${opt("absence","결근성")}
            ${opt("review","검토")}
          </select>
        </td>
        <td class="center nowrap">
          <input type="checkbox" data-rec-id="${rec.id}" data-field="credit" ${rec.credit ? "checked":""} />
        </td>
        <td class="center nowrap">
          <button class="btn btn-lightgrey" data-rec-id="${rec.id}" data-field="delete">삭제</button>
        </td>
      </tr>
    `;
  }

  function safeFilename(s) {
    return String(s || "")
      .replace(/[\\\/:*?"<>|]/g, "_")
      .replace(/\s+/g, "_")
      .slice(0, 60);
  }

  function downloadWorkerDetailXlsx(workerKey) {
    const w = state.workers.get(workerKey);
    const rr = state.results.find(x => x.workerKey === workerKey);

    if (!w || !rr) {
      alert("개인별 상세를 저장하려면 먼저 계산을 실행해주세요.");
      return;
    }

    if (!state.calendar.sets) buildCalendarSets();
    const sets = state.calendar.sets;

    const dailyMinutes = rr.rates.dailyMinutes || Math.round(Number(w.dailyHours || DEFAULT_DAILY_HOURS) * 60);
    const records = state.records.filter(x => x.workerKey === workerKey).sort((a,b) => a.startUTC - b.startUTC);

    const sum = { deemed:0, excluded:0, absence:0, review:0, creditVac:0, total: sets.fullCount * dailyMinutes };
    for (const rec of records) {
      const cls = recordClass(rec);
      const mFull = computeRecordMinutesOnSet(rec, sets.fullSet, dailyMinutes);
      sum[cls] = (sum[cls] || 0) + mFull;

      if (rec.credit) {
        sum.creditVac += computeRecordMinutesOnSet(rec, sets.vacationSet, dailyMinutes);
      }
    }

    const leaveUsage = computeAnnualLeaveUsageSummary(workerKey, dailyMinutes);

    const rateSem = (rr.rates.rateSemester == null) ? "-" : pct(rr.rates.rateSemester);
    const rateFull = pct(rr.rates.rateFull ?? 0);
    const rateProp = (rr.rates.rateProportional == null) ? "-" : pct(rr.rates.rateProportional);

    const finalText = (rr.finalHours > 0) ? `${rr.finalDays}일 ${rr.finalHours}시간` : `${rr.finalDays}일`;
    const stdText = formatStdCompact(rr);

    const ss = state.calendar.summerStart ? utcToYmd(state.calendar.summerStart) : "";
    const se = state.calendar.summerEnd ? utcToYmd(state.calendar.summerEnd) : "";
    const ws = state.calendar.winterStart ? utcToYmd(state.calendar.winterStart) : "";
    const we = state.calendar.winterEnd ? utcToYmd(state.calendar.winterEnd) : "";

    const rows1 = [];
    rows1.push(["항목","값"]);
    rows1.push(["나이스개인번호", w.key || ""]);
    rows1.push(["성명", w.name || ""]);
    rows1.push(["직군", w.group==="special" ? "특수운영직군" : "교육공무직"]);
    rows1.push(["근무형태", w.pattern==="emergency" ? "방학중비상시" : "상시"]);
    rows1.push(["최초임용일", w.hireDateUTC ? utcToYmd(w.hireDateUTC) : ""]);
    rows1.push(["1일 소정근로시간", String(w.dailyHours ?? DEFAULT_DAILY_HOURS)]);
    rows1.push(["근속연수(2026-03-01)", String(w.serviceYears ?? 0) + "년"]);
    rows1.push(["학사일정(여름)", (ss && se) ? `${ss}~${se}` : ""]);
    rows1.push(["학사일정(겨울)", (ws && we) ? `${ws}~${we}` : ""]);
    rows1.push(["출근율(학기중)", rateSem]);
    rows1.push(["출근율(연간)", rateFull]);
    rows1.push(["출근율(비례산정)", rateProp]);
    rows1.push(["기본연차(비상시 기본 12/11)", String(rr.baseDays ?? "")]);
    rows1.push(["출근가산(비상시 학기중80% 이상)", String(rr.bonusDays ?? 0)]);
    rows1.push(["근속가산(3년차부터 2년에 1일)", String(rr.addDays ?? 0)]);
    rows1.push(["기본+가산(상한25)", stdText]);
    rows1.push(["최종부여", finalText]);
    rows1.push(["판정", rr.method || ""]);
    rows1.push(["비고", rr.note || ""]);
    rows1.push(["연차 사용(완결만 집계)", fmtDHM(minutesToDHM(leaveUsage.total, dailyMinutes))]);
    rows1.push(["복무-산정제외(연간)", minutesToDays(sum.excluded, dailyMinutes)]);
    rows1.push(["복무-결근성(연간)", minutesToDays(sum.absence, dailyMinutes)]);
    rows1.push(["복무-출근간주(연간)", minutesToDays(sum.deemed, dailyMinutes)]);
    rows1.push(["복무-검토(연간)", minutesToDays(sum.review, dailyMinutes)]);
    if (w.pattern === "emergency") {
      rows1.push(["비상시 방학중 근무(분자 가산)", minutesToDays(sum.creditVac, dailyMinutes)]);
    }

    const rows2 = [];
    rows2.push(["기간시작","기간종료","종별","사유","결재상태","자동분류","최종분류","방학중근무가산","분(저장값)","원본시간/일수","파일"]);
    for (const rec of records) {
      const auto = rec.autoClass || "review";
      const fin = rec.finalClass || "auto";
      rows2.push([
        utcToYmd(rec.startUTC),
        utcToYmd(rec.endUTC),
        rec.type || "",
        rec.reason || "",
        rec.approvalStatus || "",
        CLASS_LABEL[auto] || auto,
        fin === "auto" ? "자동" : (CLASS_LABEL[fin] || fin),
        rec.credit ? "Y" : "",
        (rec.minutes == null ? "" : rec.minutes),
        rec.rawDur || "",
        rec.sourceFile || ""
      ]);
    }

    const u8 = MiniXLSX.writeWorkbook([
      { name: "요약", rows: rows1 },
      { name: "복무내역", rows: rows2 }
    ]);
    const blob = new Blob([u8], { type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" });

    saveOrShowBase64(blob, `2026학년도_개인별상세_${safeFilename(w.name)}_${safeFilename(w.key)}.xlsx`);
  }

  function renderDetail() {
    const box = $("#detailBox");
    box.innerHTML = "";

    const resArr = state.results.slice().sort((a,b) => {
      const wa = state.workers.get(a.workerKey);
      const wb = state.workers.get(b.workerKey);
      return (wa?.name || "").localeCompare(wb?.name || "", "ko");
    });

    for (const rr of resArr) {
      const w = state.workers.get(rr.workerKey);
      const records = state.records.filter(x => x.workerKey === rr.workerKey).sort((a,b) => a.startUTC - b.startUTC);

      const sets = state.calendar.sets;
      const dailyMinutes = rr.rates.dailyMinutes || (Number(w?.dailyHours||DEFAULT_DAILY_HOURS)*60);

      const sum = { deemed:0, excluded:0, absence:0, review:0, creditVac:0, total:0 };
      if (sets) sum.total = sets.fullCount * dailyMinutes;

      for (const rec of records) {
        const cls = recordClass(rec);
        const mFull = sets ? computeRecordMinutesOnSet(rec, sets.fullSet, dailyMinutes) : 0;
        sum[cls] = (sum[cls] || 0) + mFull;

        if (rec.credit && sets) {
          sum.creditVac += computeRecordMinutesOnSet(rec, sets.vacationSet, dailyMinutes);
        }
      }

      const rateSem = (rr.rates.rateSemester == null) ? "-" : pct(rr.rates.rateSemester);
      const rateFull = pct(rr.rates.rateFull ?? 0);
      const rateProp = (rr.rates.rateProportional == null) ? "-" : pct(rr.rates.rateProportional);

      const final = (rr.finalHours > 0) ? `${rr.finalDays}일 ${rr.finalHours}시간` : `${rr.finalDays}일`;
      const stdCompact = formatStdCompact(rr);

      const stdParts = [];
      stdParts.push(`기본 ${rr.baseDays}일`);
      if (rr.bonusDays) stdParts.push(`출근가산 ${rr.bonusDays}일`);
      if (rr.addDays) stdParts.push(`근속가산 ${rr.addDays}일`);
      stdParts.push(`= ${rr.standardDays}일`);

      const leaveUsage = computeAnnualLeaveUsageSummary(rr.workerKey, dailyMinutes);

      const details = document.createElement("details");
      details.className = "card";
      details.open = false;

      details.innerHTML = `
        <summary>
          ${escapeHtml(w?.name || rr.workerKey)} (${escapeHtml(w?.key || rr.workerKey)})
          · <span class="pill">${w?.group==="special" ? "특수운영" : "교육공무직"}</span>
          · <span class="pill">${w?.pattern==="emergency" ? "비상시" : "상시"}</span>
          · 최종 <b>${final}</b> (${escapeHtml(rr.method)})
        </summary>

        <div class="row gap" style="margin-top:10px;">
          <button class="btn" data-action="downloadDetail" data-worker="${escapeHtml(rr.workerKey)}">개인별 상세 엑셀 저장</button>
        </div>

        <div style="margin-top:12px;" class="grid two">
          <div class="msg">
            <div><b>기본/가산</b>: ${escapeHtml(stdParts.join(" + "))} <span class="muted">(${escapeHtml(stdCompact)})</span> (상한25 적용)</div>
            <div><b>근속</b>: ${escapeHtml(String(w?.serviceYears ?? 0))}년 (기준일 2026-03-01)</div>
            <div><b>출근율</b>: 학기중 ${rateSem} · 연간 ${rateFull} · 비례산정 ${rateProp}</div>
            <div><b>연차 사용(완결만)</b>: ${fmtDHM(minutesToDHM(leaveUsage.total, dailyMinutes))}</div>
            ${rr.note ? `<div class="muted">※ ${escapeHtml(rr.note)}</div>` : ""}
          </div>

          <div class="msg">
            <div><b>복무 분류 합계(연간 기준)</b></div>
            <ul>
              <li>산정제외: ${minutesToDays(sum.excluded, dailyMinutes)}</li>
              <li>결근성: ${minutesToDays(sum.absence, dailyMinutes)}</li>
              <li>출근간주: ${minutesToDays(sum.deemed, dailyMinutes)} <span class="muted">(정보성)</span></li>
              <li>검토: ${minutesToDays(sum.review, dailyMinutes)}</li>
              ${w?.pattern==="emergency" ? `<li>비상시직종 방학중 근무 (분자 가산): ${minutesToDays(sum.creditVac, dailyMinutes)}</li>` : ""}
            </ul>
            <div class="muted">※애매한 건 검토 필요로 분류함.</div>
          </div>
        </div>

        <hr />

        <h4>복무 전체 목록(최종분류 수정 가능)</h4>
        <div class="table-wrap">
          <table class="sheetlike table-compact">
            <thead>
              <tr>
                <th class="nowrap">기간</th>
                <th class="nowrap">종별</th>
                <th class="nowrap">사유</th>
                <th class="nowrap">결재상태</th>
                <th class="nowrap">자동</th>
                <th class="nowrap">최종</th>
                <th class="nowrap">비상시직종방학추가근무</th>
                <th class="nowrap center">삭제</th>
              </tr>
            </thead>
            <tbody>
              ${records.map(rec => renderRecordRow(rec)).join("")}
            </tbody>
          </table>
        </div>
      `;

      box.appendChild(details);
    }

    box.querySelectorAll("[data-rec-id]").forEach(el => {
      const rid = el.getAttribute("data-rec-id");
      const field = el.getAttribute("data-field");

      if (field === "finalClass") {
        el.addEventListener("change", () => {
          const rec = state.records.find(x => x.id === rid);
          if (!rec) return;
          const v = el.value;
          rec.finalClass = (v === "auto") ? null : v;
          runCalculation();
        });
      }

      if (field === "credit") {
        el.addEventListener("change", () => {
          const rec = state.records.find(x => x.id === rid);
          if (!rec) return;
          rec.credit = !!el.checked;
          runCalculation();
        });
      }

      if (field === "delete") {
        el.addEventListener("click", () => {
          state.records = state.records.filter(x => x.id !== rid);
          runCalculation();
        });
      }
    });

    box.querySelectorAll("button[data-action='downloadDetail']").forEach(btn => {
      btn.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        const wk = btn.getAttribute("data-worker");
        if (!wk) return;
        downloadWorkerDetailXlsx(wk);
      });
    });
  }

  function renderResults() {
    const tbody = $("#resultTable tbody");
    tbody.innerHTML = "";

    const detailNotice = $("#detailNotice");

    if (!state.results || state.results.length === 0) {
      setMsg($("#resultSummary"), "warn", "계산 결과가 없습니다. <b>계산 실행</b>을 먼저 수행하세요.");
      $("#detailBox").innerHTML = "";
      detailNotice.classList.add("hidden");
      return;
    }

    detailNotice.classList.remove("hidden");

    const resArr = state.results.slice().sort((a,b) => {
      const wa = state.workers.get(a.workerKey);
      const wb = state.workers.get(b.workerKey);
      return (wa?.name || "").localeCompare(wb?.name || "", "ko");
    });

    setMsg($("#resultSummary"), "ok", `
      <div><b>계산 완료</b> · 대상자 ${resArr.length}명 · 실행시각: ${escapeHtml(new Date(state.lastRunAt).toLocaleString())}</div>
      <div class="muted">※ 상세에서 복무 자동분류를 <b>최종분류로 수정</b>하면 즉시 재계산됩니다.</div>
    `);

    for (const r of resArr) {
      const w = state.workers.get(r.workerKey);
      const rateSem = (r.rates.rateSemester == null) ? "-" : pct(r.rates.rateSemester);
      const rateFull = pct(r.rates.rateFull ?? 0);
      const rateProp = (r.rates.rateProportional == null) ? "-" : pct(r.rates.rateProportional);

      const std = formatStdCompact(r);
      const final = (r.finalHours > 0) ? `${r.finalDays}일 ${r.finalHours}시간` : `${r.finalDays}일`;

      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td class="nowrap">${escapeHtml(w?.key || r.workerKey)}</td>
        <td class="nowrap">${escapeHtml(w?.name || "")}</td>
        <td class="nowrap">${w?.group==="special" ? "특수운영" : "교육공무직"}</td>
        <td class="nowrap">${w?.pattern==="emergency" ? "비상시" : "상시"}</td>
        <td class="right nowrap">${escapeHtml(String(w?.serviceYears ?? 0))}년</td>
        <td class="right nowrap">${rateSem}</td>
        <td class="right nowrap">${rateFull}</td>
        <td class="right nowrap">${rateProp}</td>
        <td class="right nowrap">${escapeHtml(std)}</td>
        <td class="right nowrap"><b>${final}</b></td>
        <td class="nowrap">${escapeHtml(r.method)}</td>
      `;
      tbody.appendChild(tr);
    }

    renderDetail();
  }

  function readFileAsArrayBuffer(file) {
    return new Promise((resolve, reject) => {
      const fr = new FileReader();
      fr.onload = () => resolve(fr.result);
      fr.onerror = () => reject(new Error("파일 읽기 실패"));
      fr.readAsArrayBuffer(file);
    });
  }

  function readFileAsText(file) {
    return new Promise((resolve, reject) => {
      const fr = new FileReader();
      fr.onload = () => resolve(String(fr.result || ""));
      fr.onerror = () => reject(new Error("파일 읽기 실패"));
      fr.readAsText(file, "utf-8");
    });
  }

  function normalizeHeader(s) {
    return String(s || "").replace(/\s+/g, "").replace(/[()]/g, "").toLowerCase();
  }

  function findHeaderRow(rows, mustHaveAny) {
    let bestIdx = -1;
    let bestScore = -1;

    for (let i = 0; i < Math.min(rows.length, 30); i++) {
      const row = rows[i];
      if (!Array.isArray(row)) continue;

      const nh = row.map(normalizeHeader);
      const joined = nh.join("|");

      const hit = mustHaveAny.some(k => joined.includes(normalizeHeader(k)));
      if (!hit) continue;

      const score = nh.filter(x => x && x.length >= 2).length;
      if (score > bestScore) {
        bestScore = score;
        bestIdx = i;
      }
    }
    return bestIdx;
  }

  function findColumnIndex(headers, candidates) {
    const nh = headers.map(normalizeHeader);
    for (const c of candidates) {
      const nc = normalizeHeader(c);
      const idx = nh.findIndex(h => h === nc);
      if (idx >= 0) return idx;
    }
    for (const c of candidates) {
      const nc = normalizeHeader(c);
      const idx = nh.findIndex(h => h.includes(nc) || nc.includes(h));
      if (idx >= 0) return idx;
    }
    return -1;
  }

  function parseDateLoose(v) {
    const s = String(v || "").trim();
    if (!s) return null;

    const m = s.match(/(\d{4})[.\-/](\d{1,2})[.\-/](\d{1,2})/);
    if (m) {
      const y = Number(m[1]);
      const mo = Number(m[2]);
      const d = Number(m[3]);
      return new Date(Date.UTC(y, mo - 1, d));
    }
    return null;
  }

  function safeNum(v, fallback = NaN) {
    const n = Number(String(v ?? "").replace(/[^0-9.\-]/g, ""));
    return Number.isFinite(n) ? n : fallback;
  }

  function parseRangeLoose(s) {
    const str = String(s||"").trim();
    if (!str) return null;
    const parts = str.split(/~|〜/).map(x => x.trim()).filter(Boolean);
    if (parts.length === 2) {
      const a = parseDateLoose(parts[0]);
      const b = parseDateLoose(parts[1]);
      if (a && b) return { start: a, end: b };
    }
    const d = parseDateLoose(str);
    if (d) return { start: d, end: d };
    return null;
  }

  function parseDurationToMinutes(cell, dailyMinutes) {
    if (cell == null) return null;
    const s = String(cell || "").trim();
    if (!s) return null;

    let days = null, hours = null, mins = null;

    const md = s.match(/(-?\d+(?:\.\d+)?)\s*일/);
    if (md) days = Number(md[1]);

    const mh = s.match(/(-?\d+(?:\.\d+)?)\s*시간/);
    if (mh) hours = Number(mh[1]);

    const mm = s.match(/(-?\d+(?:\.\d+)?)\s*분/);
    if (mm) mins = Number(mm[1]);

    if (md || mh || mm) {
      let total = 0;
      if (days != null && Number.isFinite(days)) total += days * dailyMinutes;
      if (hours != null && Number.isFinite(hours)) total += hours * 60;
      if (mins != null && Number.isFinite(mins)) total += mins;
      return Math.round(total);
    }

    return null;
  }

  function csvToRows(text) {
    const lines = String(text || "").split(/\r?\n/).filter(x => x.trim() !== "");
    return lines.map(line => parseCsvLine(line));
  }

  function parseCsvLine(line) {
    const res = [];
    let cur = "";
    let inQ = false;

    for (let i = 0; i < line.length; i++) {
      const ch = line[i];
      if (ch === '"' ) {
        if (inQ && line[i+1] === '"') { cur += '"'; i++; continue; }
        inQ = !inQ; continue;
      }
      if (ch === "," && !inQ) { res.push(cur); cur = ""; continue; }
      cur += ch;
    }
    res.push(cur);
    return res;
  }

  function htmlTableToRows(html){
    const doc = new DOMParser().parseFromString(String(html||""), "text/html");
    const table = doc.querySelector("table");
    if (!table) throw new Error("XLS(HTML)에서 테이블을 찾지 못했습니다.");
    const rows = [];
    table.querySelectorAll("tr").forEach(tr => {
      const r = [];
      tr.querySelectorAll("th,td").forEach(td => r.push((td.textContent || "").trim()));
      rows.push(r);
    });
    return rows;
  }

  function looksLikeHtmlTable(text){
    const s = String(text || "").toLowerCase();
    return s.includes("<table") && s.includes("</table>");
  }

  async function readSpreadsheetRows(file){
    const name = String(file?.name || "");
    const ext = (name.split(".").pop() || "").toLowerCase();

    if (ext === "csv") {
      const text = await readFileAsText(file);
      return csvToRows(text);
    }

    // XLSX: zip signature PK
    const buf = await readFileAsArrayBuffer(file);
    const u8 = new Uint8Array(buf);
    const isZip = (u8[0] === 0x50 && u8[1] === 0x4b);

    if (isZip) {
      // xlsx
      return await MiniXLSX.xlsxFirstSheetToRows(buf);
    }

    // .xls인데 실제는 HTML 테이블인 경우가 많음
    const text = await readFileAsText(file);
    if (looksLikeHtmlTable(text)) return htmlTableToRows(text);

    // 마지막: 그냥 csv처럼 파싱 시도
    return csvToRows(text);
  }

  // ==========================
  // HR 파일 로드(단일 파일)
  // ==========================
  async function loadHrFileSingle(file) {
    const rows = await readSpreadsheetRows(file);

    const headerIdx = findHeaderRow(rows, ["성명", "이름", "직종", "근무"]);
    if (headerIdx < 0) throw new Error("인사기록 파일에서 헤더 행을 찾지 못했습니다. (양식 확인 필요)");

    const headers = rows[headerIdx].map(x => String(x || "").trim());
    const dataRows = rows.slice(headerIdx + 1).filter(r => Array.isArray(r) && r.some(x => String(x||"").trim() !== ""));

    const colName = findColumnIndex(headers, ["성명","이름"]);
    const colPid  = findColumnIndex(headers, ["개인번호","사번","인적번호","개인번호(아이디)","나이스개인번호"]);
    const colHire = findColumnIndex(headers, ["최초임용일","근무시작일","임용일","현소속교육청근무일","최초계약일","계약시작일"]);
    const colGroup = findColumnIndex(headers, ["직군","직군구분","직종구분","구분"]);
    const colJob = findColumnIndex(headers, ["직종","직종명"]);
    const colPattern = findColumnIndex(headers, ["근무형태","근무형태명","근무구분","근무유형"]);
    const colDailyH = findColumnIndex(headers, ["1일근로시간","일근로시간","1일소정근로시간"]);
    const colWeeklyH = findColumnIndex(headers, ["주소정근로시간","주당근로시간","주근무시간"]);

    if (colName < 0) throw new Error("인사기록 파일에서 [성명] 컬럼을 찾지 못했습니다.");

    let loaded = 0;
    let skipped = 0;

    for (const row of dataRows) {
      const name = String(row[colName] || "").trim();
      if (!name) { skipped++; continue; }

      const pid = (colPid >= 0) ? String(row[colPid] || "").trim() : "";
      const hire = (colHire >= 0) ? parseDateLoose(row[colHire]) : null;

      const groupRaw = (colGroup >= 0) ? String(row[colGroup] || "").trim() : "";
      const jobRaw = (colJob >= 0) ? String(row[colJob] || "").trim() : "";
      const group = (groupRaw.includes("특수") || jobRaw.includes("특수")) ? "special" : "regular";

      const patRaw = (colPattern >= 0) ? String(row[colPattern] || "").trim() : "";
      const pattern = (patRaw.includes("비상") || patRaw.includes("방학") || patRaw.includes("비근무")) ? "emergency" : "always";

      let dailyHours = DEFAULT_DAILY_HOURS;
      if (colDailyH >= 0) {
        const v = safeNum(row[colDailyH], NaN);
        if (Number.isFinite(v) && v > 0) dailyHours = v;
      } else if (colWeeklyH >= 0) {
        const v = safeNum(row[colWeeklyH], NaN);
        if (Number.isFinite(v) && v > 0) {
          dailyHours = Math.round((v / 5) * 10) / 10;
        }
      }

      addOrUpdateWorker({
        key: workerKeyOf(name, pid),
        name, pid,
        group,
        pattern,
        hireDateUTC: hire,
        dailyHours
      });

      loaded++;
    }

    return { loaded, skipped };
  }

  async function handleLoadHrFiles(files) {
    if (!files || files.length === 0) throw new Error("인사기록 파일이 선택되지 않았습니다.");
    let totalLoaded = 0;
    let totalSkipped = 0;
    const fail = [];

    for (const f of files) {
      try {
        const out = await loadHrFileSingle(f);
        totalLoaded += out.loaded;
        totalSkipped += out.skipped;
      } catch (e) {
        fail.push(`${f.name}: ${e.message}`);
      }
    }

    renderWorkersTable();
    renderWorkerSelect();

    const failHtml = fail.length
      ? `<div class="msg err" style="margin-top:10px;"><b>실패 파일</b><ul>${fail.map(x => `<li>${escapeHtml(x)}</li>`).join("")}</ul></div>`
      : "";

    setMsg($("#hrMsg"), fail.length ? "warn" : "ok", `
      <div><b>인사내역 파일 불러오기 완료</b></div>
      <ul>
        <li>처리 파일: ${files.length}개</li>
        <li>로드(행 기준): ${totalLoaded}건</li>
        <li>스킵(빈 성명 등): ${totalSkipped}건</li>
      </ul>
      <div class="muted">목록 행 자동 탐색함. 임의로 서식 변경한 경우 못 읽을 수도 있음.</div>
      ${failHtml}
    `);
  }

  // ==========================
  // 근무상황 파일 로드
  // ==========================
  function parseWorkRows(rows, filename) {
    const headerIdx = findHeaderRow(rows, ["성명", "종별", "근태", "기간", "일시", "결재상태", "복무"]);
    if (headerIdx < 0) throw new Error(`[${filename}] 헤더 행을 찾지 못했습니다.`);

    const headers = rows[headerIdx].map(x => String(x||"").trim());
    const dataRows = rows.slice(headerIdx + 1).filter(r => Array.isArray(r) && r.some(x => String(x||"").trim() !== ""));

    const colName = findColumnIndex(headers, ["성명","이름"]);
    const colPid  = findColumnIndex(headers, ["개인번호","사번","인적번호","나이스개인번호"]);
    const colType = findColumnIndex(headers, ["종별","복무종별","근무상황","근태종류","근태유형","복무구분"]);
    const colReason = findColumnIndex(headers, ["사유","상세사유","용무","비고"]);
    const colApproval = findColumnIndex(headers, ["결재상태","결재상태명","결재상태(결재)","결재상태(상태)"]);

    const colStart = findColumnIndex(headers, ["시작일","시작","from","시작일자"]);
    const colEnd   = findColumnIndex(headers, ["종료일","종료","to","종료일자"]);
    const colRange = findColumnIndex(headers, ["기간","일시","기간(일시)","기간(일자)","기간일시"]);

    const colDays = findColumnIndex(headers, ["일수","일수/기간","기간(일수)","사용일수","일수(사용)"]);
    const colHours = findColumnIndex(headers, ["시간","사용시간","근무시간","사용시간(시간)"]);
    const colMins = findColumnIndex(headers, ["분","사용분","사용시간(분)"]);
    const colTime = findColumnIndex(headers, ["시간(분)","사용시간(분)"]);

    const colDurFallback = findColumnIndex(headers, ["시간및일수","시간 및 일수","시간/일수","시간및 일수","시간및일수(사용)","시간(일수)"]);

    if (colName < 0) throw new Error(`[${filename}] 성명 열을 찾지 못했습니다.`);
    if (colType < 0 && colRange < 0) throw new Error(`[${filename}] 종별/기간 열을 찾지 못했습니다.`);

    let recs = 0;
    let newWorkers = 0;
    let totalRows = dataRows.length;

    let annualCandidate = 0;
    let annualApproved = 0;
    let annualExcludedByStatus = 0;

    for (const row of dataRows) {
      const nameRaw = String(row[colName] || "").trim();
      if (!nameRaw) continue;

      let name = nameRaw;
      let pidFromName = "";
      const m = nameRaw.match(/\((K[0-9A-Za-z]+)\)/);
      if (m) pidFromName = m[1];
      name = nameRaw.replace(/\(.*?\)/g, "").trim();

      const pid = (colPid >= 0 ? String(row[colPid]||"").trim() : "") || pidFromName;
      const key = workerKeyOf(name, pid);

      if (!state.workers.has(key)) {
        addOrUpdateWorker({
          key,
          name,
          pid,
          group: "regular",
          pattern: "always",
          hireDateUTC: null,
          dailyHours: DEFAULT_DAILY_HOURS
        });
        newWorkers++;
      }

      const w = state.workers.get(key);
      const dailyMinutes = Math.round(Number(w?.dailyHours || DEFAULT_DAILY_HOURS) * 60);

      let start = null, end = null;

      if (colRange >= 0) {
        const rangeStr = String(row[colRange] || "").trim();
        const parsed = parseRangeLoose(rangeStr);
        if (parsed) { start = parsed.start; end = parsed.end; }
      }

      if ((!start || !end) && colStart >= 0 && colEnd >= 0) {
        const s = parseDateLoose(row[colStart]);
        const e = parseDateLoose(row[colEnd]);
        if (s && e) { start = s; end = e; }
      }

      if (!start && colStart >= 0) start = parseDateLoose(row[colStart]);
      if (!end && colEnd >= 0) end = parseDateLoose(row[colEnd]);
      if (start && !end) end = start;
      if (end && !start) start = end;

      if (!start || !end) continue;

      const type = (colType >= 0) ? String(row[colType] || "").trim() : "";
      const reason = (colReason >= 0) ? String(row[colReason] || "").trim() : "";

      const approvalStatus = (colApproval >= 0) ? String(row[colApproval] || "").trim() : "";

      const kind = classifyAnnualLeaveKind(type);
      if (kind) {
        annualCandidate++;
        if (isFinalApprovedStatus(approvalStatus)) annualApproved++;
        else annualExcludedByStatus++;
      }

      let minutes = null;
      let rawDur = "";

      if (colDays >= 0 && String(row[colDays]||"").trim() !== "") {
        rawDur = String(row[colDays]||"").trim();
        const p = parseDurationToMinutes(row[colDays], dailyMinutes);
        if (p != null) minutes = p;
        else {
          const d = safeNum(row[colDays], NaN);
          if (Number.isFinite(d)) minutes = Math.round(d * dailyMinutes);
        }
      }

      if (minutes == null && colTime >= 0 && String(row[colTime]||"").trim() !== "") {
        rawDur = String(row[colTime]||"").trim();
        const m2 = safeNum(row[colTime], NaN);
        if (Number.isFinite(m2)) minutes = Math.round(m2);
      }

      if (minutes == null && (colHours >= 0 || colMins >= 0)) {
        const hCell = (colHours >= 0) ? row[colHours] : "";
        const mCell = (colMins >= 0) ? row[colMins] : "";

        const p = parseDurationToMinutes(hCell, dailyMinutes);
        if (p != null) {
          rawDur = String(hCell||"").trim();
          minutes = p;
        } else {
          const h = safeNum(hCell, NaN);
          const m3 = safeNum(mCell, NaN);
          if (Number.isFinite(h) || Number.isFinite(m3)) {
            rawDur = `${Number.isFinite(h) ? h : 0}시간 ${Number.isFinite(m3) ? m3 : 0}분`;
            minutes = Math.round((Number.isFinite(h) ? h : 0) * 60 + (Number.isFinite(m3) ? m3 : 0));
          }
        }
      }

      if (minutes == null && colDurFallback >= 0 && String(row[colDurFallback]||"").trim() !== "") {
        rawDur = String(row[colDurFallback]||"").trim();
        const p = parseDurationToMinutes(row[colDurFallback], dailyMinutes);
        if (p != null) minutes = p;
      }

      addRecord({
        workerKey: key,
        startUTC: start,
        endUTC: end,
        type,
        reason,
        minutes,
        rawDur,
        approvalStatus,
        sourceFile: filename,
        credit: false
      });
      recs++;
    }

    return { recs, newWorkers, totalRows, annualCandidate, annualApproved, annualExcludedByStatus };
  }

  async function loadWorkFiles(files) {
    if (!files || files.length === 0) throw new Error("근무상황 파일이 선택되지 않았습니다.");

    let totalRecs = 0;
    let createdWorkers = 0;
    let totalRows = 0;

    let annualCandidate = 0;
    let annualApproved = 0;
    let annualExcludedByStatus = 0;

    for (const file of files) {
      const rows = await readSpreadsheetRows(file);
      const out = parseWorkRows(rows, file.name);

      totalRecs += out.recs;
      createdWorkers += out.newWorkers;
      totalRows += out.totalRows;
      annualCandidate += out.annualCandidate;
      annualApproved += out.annualApproved;
      annualExcludedByStatus += out.annualExcludedByStatus;
    }

    renderWorkersTable();
    renderWorkerSelect();

    return { totalRecs, createdWorkers, totalRows, annualCandidate, annualApproved, annualExcludedByStatus };
  }

  function pctValue(x) {
    return (x * 100).toFixed(1) + "%";
  }

  function downloadXlsx() {
    if (!state.results || state.results.length === 0) {
      alert("계산 결과가 없습니다. 먼저 계산 실행을 눌러주세요.");
      return;
    }

    const rows1 = [];
    rows1.push([
      "나이스개인번호","성명","직군","근무형태","최초임용일","근속(2026-03-01)",
      "출근율(학기중)","출근율(연간)","출근율(비례산정)",
      "기본","출근가산(비상시80%)","근속가산","표준합계(상한적용)",
      "최종부여(일)","최종부여(시간)","판정","비고"
    ]);

    for (const r of state.results) {
      const w = state.workers.get(r.workerKey);
      rows1.push([
        w?.key || r.workerKey,
        w?.name || "",
        w?.group==="special" ? "특수운영직군" : "교육공무직",
        w?.pattern==="emergency" ? "방학중비상시" : "상시",
        w?.hireDateUTC ? utcToYmd(w.hireDateUTC) : "",
        w?.serviceYears ?? 0,
        r.rates.rateSemester==null ? "" : pctValue(r.rates.rateSemester),
        pctValue(r.rates.rateFull ?? 0),
        r.rates.rateProportional==null ? "" : pctValue(r.rates.rateProportional),
        r.baseDays,
        r.bonusDays ?? 0,
        r.addDays,
        r.standardDays,
        r.finalDays,
        r.finalHours,
        r.method,
        r.note || ""
      ]);
    }

    const rows2 = [];
    rows2.push([
      "나이스개인번호","성명","기간시작","기간종료","종별","사유","결재상태",
      "자동분류","최종분류","방학중근무(비상시직종)","분(저장값)","원본시간/일수","파일"
    ]);

    for (const rec of state.records) {
      const w = state.workers.get(rec.workerKey);
      const auto = rec.autoClass || "review";
      const fin = rec.finalClass || "auto";
      rows2.push([
        rec.workerKey,
        w?.name || "",
        utcToYmd(rec.startUTC),
        utcToYmd(rec.endUTC),
        rec.type || "",
        rec.reason || "",
        rec.approvalStatus || "",
        CLASS_LABEL[auto] || auto,
        fin === "auto" ? "자동" : (CLASS_LABEL[fin] || fin),
        rec.credit ? "Y" : "",
        rec.minutes == null ? "" : rec.minutes,
        rec.rawDur || "",
        rec.sourceFile || ""
      ]);
    }

    const rows3 = [];
    rows3.push(["나이스개인번호","성명","연차사용(완결만)_분","연차사용(완결만)_표시","연차","반일연차","연차(지각)","연차(조퇴)","연차(외출)"]);

    const workersSorted = Array.from(state.workers.values()).sort((a,b) => (a.name||"").localeCompare(b.name||"", "ko"));
    for (const w of workersSorted) {
      const dailyMinutes = Math.round(Number(w.dailyHours || DEFAULT_DAILY_HOURS) * 60);
      const usage = computeAnnualLeaveUsageSummary(w.key, dailyMinutes);
      const toText = (mins) => fmtDHM(minutesToDHM(mins, dailyMinutes));

      rows3.push([
        w.key,
        w.name || "",
        usage.total,
        toText(usage.total),
        toText(usage.byKind.FULL),
        toText(usage.byKind.HALF),
        toText(usage.byKind.LATE),
        toText(usage.byKind.EARLY),
        toText(usage.byKind.OUT)
      ]);
    }

    const u8 = MiniXLSX.writeWorkbook([
      { name: "연차부여결과", rows: rows1 },
      { name: "복무취합(전체)", rows: rows2 },
      { name: "연차사용(완결만)", rows: rows3 }
    ]);

    const blob = new Blob([u8], { type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" });
    saveOrShowBase64(blob, "2026학년도_연차휴가_부여일수_계산결과.xlsx");
  }

  function runCalculation() {
    if (!state.calendar.sets) buildCalendarSets();

    const workers = Array.from(state.workers.values());
    if (workers.length === 0) {
      setMsg($("#runMsg"), "err", "대상자가 없습니다. 인사정보를 먼저 입력하세요.");
      state.results = [];
      renderResults();
      return;
    }

    const hasEmergency = workers.some(w => w.pattern === "emergency");
    if (hasEmergency && !state.calendar.applied) {
      setMsg($("#runMsg"), "warn", `
        <div class="warn-line">
          <b>경고</b>: 비상시근로자가 포함되어 있으나 학사일정이 입력되지 않았습니다.<br/>
          비상시직종의 출근율 및 방학중 추가근무로 인한 출근율 산정 정확도가 떨어질 수 있습니다.
        </div>
      `);
    } else {
      setMsg($("#runMsg"), "ok", "계산 들어갑니다.");
    }

    state.results = workers.map(w => calcGrantForWorker(w));
    state.lastRunAt = Date.now();

    renderResults();
  }

  function bindDropZone(zoneEl, inputEl, onFiles) {
    zoneEl.addEventListener("click", () => inputEl.click());

    ["dragenter","dragover"].forEach(evt => {
      zoneEl.addEventListener(evt, (e) => {
        e.preventDefault();
        e.stopPropagation();
        zoneEl.classList.add("dragover");
      });
    });

    ["dragleave","drop"].forEach(evt => {
      zoneEl.addEventListener(evt, (e) => {
        e.preventDefault();
        e.stopPropagation();
        zoneEl.classList.remove("dragover");
      });
    });

    zoneEl.addEventListener("drop", (e) => {
      const files = Array.from(e.dataTransfer.files || []);
      if (!files.length) return;
      onFiles(files);
    });

    inputEl.addEventListener("change", () => {
      const files = Array.from(inputEl.files || []);
      if (!files.length) return;
      onFiles(files);
    });
  }

  function bindEvents() {
    $("#btnApplyCalendar").addEventListener("click", () => {
      state.calendar.summerStart = $("#summerStart").value ? ymdToUTC($("#summerStart").value) : null;
      state.calendar.summerEnd   = $("#summerEnd").value ? ymdToUTC($("#summerEnd").value) : null;
      state.calendar.winterStart = $("#winterStart").value ? ymdToUTC($("#winterStart").value) : null;
      state.calendar.winterEnd   = $("#winterEnd").value ? ymdToUTC($("#winterEnd").value) : null;

      buildCalendarSets();
      state.calendar.applied = true;
      renderCalendarSummary();
    });

    $("#btnSetExampleCalendar").addEventListener("click", () => {
      $("#summerStart").value = "2025-07-21";
      $("#summerEnd").value = "2025-08-11";
      $("#winterStart").value = "2026-01-03";
      $("#winterEnd").value = "2026-02-28";
      $("#btnApplyCalendar").click();
    });

    bindDropZone($("#hrDrop"), $("#hrFile"), (files) => {
      const ok = files.filter(f => /\.(xlsx|xls|csv)$/i.test(f.name));
      state.selectedFiles.hr = ok;
      if (!ok.length) {
        setMsg($("#hrMsg"), "err", "(.xlsx/.xls/.csv) 파일만 업로드 가능합니다.");
        return;
      }
      setMsg($("#hrMsg"), "warn", `인사기록 파일 ${ok.length}개 선택됨. <b>인사 정보 반영하기</b>를 눌러주세요.`);
    });

    bindDropZone($("#workDrop"), $("#workFiles"), (files) => {
      const ok = files.filter(f => /\.(xlsx|xls|csv)$/i.test(f.name));
      state.selectedFiles.work = ok;
      if (!ok.length) {
        setMsg($("#workMsg"), "err", "(.xlsx/.xls/.csv) 파일만 업로드 가능합니다.");
        return;
      }
      setMsg($("#workMsg"), "warn", `근무상황 파일 ${ok.length}개 선택됨. <b>복무사항 불러오기</b>를 눌러주세요.`);
    });

    $$("input[name='hrMode']").forEach(r => {
      r.addEventListener("change", () => {
        const mode = $$("input[name='hrMode']").find(x => x.checked)?.value;
        $("#hrFileBox").classList.toggle("hidden", mode !== "file");
        $("#hrManualBox").classList.toggle("hidden", mode !== "manual");
      });
    });

    $$("input[name='workMode']").forEach(r => {
      r.addEventListener("change", () => {
        const mode = $$("input[name='workMode']").find(x => x.checked)?.value;
        $("#workFileBox").classList.toggle("hidden", mode !== "file");
        $("#workManualBox").classList.toggle("hidden", mode !== "manual");
      });
    });

    $("#btnLoadHr").addEventListener("click", async () => {
      const files = (state.selectedFiles.hr && state.selectedFiles.hr.length)
        ? state.selectedFiles.hr
        : Array.from($("#hrFile").files || []);

      if (!files.length) { setMsg($("#hrMsg"), "err", "인사내역 파일을 선택하세요."); return; }

      try {
        await handleLoadHrFiles(files);
      } catch (e) {
        setMsg($("#hrMsg"), "err", `<b>오류</b>: ${escapeHtml(e.message)}`);
      }
    });

    $("#btnClearHr").addEventListener("click", () => {
      state.workers.clear();
      state.records = [];
      state.results = [];
      state.selectedFiles.hr = [];
      state.selectedFiles.work = [];
      renderWorkersTable();
      renderWorkerSelect();
      renderResults();
      setMsg($("#hrMsg"), "warn", "입력내역을 초기화했습니다.");
    });

    $("#btnAddWorker").addEventListener("click", () => {
      const name = $("#mName").value.trim();
      const pid = $("#mPid").value.trim();
      const hire = $("#mHire").value ? ymdToUTC($("#mHire").value) : null;
      const group = $("#mGroup").value;
      const pattern = $("#mPattern").value;
      const dailyHours = Number($("#mDailyHours").value || DEFAULT_DAILY_HOURS);

      if (!name) { setMsg($("#hrManualMsg"), "err", "성명은 필수 입력사항입니다."); return; }
      if (!hire) { setMsg($("#hrManualMsg"), "err", "최초임용일은 필수 입력사항입니다."); return; }

      addOrUpdateWorker({
        key: workerKeyOf(name, pid),
        name, pid,
        group, pattern,
        hireDateUTC: hire,
        dailyHours
      });

      $("#mName").value = "";
      $("#mPid").value = "";

      renderWorkersTable();
      renderWorkerSelect();
      setMsg($("#hrManualMsg"), "ok", "대상자를 추가했습니다.");
    });

    $("#btnClearWorkers").addEventListener("click", () => {
      state.workers.clear();
      state.records = [];
      renderWorkersTable();
      renderWorkerSelect();
      setMsg($("#hrManualMsg"), "warn", "전체 삭제 완료");
    });

    $("#btnLoadWork").addEventListener("click", async () => {
      const files = (state.selectedFiles.work && state.selectedFiles.work.length)
        ? state.selectedFiles.work
        : Array.from($("#workFiles").files || []);

      if (!files.length) { setMsg($("#workMsg"), "err", "근무상황 파일을 선택하세요."); return; }

      try {
        const out = await loadWorkFiles(files);
        setMsg($("#workMsg"), "ok", `
          <div><b>근무상황 파일 불러오기 완료</b></div>
          <ul>
            <li>처리 파일: ${files.length}개</li>
            <li>전체 행(대략): ${out.totalRows.toLocaleString("ko-KR")}행</li>
            <li>복무사항 추출(전체): ${out.totalRecs.toLocaleString("ko-KR")}건</li>
            <li>인사정보가 없어서 임시로 생성: ${out.createdWorkers.toLocaleString("ko-KR")}명</li>
            <li><b>연차 집계 후보</b>: ${out.annualCandidate.toLocaleString("ko-KR")}건</li>
            <li><b>연차 집계(완결만)</b>: ${out.annualApproved.toLocaleString("ko-KR")}건</li>
            <li>연차 제외(결재상태 미완결): ${out.annualExcludedByStatus.toLocaleString("ko-KR")}건</li>
          </ul>
          <div class="muted">※ 임시 생성자의 직군, 근무형태, 최초임용일 등의 인사 정보는 필요시 수기 입력하십시오.</div>
        `);
      } catch (e) {
        setMsg($("#workMsg"), "err", `<b>오류</b>: ${escapeHtml(e.message)}`);
      }
    });

    $("#btnClearWork").addEventListener("click", () => {
      state.records = [];
      state.results = [];
      state.selectedFiles.work = [];
      renderResults();
      setMsg($("#workMsg"), "warn", "복무사항 초기화 완료");
    });

    $("#btnAddRecord").addEventListener("click", () => {
      const wk = $("#wSelect").value;
      if (!wk) { setMsg($("#workManualMsg"), "err", "대상자를 선택해주십시오."); return; }

      const s = $("#wStart").value ? ymdToUTC($("#wStart").value) : null;
      const e = $("#wEnd").value ? ymdToUTC($("#wEnd").value) : null;
      if (!s || !e) { setMsg($("#workManualMsg"), "err", "시작일자와 종료일자는 필수 입력사항입니다."); return; }

      const type = $("#wType").value.trim();
      const reason = $("#wReason").value.trim();
      const clsMode = $("#wClass").value;
      const credit = $("#wCredit").checked;

      try {
        addRecord({
          workerKey: wk,
          startUTC: s,
          endUTC: e,
          type,
          reason,
          finalClass: clsMode === "auto" ? null : clsMode,
          credit,
          approvalStatus: "",
          rawDur: "",
          sourceFile: "수기입력"
        });
        setMsg($("#workManualMsg"), "ok", "복무 항목을 추가했습니다.");
        $("#wType").value = "";
        $("#wReason").value = "";
      } catch (err) {
        setMsg($("#workManualMsg"), "err", `<b>오류</b>: ${escapeHtml(err.message)}`);
      }
    });

    $("#btnClearManualRecords").addEventListener("click", () => {
      state.records = [];
      setMsg($("#workManualMsg"), "warn", "전체 삭제 완료");
    });

    $("#btnRun").addEventListener("click", runCalculation);

    $("#btnDownload").addEventListener("click", () => {
      try { downloadXlsx(); } catch (e) { alert(e.message); }
    });

    $("#btnScrollTop").addEventListener("click", (e) => {
      e.preventDefault();
      window.scrollTo({ top: 0, behavior: "smooth" });
    });

    // Base64 모달 이벤트
    $("#b64Backdrop").addEventListener("click", closeB64Modal);
    $("#btnCloseB64").addEventListener("click", closeB64Modal);

    $("#btnCopyB64").addEventListener("click", async () => {
      const txt = $("#b64Text").value || "";
      try {
        await navigator.clipboard.writeText(txt);
        alert("복사 완료");
      } catch (e) {
        // clipboard 차단이면 선택이라도 해줌
        const ta = $("#b64Text");
        ta.focus();
        ta.select();
        alert("클립보드 권한이 없어 선택만 했습니다. Ctrl+C로 복사하세요.");
      }
    });

    $("#btnDownloadB64").addEventListener("click", async () => {
      const b64 = $("#b64Text").value || "";
      const blob = new Blob([b64], { type: "text/plain" });
      await saveBlobSmart(blob, "out.b64");
    });
  }

  function init() {
    setMsg($("#hrMsg"), "", "인사정보를 입력해주세요.");
    setMsg($("#workMsg"), "", "근무상황을 입력해주세요.");
    setMsg($("#runMsg"), "", "인사 및 복무사항 입력 후 계산 버튼을 눌러주세요.");

    buildCalendarSets();
    renderCalendarSummary();
    renderWorkerSelect();
    bindEvents();
    renderWorkersTable();
    renderResults();

    // XLSX 업로드 지원 여부 안내
    if (!("DecompressionStream" in window)) {
      setMsg($("#hrMsg"), "warn", `
        <div class="warn-line">
          이게 작동할지 안 할지 저도 잘 모르겠
        </div>
      `);
    }
  }

  init();
})();
</script>

</body>
</html>
