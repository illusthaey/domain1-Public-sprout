<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>[세입] 미납 금쪽 학부모 문자 독촉 업무 경감 기능</title>

  <link rel="stylesheet" href="/static/style.css" />

  <style>
    /* 파일 input: display:none 대신 "시각적으로만 숨김" */
    #excelFile{
      position:absolute;
      width:1px;
      height:1px;
      padding:0;
      margin:-1px;
      overflow:hidden;
      clip: rect(0, 0, 0, 0);
      clip-path: inset(50%);
      white-space:nowrap;
      border:0;
    }

    .dropzone{
      border: 2px dashed #d4d4d8;
      background: #fafafa;
      border-radius: 12px;
      padding: 14px 16px;
      cursor: pointer;
      transition: background .12s ease, border-color .12s ease, transform .08s ease;
      display:block;
      user-select:none;
    }
    .dropzone:hover{ background:#f9fafb; }
    .dropzone:active{ transform: scale(0.998); }
    .dropzone.is-dragover{
      border-color: #6b7280;
      background: #eef2ff;
    }
    .dropzone .dz-title{
      font-weight: 700;
      color: #111;
      margin: 0 0 6px;
      font-size: 1.02rem;
    }
    .dropzone .dz-sub{
      margin: 0;
      color: #555;
      font-size: 0.95rem;
    }
    .dropzone .dz-sub code{
      background:#fff;
      border:1px solid #e5e7eb;
      padding: 2px 6px;
      border-radius: 8px;
      font-size: 0.92rem;
    }
    .dropzone .dz-file{
      margin: 10px 0 0;
      font-size: 0.95rem;
      color: #111;
      background:#fff;
      border:1px solid #e5e7eb;
      border-radius: 10px;
      padding: 8px 10px;
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .btnbar{
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
      margin-top: 10px;
    }

    .status-box{
      font-size: 1rem;
      color: #333;
    }
    .status-ok{
      border-color: #bbf7d0 !important;
      background: #f0fdf4 !important;
    }
    .status-err{
      border-color: #fecaca !important;
      background: #fff1f2 !important;
    }
    .status-warn{
      border-color: #fde68a !important;
      background: #fffbeb !important;
    }

    /* 라이브러리 진행바 */
    .lib-progress-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      font-weight: 700;
      margin-bottom: 6px;
    }
    #libProgressBar{
      width: 100%;
      height: 14px;
    }
    .lib-progress-detail{
      margin-top: 8px;
      font-size: 0.92rem;
      color: #555;
      white-space: pre-line;
    }
    .status-text{
      margin-top: 10px;
      white-space: pre-line;
    }

    textarea{
      width: 100%;
      max-width: 100%;
      resize: vertical;
      overflow-y: auto;
    }
    #smsTemplate{ min-height: 320px; }
    #smsPreview{ min-height: 360px; }

    .canvasbox{
      border: 1px solid #e5e5e5;
      border-radius: 12px;
      background: #fff;
      padding: 12px;
    }
    canvas{
      width: 100%;
      height: auto;
      display:block;
      border-radius: 10px;
      background: #fff;
      border: 1px solid #e5e5e5;
    }

    .preview-grid{
      display:grid;
      gap: 12px;
      grid-template-columns: 1fr;
    }
    @media (min-width: 900px){
      .preview-grid{
        grid-template-columns: 1fr 1fr;
        align-items: start;
      }
    }

    .home-link-wrap{
      background:#fff;
      max-width: 880px;
      margin: 16px auto 0;
      padding: 0 16px 10px;
      display:flex;
      justify-content:flex-start;
      gap: 8px;
      flex-wrap: wrap;
    }
  </style>
</head>

<body>
  <main class="container">
    <h1>미수납자 독촉 문자 문구 및 미납 안내장 파일 생성기</h1>
    <p class="muted">
      ·에듀파인 학교회계-수입관리-출납관리-미수납관리에서 미수납대상 엑셀파일 다운로드 <br/>
      ·학생별 독촉 문자 문구 및 미납 안내장 PNG 파일을 일괄 생성해줌. <br/>
      ※서버/DB 없이 로컬 브라우저에서만 처리됩니다(학생 데이터는 서버로 전송되지 않음). <br/>
      ※편의를 위해 “징수정보/문구” 입력값은 이 브라우저에만 저장될 수 있으며, “초기화”로 모두 삭제됩니다.
    </p>

    <!-- 1) 업로드 -->
    <section class="section">
      <div class="row between">
        <h2 class="local-h2 local-tight" style="margin:0;">1. 미수납 대상 정보 업로드</h2>
      </div>

      <p class="muted local-tight">
        ·학년, 반, 번호, 이름, 미납 내역, 미납 금액 데이터만 추출함.
      </p>

      <input id="excelFile" type="file" accept=".xlsx,.xls" />

      <label id="dropZone" class="dropzone" for="excelFile" role="button" tabindex="0" aria-label="엑셀 파일 드롭존">
        <p class="dz-title">엑셀 파일을 드래그해서 놓기</p>
        <p class="dz-sub">또는 여기를 클릭하면 파일 선택창 열림. <code>.xlsx</code></p>
        <p class="dz-file" id="selectedFileName">선택된 파일 없음</p>
      </label>

      <div class="btnbar">
        <button class="btn primary" id="btnExtract" type="button" disabled>미납내역 추출하기</button>
        <button class="btn" id="btnReset" type="button">초기화</button>
      </div>

      <div id="statusBox" class="card status-box" style="margin-top:12px;">
        <div id="libProgressWrap">
          <div class="lib-progress-head">
            <span id="libProgressLabel">필수 라이브러리 로딩: 0/3</span>
            <span id="libProgressPercent">0%</span>
          </div>
          <progress id="libProgressBar" max="3" value="0" aria-label="라이브러리 로딩 진행률"></progress>
          <div id="libProgressDetail" class="muted lib-progress-detail">-</div>
        </div>
        <div id="statusText" class="status-text">
          기다리는 중. 엑셀 파일을 올리고 나서 추출하기를 누르십시오.
        </div>
      </div>
    </section>

    <!-- 2) 설정 -->
    <section class="section">
      <div class="row between">
        <h2 class="local-h2 local-tight" style="margin:0;">2. 징수 정보 입력</h2>
      </div>

      <div class="grid two">
        <div class="field">
          <label>학교명</label>
          <input id="schoolName" type="text" placeholder="예시: 금쪽부모 초등학교" />
        </div>
        <div class="field">
          <label>부과년월 (선택)</label>
          <input id="roundText" type="text" placeholder="예시: 2025년 2학기" />
        </div>
      </div>

      <div class="grid two">
        <div class="field">
          <label>은행명</label>
          <input id="bankName" type="text" placeholder="예: 농협" />
        </div>
        <div class="field">
          <label>학교 계좌번호</label>
          <input id="accountNumber" type="text" placeholder="예시: 123456-78-901234" />
        </div>
      </div>

      <div class="grid two">
        <div class="field">
          <label>이체 기한</label>
          <input id="dueDate" type="date" />
        </div>
        <div class="field">
          <label>미납안내서 발송 일자</label>
          <input id="docDate" type="date" />
        </div>
      </div>

      <p class="note" style="margin-top:10px;">
        ※입력값 변경 시 미반영 방지를 위해 “추출한 미납자 정보 반영하기” 버튼을 다시 눌러야 다운로드 버튼이 활성화됩니다.
      </p>
    </section>

    <!-- 3) 추출 결과 -->
    <section class="section">
      <h2 class="local-h2 local-tight">3. 추출 내역 상세 조회</h2>

      <h3 class="local-h3 local-tight">미납 건별 조회하기</h3>
      <div class="table-wrap">
        <table class="sheetlike">
          <thead>
            <tr>
              <th>학년</th>
              <th>반</th>
              <th>번호</th>
              <th>이름</th>
              <th>납입금명</th>
              <th>납입차수</th>
              <th class="numeric">미납액</th>
            </tr>
          </thead>
          <tbody id="rawTbody">
            <tr><td colspan="7" class="muted">파일부터 올리쇼</td></tr>
          </tbody>
        </table>
      </div>

      <h3 class="local-h3 local-tight" style="margin-top:18px;">학생별 미납액 조회하기</h3>
      <div class="table-wrap">
        <table class="sheetlike">
          <thead>
            <tr>
              <th>학년</th>
              <th>반</th>
              <th>번호</th>
              <th>이름</th>
              <th>납입차수</th>
              <th>납입금명</th>
              <th class="numeric">총 미납액</th>
            </tr>
          </thead>
          <tbody id="caseTbody">
            <tr><td colspan="7" class="muted">아직 데이터가 없습니다.</td></tr>
          </tbody>
        </table>
      </div>
    </section>

    <!-- 4) 문자 템플릿 -->
    <section class="section">
      <h2 class="local-h2 local-tight">4. 납부 안내 문구 설정</h2>
      <p class="muted">
        치환: [학교명] [학년] [반] [번호] [이름] [차수] [납입금명] [은행명] [계좌번호] [미납액]
      </p>

      <textarea id="smsTemplate"></textarea>

      <div class="btnbar">
        <button class="btn" id="btnApply" type="button" disabled>
          추출한 미납자 정보 반영하기
        </button>
      </div>
    </section>

    <!-- 5) 다운로드 + 미리보기 -->
    <section class="section">
      <h2 class="local-h2 local-tight">5. 파일 다운로드</h2>

      <div class="btnbar">
        <button class="btn primary" id="btnDownloadAllZip" type="button" disabled>
          압축 파일로 전체 다운로드
        </button>

        <button class="btn" id="btnCopyAllSms" type="button" disabled>
          전체 학생 미납 안내 문구 복사하기
        </button>
      </div>

      <details class="shot-details" style="margin-top:12px;">
        <summary class="shot-summary">개별 다운로드 (선택)</summary>
        <div class="btnbar">
          <button class="btn" id="btnDownloadXlsxOnly" type="button" disabled>문구 엑셀만 다운로드</button>
          <button class="btn" id="btnDownloadPngZipOnly" type="button" disabled>안내문 PNG ZIP만 다운로드</button>
          <button class="btn" id="btnDownloadPdfOnly" type="button" disabled>안내문 PDF만 다운로드</button>
        </div>
      </details>

      <div class="grid two">
        <div class="field">
          <label>학생 선택</label>
          <select id="caseSelect" disabled>
            <option value="">먼저 엑셀을 업로드하고 추출하세요</option>
          </select>
        </div>
        <div class="field">
          <label>선택 학생 작업</label>
          <div class="btnbar">
            <button class="btn" id="btnOnePng" type="button" disabled>안내문 PNG 1장</button>
            <button class="btn" id="btnCopySms" type="button" disabled>문자 복사</button>
          </div>
        </div>
      </div>

      <div class="preview-grid" style="margin-top:12px;">
        <div class="canvasbox">
          <canvas id="previewCanvas" width="1080" height="1350"></canvas>
          <p class="note">엑셀에서 추출된 값이 그대로 안내문에 반영됩니다.</p>
        </div>

        <div class="card">
          <h3 class="local-h3 local-tight">선택한 학생 정보로 문구 생성</h3>
          <textarea id="smsPreview" readonly></textarea>
          <p class="note">저장해서 문자 보내삼.</p>
        </div>
      </div>
    </section>

  </main>

  <div class="home-link-wrap">
    <a class="btn" href="/">메인으로 돌아가기</a>
  </div>

  <script>
    /***********************
     * 공통
     ***********************/
    const STORAGE_KEY = "eduFine_unpaid_notice_badparents_v4";
    const EXPORT_SCALE = 2;
    const LABEL_BG = "#BFBFBF";
    const TABLE_SLOTS = 10;

    const LAYOUT = {
      baseW: 1080,
      baseH: 1350,
      boxMargin: 86,
      boxBottomMargin: 78,
      titleTop: 38,
      boxTopGap: 28,
      outerLine: 2.2,
      innerLine: 1.1,
      topRowH: 62,
      moneyRowH: 56,
      headH: 56,
      rowH: 56,
      sumH: 56,
      col1Ratio: 0.44,
      col2Ratio: 0.28,
      titleSize: 52,
      titleSpacing: 12,
      labelSize: 28,
      valueSize: 28,
      tableSize: 26,
      dateSize: 26,
      labelWRatio: 0.34
    };

    const DEFAULT_SMS_TEMPLATE =
`안녕하세요,
[학교명] 행정실입니다.

[학년] [반] [번호] [이름] 학생 [차수] [납입금명] 미납 금액 이체 안내드립니다.

이체하실 계좌: [은행명] [계좌번호] [학교명]
이체하실 금액: [미납액]

원활한 업무처리를 위하여 반드시 학생 이름으로 이체 부탁드립니다.

감사합니다.`;

    const el = (id) => document.getElementById(id);

    function toISODate(d){
      const y = d.getFullYear();
      const m = String(d.getMonth()+1).padStart(2,"0");
      const day = String(d.getDate()).padStart(2,"0");
      return `${y}-${m}-${day}`;
    }
    function parseDateInput(value){
      if(!value) return null;
      const [y,m,d] = value.split("-").map(Number);
      if(!y || !m || !d) return null;
      return new Date(y, m-1, d);
    }
    function fmtKoreanDate(d, pad=false){
      if(!d) return "";
      const y = d.getFullYear();
      const m = d.getMonth()+1;
      const day = d.getDate();
      if(pad){
        return `${y}년 ${String(m).padStart(2,"0")}월 ${String(day).padStart(2,"0")}일`;
      }
      return `${y}년 ${m}월 ${day}일`;
    }

    function setStatus(msg, kind=""){
      const box = el("statusBox");
      box.classList.remove("status-ok","status-err","status-warn");
      if(kind === "ok") box.classList.add("status-ok");
      if(kind === "err") box.classList.add("status-err");
      if(kind === "warn") box.classList.add("status-warn");

      const t = el("statusText");
      if(t) t.textContent = msg;
      else box.textContent = msg;
    }

    function disableWhile(btn, on=true, text="처리중…"){
      if(!btn) return;
      if(on){
        btn.dataset._oldText = btn.textContent;
        btn.dataset._oldDisabled = String(btn.disabled);
        btn.disabled = true;
        btn.textContent = text;
      }else{
        const oldDisabled = (btn.dataset._oldDisabled === "true");
        btn.disabled = oldDisabled;
        if(btn.dataset._oldText) btn.textContent = btn.dataset._oldText;
        delete btn.dataset._oldText;
        delete btn.dataset._oldDisabled;
      }
    }

    /***********************
     * 라이브러리 로딩 진행바 + fallback 로더
     ***********************/
    const LIB_SPECS = [
      {
        key: "xlsx",
        label: "XLSX (엑셀 파서)",
        urls: [
          "/static/vendor/xlsx.full.min.js",
          "https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js",
          "https://unpkg.com/xlsx@0.18.5/dist/xlsx.full.min.js",
          "https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"
        ],
        check: () => !!window.XLSX
      },
      {
        key: "jszip",
        label: "JSZip (ZIP 생성)",
        urls: [
          "/static/vendor/jszip.min.js",
          "https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js",
          "https://unpkg.com/jszip@3.10.1/dist/jszip.min.js",
          "https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"
        ],
        check: () => !!window.JSZip
      },
      {
        key: "jspdf",
        label: "jsPDF (PDF 생성)",
        urls: [
          "/static/vendor/jspdf.umd.min.js",
          "https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js",
          "https://unpkg.com/jspdf@2.5.1/dist/jspdf.umd.min.js",
          "https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"
        ],
        check: () => !!(window.jspdf && window.jspdf.jsPDF)
      }
    ];

    const libState = {
      total: LIB_SPECS.length,
      items: Object.fromEntries(LIB_SPECS.map(s => [s.key, { status: "pending", usedUrl: "", source: "", error: "" }]))
    };

    function libSourceFromUrl(url){
      if(!url) return "";
      if(url.startsWith("/")) return "local";
      if(url.includes("jsdelivr.net")) return "jsDelivr";
      if(url.includes("unpkg.com")) return "unpkg";
      if(url.includes("cdnjs.cloudflare.com")) return "cdnjs";
      return "custom";
    }

    function isLibOk(key){
      const it = libState.items[key];
      return it && it.status === "ok";
    }

    function renderLibProgress(){
      const bar = el("libProgressBar");
      const label = el("libProgressLabel");
      const percent = el("libProgressPercent");
      const detail = el("libProgressDetail");
      if(!bar || !label || !percent || !detail) return;

      const items = Object.values(libState.items);
      const okCount = items.filter(x => x.status === "ok").length;
      const errCount = items.filter(x => x.status === "err").length;
      const doneCount = items.filter(x => x.status === "ok" || x.status === "err").length;

      bar.max = libState.total;
      bar.value = doneCount;

      const pct = Math.round((doneCount / libState.total) * 100);
      percent.textContent = `${pct}%`;
      label.textContent = `필수 라이브러리 로딩: ${doneCount}/${libState.total} (성공 ${okCount}, 실패 ${errCount})`;

      const map = { pending: "대기", loading: "로딩중…", ok: "완료", err: "실패" };
      const lines = LIB_SPECS.map(s => {
        const it = libState.items[s.key];
        const st = map[it.status] || it.status;
        const src = it.source ? ` (${it.source})` : "";
        const err = it.status === "err" && it.error ? ` — ${it.error}` : "";
        return `- ${s.label}: ${st}${src}${err}`;
      });
      detail.textContent = lines.join("\n");
    }

    function setLibStatus(key, status, meta={}){
      const it = libState.items[key];
      if(!it) return;
      it.status = status;
      if(meta.usedUrl !== undefined) it.usedUrl = meta.usedUrl;
      if(meta.source !== undefined) it.source = meta.source;
      if(meta.error !== undefined) it.error = meta.error;

      renderLibProgress();
      updateUIStates();
    }

    function loadScript(url, timeoutMs=20000){
      return new Promise((resolve, reject) => {
        const s = document.createElement("script");
        s.src = url;
        s.async = true;
        s.crossOrigin = "anonymous";

        let done = false;
        const t = setTimeout(() => {
          if(done) return;
          done = true;
          s.remove();
          reject(new Error("timeout"));
        }, timeoutMs);

        s.onload = () => {
          if(done) return;
          done = true;
          clearTimeout(t);
          resolve(url);
        };
        s.onerror = () => {
          if(done) return;
          done = true;
          clearTimeout(t);
          s.remove();
          reject(new Error("loaderror"));
        };

        document.head.appendChild(s);
      });
    }

    async function loadOneLib(spec){
      if(spec.check()){
        setLibStatus(spec.key, "ok", { usedUrl: "(이미 로드됨)", source: "cached", error: "" });
        return;
      }

      setLibStatus(spec.key, "loading", { usedUrl: "", source: "", error: "" });

      let lastErr = "";
      for(const url of spec.urls){
        try{
          await loadScript(url);
          if(spec.check()){
            setLibStatus(spec.key, "ok", { usedUrl: url, source: libSourceFromUrl(url), error: "" });
            return;
          }
          lastErr = "로드는 됐지만 전역 객체 확인 실패";
        }catch(err){
          lastErr = String(err?.message || err);
        }
      }

      setLibStatus(spec.key, "err", {
        usedUrl: "",
        source: "",
        error: `네트워크/CSP/CDN 차단 등으로 로드 실패 (${lastErr || "unknown"})`
      });
    }

    async function startLibraryLoad(){
      renderLibProgress();

      for(const spec of LIB_SPECS){
        await loadOneLib(spec);
      }

      if(!isLibOk("xlsx")){
        setStatus(
          "필수 라이브러리(XLSX)를 불러오지 못해 엑셀 추출이 비활성화되었습니다.\n" +
          "- 사내/학교망에서 CDN(jsDelivr/unpkg/cdnjs)이 차단된 경우가 많습니다.\n" +
          "- 해결(권장): xlsx.full.min.js를 로컬(/static/vendor)에 내려받아 두고 로드하세요.\n" +
          "  (이 파일은 위 로더가 자동으로 먼저 시도합니다.)",
          "err"
        );
      }else{
        const missing = [];
        if(!isLibOk("jszip")) missing.push("JSZip(압축)");
        if(!isLibOk("jspdf")) missing.push("jsPDF(PDF)");
        if(missing.length){
          setStatus(
            "엑셀 추출용 라이브러리(XLSX)는 준비되었습니다.\n" +
            `하지만 ${missing.join(", ")} 로드가 실패하여 일부 다운로드 기능이 비활성화될 수 있습니다.`,
            "warn"
          );
        }
      }

      updateUIStates();
    }

    /***********************
     * 설정 저장/로드 (로컬)
     ***********************/
    function collectSettings(){
      return {
        schoolName: (el("schoolName").value || "").trim(),
        roundText: (el("roundText").value || "").trim(),
        bankName: (el("bankName").value || "").trim(),
        accountNumber: (el("accountNumber").value || "").trim(),
        dueDate: el("dueDate").value || "",
        docDate: el("docDate").value || "",
        smsTemplate: el("smsTemplate").value || ""
      };
    }

    function saveSettings(){
      try{
        localStorage.setItem(STORAGE_KEY, JSON.stringify(collectSettings()));
      }catch(_){}
    }

    function loadSettings(){
      try{
        const raw = localStorage.getItem(STORAGE_KEY);
        if(!raw) return false;
        const s = JSON.parse(raw);

        if(typeof s.schoolName === "string") el("schoolName").value = s.schoolName;
        if(typeof s.roundText === "string") el("roundText").value = s.roundText;
        if(typeof s.bankName === "string") el("bankName").value = s.bankName;
        if(typeof s.accountNumber === "string") el("accountNumber").value = s.accountNumber;
        if(typeof s.dueDate === "string") el("dueDate").value = s.dueDate;
        if(typeof s.docDate === "string") el("docDate").value = s.docDate;
        if(typeof s.smsTemplate === "string") el("smsTemplate").value = s.smsTemplate;

        return true;
      }catch(_){
        return false;
      }
    }

    /***********************
     * 상태 데이터
     ***********************/
    let pendingFile = null;
    let rawRows = [];
    let cases = [];
    let selectedCaseKey = "";
    let appliedSettings = null;

    /***********************
     * 유틸
     ***********************/
    function toIntMoney(v){
      if(v === null || v === undefined || v === "") return 0;
      const n = Number(v);
      if(Number.isFinite(n)) return Math.round(n);
      const s = String(v).replace(/,/g,"").trim();
      const nn = Number(s);
      return Number.isFinite(nn) ? Math.round(nn) : 0;
    }

    function cleanSchoolToken(s){
      let out = String(s ?? "")
        .replace(/주간/g, "")
        .replace(/야간/g, "")
        .replace(/[_-]/g, "")
        .replace(/\s+/g, " ")
        .trim();
      out = out.replace(/\b\d+\s*번\b/g, "").replace(/\s+/g," ").trim();
      return out;
    }

    function normalizeGradeClass(gradeIn, classIn){
      let g = cleanSchoolToken(gradeIn);
      let c = cleanSchoolToken(classIn);

      const gHas = /(\d+)\s*학년/.test(g);
      const cHas = /(\d+)\s*학년/.test(c);
      if(!gHas && cHas){
        const tmp = g; g = c; c = tmp;
      }

      const m = g.match(/(\d+)\s*학년/);
      if(m){
        const gradePart = `${m[1]}학년`;
        let rest = g.replace(m[0], "").trim().replace(/\s+/g," ");
        g = gradePart;
        if(rest){
          if(!c) c = rest;
          else if(!c.includes(rest)) c = `${rest} ${c}`.trim();
        }
      }
      return { 학년: g, 반: c };
    }

    function parseStudentNo(v){
      const s = String(v ?? "").trim();
      const m = s.match(/(\d{1,3})/);
      return m ? Number(m[1]) : null;
    }

    function normalizeSpacesPerLine(text){
      return String(text ?? "")
        .split("\n")
        .map(line => line.replace(/[ \t]+/g, " ").replace(/\s+$/g,""))
        .join("\n")
        .trim();
    }

    function escapeHtml(s){
      return String(s ?? "")
        .replace(/&/g,"&amp;")
        .replace(/</g,"&lt;")
        .replace(/>/g,"&gt;")
        .replace(/"/g,"&quot;")
        .replace(/'/g,"&#39;");
    }

    function markNotApplied(reasonText){
      if(appliedSettings !== null){
        appliedSettings = null;
        updateUIStates();
        if(reasonText){
          setStatus(
            reasonText + "\n\n※ “추출한 미납자 정보 반영하기” 버튼을 다시 눌러야 다운로드가 활성화됩니다.",
            "warn"
          );
        }
      }
    }

    function updateUIStates(){
      const hasFile = !!pendingFile;
      const hasCases = cases.length > 0;
      const isApplied = (appliedSettings !== null);

      const xlsxOk = isLibOk("xlsx");
      const zipOk  = isLibOk("jszip");
      const pdfOk  = isLibOk("jspdf");

      el("btnExtract").disabled = !hasFile || !xlsxOk;

      el("btnApply").disabled = !hasCases;

      el("caseSelect").disabled = !hasCases;
      el("btnOnePng").disabled = !hasCases;
      el("btnCopySms").disabled = !hasCases;

      const dlBase = hasCases && isApplied;

      el("btnCopyAllSms").disabled = !dlBase;
      el("btnDownloadXlsxOnly").disabled   = !(dlBase && xlsxOk);
      el("btnDownloadPngZipOnly").disabled = !(dlBase && zipOk);
      el("btnDownloadPdfOnly").disabled    = !(dlBase && pdfOk);

      // 전체 ZIP: XLSX+JSZip만 있으면 가능 (PDF는 있으면 포함, 없으면 제외)
      el("btnDownloadAllZip").disabled     = !(dlBase && xlsxOk && zipOk);
    }

    function clearResultsOnly(){
      rawRows = [];
      cases = [];
      selectedCaseKey = "";
      appliedSettings = null;

      renderAll();

      el("smsPreview").value = "";
      const canvas = el("previewCanvas");
      canvas.getContext("2d").clearRect(0,0,canvas.width,canvas.height);
    }

    function setPendingFile(file){
      pendingFile = file || null;
      el("selectedFileName").textContent = pendingFile ? pendingFile.name : "선택된 파일 없음";

      clearResultsOnly();
      updateUIStates();

      if(pendingFile){
        setStatus(
          `파일 선택됨\n- ${pendingFile.name}\n\n이제 “미납내역 추출하기”를 누르십시오.`,
          ""
        );
      }else{
        setStatus("기다리는 중. 엑셀 파일을 올리고 나서 추출하기를 누르십시오.", "");
      }
    }

    /***********************
     * ✅ 전체 초기화 (파일/추출결과/입력값/로컬저장까지)
     ***********************/
    function resetAll(){
      // 1) 로컬 저장 삭제
      try{ localStorage.removeItem(STORAGE_KEY); }catch(_){}

      // 2) 입력값 초기화
      el("schoolName").value = "";
      el("roundText").value = "";
      el("bankName").value = "";
      el("accountNumber").value = "";
      el("dueDate").value = "";
      el("docDate").value = toISODate(new Date());
      el("smsTemplate").value = DEFAULT_SMS_TEMPLATE;

      // 3) 파일/데이터 초기화
      try{ el("excelFile").value = ""; }catch(_){}
      pendingFile = null;
      rawRows = [];
      cases = [];
      selectedCaseKey = "";
      appliedSettings = null;

      // 4) UI 초기화
      el("selectedFileName").textContent = "선택된 파일 없음";

      renderAll();
      updateUIStates();

      setStatus("초기화 완료. 엑셀 파일을 다시 올려주세요.", "ok");
    }

    /***********************
     * XLSX 파싱
     ***********************/
    function normalizeHeader(h){
      return String(h ?? "").trim().replace(/\s+/g,"").replace(/[_-]/g,"_");
    }

    function findHeaderRow(rows){
      const limit = Math.min(rows.length, 50);
      for(let i=0;i<limit;i++){
        const row = (rows[i] || []).map(normalizeHeader);

        const hasName = row.some(x => /(이름|성명|학생명)/.test(x));
        const hasItem = row.some(x => /(납입금명|납입항목|항목명|부과.*명|납입금(?!액))/i.test(x));
        const hasAmt  = row.some(x => /(미납|미수납)/.test(x));

        if(hasName && hasItem && hasAmt) return i;
      }
      return 0;
    }

    function pickIndexSmart(headersNorm, candidates){
      for(const cand of candidates){
        const inc = cand.include || [];
        const exc = cand.exclude || [];
        const idx = headersNorm.findIndex(h =>
          inc.some(re => re.test(h)) && !exc.some(re => re.test(h))
        );
        if(idx !== -1) return idx;
      }
      return -1;
    }

    function parseXlsx(arrayBuffer){
      if(!window.XLSX) throw new Error("XLSX 라이브러리가 로드되지 않았습니다.");

      const wb = XLSX.read(arrayBuffer, { type: "array" });
      const sheetName = wb.SheetNames[0];
      const sheet = wb.Sheets[sheetName];
      const rows = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: "" });
      if(!rows || rows.length === 0) throw new Error("시트에 데이터가 없습니다.");

      const headerRowIdx = findHeaderRow(rows);
      const headerRaw = (rows[headerRowIdx] || []).map(v => String(v ?? "").trim());
      const headerNorm = headerRaw.map(normalizeHeader);

      const idxGrade = pickIndexSmart(headerNorm, [
        { include: [/주야.*학년/i, /계열.*학년/i, /^학년$/i, /학년/i] },
      ]);
      const idxClass = pickIndexSmart(headerNorm, [
        { include: [/학과.*반/i, /^반$/i, /반/i], exclude: [/방법/i, /구분/i] },
      ]);
      const idxNo = pickIndexSmart(headerNorm, [
        { include: [/^번호$/i, /^출석번호$/i, /^학생번호$/i, /^학번$/i] },
        { include: [/출석번호/i, /학생번호/i, /학번/i, /번호/i], exclude: [/계좌/i, /통장/i, /가상/i, /연락/i, /전화/i, /휴대/i, /결재/i] },
      ]);
      const idxName = pickIndexSmart(headerNorm, [
        { include: [/^이름$/i, /^성명$/i, /^학생명$/i] },
        { include: [/학생.*이름/i, /학생명/i, /이름/i, /성명/i], exclude: [/보호자/i, /학부모/i, /담당/i, /결재/i] },
      ]);
      const idxItem = pickIndexSmart(headerNorm, [
        { include: [/^납입금명$/i] },
        { include: [/납입.*명/i, /납입항목/i, /부과.*명/i, /항목명/i, /납입금(?!액)/i], exclude: [/계좌/i, /은행/i] },
      ]);
      const idxAmt = pickIndexSmart(headerNorm, [
        { include: [/^미납액$/i, /^미수납액$/i] },
        { include: [/미납.*액/i, /미수납.*액/i, /미납.*금/i, /미수납.*금/i, /미납/i, /미수납/i], exclude: [/일수/i] },
      ]);

      const idxTerm = pickIndexSmart(headerNorm, [
        { include: [/^차수$/i, /차수/i] },
        { include: [/학기/i, /년도학기/i, /학년도/i, /부과년월/i], exclude: [/미사용/i] },
        { include: [/부과기간/i, /적용기간/i, /부과.*기간/i] },
        { include: [/비고/i], exclude: [/결재/i] },
      ]);

      if([idxGrade, idxClass, idxNo, idxName, idxItem, idxAmt].some(x => x === -1)){
        throw new Error(
          "필수 컬럼을 찾지 못했습니다.\n" +
          "필요: 학년/반/번호/이름/납입금명/미납액\n" +
          "※ 엑셀 헤더명이 특이하면 헤더 줄(열 제목)을 확인해주세요."
        );
      }

      const out = [];
      for(let r=headerRowIdx+1; r<rows.length; r++){
        const row = rows[r] || [];
        const norm = normalizeGradeClass(row[idxGrade], row[idxClass]);
        const no = parseStudentNo(row[idxNo]);
        const name = String(row[idxName] ?? "").trim();
        const item = String(row[idxItem] ?? "").trim();
        const amt  = toIntMoney(row[idxAmt]);

        let term = "";
        if(idxTerm !== -1){
          term = String(row[idxTerm] ?? "")
            .replace(/[_-]/g, " ")
            .replace(/\s+/g, " ")
            .trim();
        }

        if(!name || !item) continue;
        out.push({ 학년: norm.학년, 반: norm.반, 번호: no, 이름: name, 납입금명: item, 차수: term, 미납액: amt });
      }

      const meta = {
        sheetName,
        headerRowIdx,
        matchedHeaders: {
          학년: headerRaw[idxGrade] || `(col ${idxGrade+1})`,
          반: headerRaw[idxClass] || `(col ${idxClass+1})`,
          번호: headerRaw[idxNo] || `(col ${idxNo+1})`,
          이름: headerRaw[idxName] || `(col ${idxName+1})`,
          납입금명: headerRaw[idxItem] || `(col ${idxItem+1})`,
          미납액: headerRaw[idxAmt] || `(col ${idxAmt+1})`,
          차수: (idxTerm !== -1) ? (headerRaw[idxTerm] || `(col ${idxTerm+1})`) : "(없음 → 부과년월(입력 선택) 사용)"
        }
      };

      return { rows: out, meta };
    }

    function buildCasesFromRaw(rows){
      const map = new Map();
      for(const rr of rows){
        const key = `${rr.학년}||${rr.반}||${rr.번호 ?? ""}||${rr.이름}`;
        if(!map.has(key)){
          map.set(key, { key, 학년: rr.학년, 반: rr.반, 번호: rr.번호, 이름: rr.이름, items: [], total: 0 });
        }
        const c = map.get(key);
        c.items.push({ 납입금명: rr.납입금명, 미납액: rr.미납액, 차수: rr.차수 || "" });
        c.total += rr.미납액;
      }

      const list = Array.from(map.values());

      for(const c of list){
        const uniqItems = [];
        const seenItem = new Set();
        for(const it of c.items){
          if(!seenItem.has(it.납입금명)){
            seenItem.add(it.납입금명);
            uniqItems.push(it.납입금명);
          }
        }
        c.납입금명요약 = uniqItems.join(", ");

        const uniqTerms = [];
        const seenTerm = new Set();
        for(const it of c.items){
          const t = String(it.차수 || "").trim();
          if(!t) continue;
          if(!seenTerm.has(t)){
            seenTerm.add(t);
            uniqTerms.push(t);
          }
        }
        c.차수요약 = uniqTerms.join(", ");
      }

      function gradeNum(g){
        const m = String(g||"").match(/(\d+)/);
        return m ? Number(m[1]) : 999;
      }

      list.sort((a,b) => {
        const ag = gradeNum(a.학년), bg = gradeNum(b.학년);
        if(ag !== bg) return ag - bg;
        const ac = (a.반||"").localeCompare(b.반||"", "ko");
        if(ac !== 0) return ac;
        const an = (a.번호 ?? 999) - (b.번호 ?? 999);
        if(an !== 0) return an;
        return (a.이름||"").localeCompare((b.이름||""), "ko");
      });

      return list;
    }

    /***********************
     * 문자 생성
     ***********************/
    function buildSmsForCase(c, settings){
      const schoolName = settings.schoolName;
      const bankName   = settings.bankName;
      const accountNum = settings.accountNumber;
      const roundText  = settings.roundText;
      const template   = settings.smsTemplate;

      const termText = (c.차수요약 && c.차수요약.trim()) ? c.차수요약.trim() : roundText;

      const repl = {
        "[학교명]": schoolName,
        "[학년]": c.학년 ?? "",
        "[반]": c.반 ?? "",
        "[번호]": (c.번호 ?? "") ? `${c.번호}번` : "",
        "[이름]": c.이름 ?? "",
        "[차수]": termText,
        "[납입금명]": c.납입금명요약 ?? "",
        "[은행명]": bankName,
        "[계좌번호]": accountNum,
        "[미납액]": (c.total||0).toLocaleString("ko-KR"),
      };

      let msg = String(template ?? "");
      for(const k of Object.keys(repl)){
        msg = msg.split(k).join(repl[k] ?? "");
      }
      return normalizeSpacesPerLine(msg);
    }

    function buildAllSmsText(settings){
      return cases.map(c => {
        const header = `${c.학년} ${c.반} ${c.번호 ?? ""}번 ${c.이름}`.replace(/\s+/g," ").trim();
        return `▶ ${header}\n${buildSmsForCase(c, settings)}\n`;
      }).join("\n").trim();
    }

    /***********************
     * 안내문 렌더링(캔버스)
     ***********************/
    const DIG_KOR = ["", "일", "이", "삼", "사", "오", "육", "칠", "팔", "구"];
    function fourToKor(n){
      const s = String(n).padStart(4,"0");
      const units = ["천","백","십",""];
      let out = "";
      for(let i=0;i<4;i++){
        const d = Number(s[i]);
        if(d === 0) continue;
        out += DIG_KOR[d] + units[i];
      }
      return out;
    }
    function numberToKor(n){
      n = Math.floor(Math.abs(Number(n) || 0));
      if(n === 0) return "영";
      const big = ["", "만", "억", "조", "경"];
      let idx = 0;
      let out = "";
      while(n > 0){
        const part = n % 10000;
        if(part > 0){
          out = fourToKor(part) + big[idx] + out;
        }
        n = Math.floor(n/10000);
        idx++;
      }
      return out;
    }

    function drawSpacedText(ctx, text, centerX, yBaseline, spacingPx){
      const chars = Array.from(String(text || ""));
      const widths = chars.map(ch => ctx.measureText(ch).width);
      const total = widths.reduce((a,b)=>a+b,0) + spacingPx * Math.max(0, chars.length-1);
      let x = centerX - total/2;
      for(let i=0;i<chars.length;i++){
        ctx.fillText(chars[i], x, yBaseline);
        x += widths[i] + spacingPx;
      }
      return total;
    }

    function renderNoticeToCanvas(caseObj, canvas, settings, opts={}){
      const baseW = LAYOUT.baseW;
      const baseH = LAYOUT.baseH;
      const scale = opts.scale || 1;

      canvas.width = Math.round(baseW * scale);
      canvas.height = Math.round(baseH * scale);

      const ctx = canvas.getContext("2d");
      ctx.setTransform(scale, 0, 0, scale, 0, 0);

      const family = `"맑은 고딕","Apple SD Gothic Neo","Noto Sans KR",system-ui,-apple-system,"Segoe UI",Roboto,sans-serif`;
      const TEXT = "#111";
      const stroke = "#222";

      const schoolName = settings.schoolName;
      const roundText = settings.roundText;

      const dueDate = parseDateInput(settings.dueDate);
      const docDate = parseDateInput(settings.docDate) || new Date();
      const principalTitle = schoolName ? (schoolName + "장") : "학교장";

      ctx.save();
      ctx.fillStyle = "#fff";
      ctx.fillRect(0,0,baseW,baseH);

      ctx.fillStyle = TEXT;
      ctx.textAlign = "center";
      ctx.textBaseline = "alphabetic";
      ctx.font = `800 ${Math.round(LAYOUT.titleSize)}px ${family}`;
      const titleBaseline = LAYOUT.titleTop + LAYOUT.titleSize + 6;
      const titleWidth = drawSpacedText(ctx, "미납안내문", baseW/2, titleBaseline, LAYOUT.titleSpacing);

      const underlineY = titleBaseline + 14;
      ctx.strokeStyle = stroke;
      ctx.lineWidth = LAYOUT.outerLine;
      ctx.beginPath();
      ctx.moveTo(baseW/2 - titleWidth/2, underlineY);
      ctx.lineTo(baseW/2 + titleWidth/2, underlineY);
      ctx.stroke();

      const boxX = LAYOUT.boxMargin;
      const boxY = underlineY + LAYOUT.boxTopGap;
      const boxW = baseW - LAYOUT.boxMargin*2;
      const boxH = baseH - boxY - LAYOUT.boxBottomMargin;

      ctx.lineWidth = LAYOUT.outerLine;
      ctx.strokeStyle = stroke;
      ctx.strokeRect(boxX, boxY, boxW, boxH);

      function cell(x, y, w, h, fill){
        if(fill){
          ctx.save();
          ctx.fillStyle = fill;
          ctx.fillRect(x,y,w,h);
          ctx.restore();
        }
        ctx.save();
        ctx.strokeStyle = stroke;
        ctx.lineWidth = LAYOUT.innerLine;
        ctx.strokeRect(x,y,w,h);
        ctx.restore();
      }

      let y = boxY;
      const labelW = Math.round(boxW * LAYOUT.labelWRatio);
      const valW = boxW - labelW;

      ctx.textBaseline = "middle";

      // 1행 학번
      cell(boxX, y, labelW, LAYOUT.topRowH, LABEL_BG);
      cell(boxX+labelW, y, valW, LAYOUT.topRowH, "#fff");
      ctx.fillStyle = TEXT;
      ctx.textAlign="center";
      ctx.font = `700 ${LAYOUT.labelSize}px ${family}`;
      ctx.fillText("학   번", boxX + labelW/2, y + LAYOUT.topRowH/2);

      ctx.textAlign="left";
      const noText = (caseObj.번호 ?? "") ? `${caseObj.번호}번` : "";
      const classLine = `${caseObj.학년 ?? ""} ${caseObj.반 ?? ""} - ${noText}`.replace(/\s+/g," ").trim();
      let curSize = LAYOUT.valueSize;
      ctx.font = `600 ${curSize}px ${family}`;
      while(curSize > 18 && ctx.measureText(classLine).width > (valW - 36)){
        curSize -= 1;
        ctx.font = `600 ${curSize}px ${family}`;
      }
      ctx.fillText(classLine, boxX + labelW + 18, y + LAYOUT.topRowH/2);
      y += LAYOUT.topRowH;

      // 2행 이름
      cell(boxX, y, labelW, LAYOUT.topRowH, LABEL_BG);
      cell(boxX+labelW, y, valW, LAYOUT.topRowH, "#fff");
      ctx.fillStyle = TEXT;
      ctx.textAlign="center";
      ctx.font = `700 ${LAYOUT.labelSize}px ${family}`;
      ctx.fillText("이   름", boxX + labelW/2, y + LAYOUT.topRowH/2);

      ctx.textAlign="left";
      ctx.font = `600 ${LAYOUT.valueSize}px ${family}`;
      ctx.fillText(String(caseObj.이름||""), boxX + labelW + 18, y + LAYOUT.topRowH/2);
      y += LAYOUT.topRowH;

      // 일금
      cell(boxX, y, boxW, LAYOUT.moneyRowH, "#fff");
      ctx.fillStyle = TEXT;
      ctx.textAlign="center";
      ctx.font = `600 ${LAYOUT.valueSize}px ${family}`;
      ctx.fillText(`일금 ${numberToKor(caseObj.total)} 원정`, boxX + boxW/2, y + LAYOUT.moneyRowH/2);
      y += LAYOUT.moneyRowH;

      // 표
      const col1 = Math.round(boxW * LAYOUT.col1Ratio);
      const col2 = Math.round(boxW * LAYOUT.col2Ratio);
      const col3 = boxW - col1 - col2;

      cell(boxX, y, col1, LAYOUT.headH, LABEL_BG);
      cell(boxX+col1, y, col2, LAYOUT.headH, LABEL_BG);
      cell(boxX+col1+col2, y, col3, LAYOUT.headH, LABEL_BG);

      ctx.fillStyle = TEXT;
      ctx.textAlign="center";
      ctx.font = `700 ${LAYOUT.tableSize}px ${family}`;
      ctx.fillText("구   분", boxX + col1/2, y + LAYOUT.headH/2);
      ctx.fillText("금   액", boxX + col1 + col2/2, y + LAYOUT.headH/2);
      ctx.fillText("비   고", boxX + col1 + col2 + col3/2, y + LAYOUT.headH/2);
      y += LAYOUT.headH;

      for(let i=0;i<TABLE_SLOTS;i++){
        cell(boxX, y, col1, LAYOUT.rowH, "#fff");
        cell(boxX+col1, y, col2, LAYOUT.rowH, "#fff");
        cell(boxX+col1+col2, y, col3, LAYOUT.rowH, "#fff");

        const it = caseObj.items[i];
        if(it){
          ctx.fillStyle = TEXT;

          // 구분
          let nm = String(it.납입금명||"");
          let s = LAYOUT.tableSize;
          ctx.textAlign="center";
          ctx.font = `600 ${s}px ${family}`;
          while(s > 16 && ctx.measureText(nm).width > (col1 - 18)){
            s -= 1;
            ctx.font = `600 ${s}px ${family}`;
          }
          ctx.fillText(nm, boxX + col1/2, y + LAYOUT.rowH/2);

          // 금액
          ctx.textAlign="right";
          ctx.font = `600 ${LAYOUT.tableSize}px ${family}`;
          ctx.fillText((it.미납액||0).toLocaleString("ko-KR"), boxX + col1 + col2 - 14, y + LAYOUT.rowH/2);

          // 비고
          const remark = (String(it.차수 || "").trim()) || (roundText || "");
          if(remark){
            ctx.textAlign="center";
            ctx.fillText(remark, boxX + col1 + col2 + col3/2, y + LAYOUT.rowH/2);
          }
        }
        y += LAYOUT.rowH;
      }

      // 합계
      cell(boxX, y, col1, LAYOUT.sumH, "#fff");
      cell(boxX+col1, y, col2, LAYOUT.sumH, "#fff");
      cell(boxX+col1+col2, y, col3, LAYOUT.sumH, "#fff");

      ctx.fillStyle = TEXT;
      ctx.font = `700 ${LAYOUT.tableSize}px ${family}`;
      ctx.textAlign="center";
      ctx.fillText("합   계", boxX + col1/2, y + LAYOUT.sumH/2);

      ctx.textAlign="right";
      ctx.fillText(caseObj.total.toLocaleString("ko-KR"), boxX + col1 + col2 - 14, y + LAYOUT.sumH/2);
      y += LAYOUT.sumH;

      // 하단 문구
      ctx.fillStyle = TEXT;
      ctx.font = `600 23px ${family}`;
      ctx.textAlign="left";
      ctx.textBaseline="alphabetic";
      ctx.fillText("※ 위의 금액이 미납되어 있습니다.", boxX + 10, y + 34);

      const dueLine = dueDate
        ? `${fmtKoreanDate(dueDate, false)} 까지 금액을 납부하여 주십시오.`
        : "이체 기한을 입력하면 여기에 표시됩니다.";
      ctx.fillText(dueLine, boxX + 10, y + 66);

      // 날짜/학교장
      const boxBottom = boxY + boxH;
      ctx.textAlign="center";
      ctx.font = `600 ${LAYOUT.dateSize}px ${family}`;
      ctx.fillText(fmtKoreanDate(docDate, true), boxX + boxW/2, boxBottom - 150);

      ctx.font = `800 34px ${family}`;
      ctx.fillText(principalTitle, boxX + boxW/2, boxBottom - 92);

      ctx.restore();
      return canvas;
    }

    function chunkItemsForPages(caseObj){
      const items = Array.isArray(caseObj.items) ? caseObj.items : [];
      const pages = [];
      if(items.length === 0){
        pages.push({ ...caseObj, items: [] });
        return pages;
      }
      for(let i=0; i<items.length; i+=TABLE_SLOTS){
        pages.push({ ...caseObj, items: items.slice(i, i+TABLE_SLOTS) });
      }
      return pages;
    }

    /***********************
     * 렌더
     ***********************/
    function renderRawTable(){
      const tbody = el("rawTbody");
      tbody.innerHTML = "";
      if(!rawRows.length){
        tbody.innerHTML = `<tr><td colspan="7" class="muted">아직 데이터가 없습니다.</td></tr>`;
        return;
      }
      for(const r of rawRows.slice(0, 2000)){
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${escapeHtml(r.학년)}</td>
          <td>${escapeHtml(r.반)}</td>
          <td>${r.번호 ?? ""}</td>
          <td>${escapeHtml(r.이름)}</td>
          <td>${escapeHtml(r.납입금명)}</td>
          <td>${escapeHtml(r.차수 || "")}</td>
          <td class="numeric">${(r.미납액||0).toLocaleString("ko-KR")}</td>
        `;
        tbody.appendChild(tr);
      }
    }

    function renderCaseTable(){
      const tbody = el("caseTbody");
      tbody.innerHTML = "";
      if(!cases.length){
        tbody.innerHTML = `<tr><td colspan="7" class="muted">아직 데이터가 없습니다.</td></tr>`;
        return;
      }
      for(const c of cases.slice(0, 2000)){
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${escapeHtml(c.학년)}</td>
          <td>${escapeHtml(c.반)}</td>
          <td>${c.번호 ?? ""}</td>
          <td>${escapeHtml(c.이름)}</td>
          <td>${escapeHtml(c.차수요약 || "")}</td>
          <td>${escapeHtml(c.납입금명요약 || "")}</td>
          <td class="numeric">${c.total.toLocaleString("ko-KR")}</td>
        `;
        tbody.appendChild(tr);
      }
    }

    function populateCaseSelect(){
      const sel = el("caseSelect");
      sel.innerHTML = "";

      if(!cases.length){
        sel.disabled = true;
        selectedCaseKey = "";
        sel.innerHTML = `<option value="">먼저 엑셀을 업로드하고 추출하세요</option>`;
        return;
      }

      sel.disabled = false;
      for(const c of cases){
        const opt = document.createElement("option");
        opt.value = c.key;
        const label = `${c.학년} ${c.반} ${c.번호 ?? ""}번 ${c.이름}`.replace(/\s+/g," ").trim();
        opt.textContent = `${label} (${c.total.toLocaleString("ko-KR")}원)`;
        sel.appendChild(opt);
      }

      selectedCaseKey = cases[0].key;
      sel.value = selectedCaseKey;
    }

    function getSelectedCase(){
      return cases.find(x => x.key === selectedCaseKey) || null;
    }

    function updatePreview(){
      const c = getSelectedCase();
      const canvas = el("previewCanvas");
      if(!c){
        canvas.getContext("2d").clearRect(0,0,canvas.width,canvas.height);
        el("smsPreview").value = "";
        return;
      }

      const live = collectSettings();
      renderNoticeToCanvas(c, canvas, live, { scale: 1 });
      el("smsPreview").value = buildSmsForCase(c, live);
    }

    function renderAll(){
      renderRawTable();
      renderCaseTable();
      populateCaseSelect();
      updatePreview();
      updateUIStates();
    }

    /***********************
     * 다운로드
     ***********************/
    function downloadBlob(blob, filename){
      const a = document.createElement("a");
      const url = URL.createObjectURL(blob);
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function canvasToBlob(canvas, type="image/png", quality){
      return new Promise((resolve) => canvas.toBlob((b) => resolve(b), type, quality));
    }

    function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

    function requireApplied(){
      if(!appliedSettings){
        setStatus("먼저 “추출한 미납자 정보 반영하기” 버튼을 눌러 적용해주세요.", "warn");
        return false;
      }
      return true;
    }

    function requireLib(key, human){
      if(!isLibOk(key)){
        setStatus(`필수 라이브러리(${human})가 로드되지 않아 이 기능을 사용할 수 없습니다.`, "err");
        return false;
      }
      return true;
    }

    function buildMessageWorkbookArrayBuffer(settings){
      if(!window.XLSX) throw new Error("XLSX 라이브러리가 로드되지 않았습니다.");

      const wb = XLSX.utils.book_new();

      const header1 = ["학년","반","번호","이름","차수(요약)","납입금명(요약)","총 미납액","문자문구"];
      const rows1 = cases.map(c => ([
        c.학년 ?? "",
        c.반 ?? "",
        (c.번호 ?? "") ? `${c.번호}번` : "",
        c.이름 ?? "",
        c.차수요약 ?? "",
        c.납입금명요약 ?? "",
        c.total ?? 0,
        buildSmsForCase(c, settings),
      ]));
      const ws1 = XLSX.utils.aoa_to_sheet([header1, ...rows1]);
      ws1["!cols"] = [{wch:10},{wch:10},{wch:8},{wch:10},{wch:18},{wch:30},{wch:12},{wch:70}];
      XLSX.utils.book_append_sheet(wb, ws1, "문자문구");

      const header2 = ["학년","반","번호","이름","납입금명","차수(행)","미납액"];
      const rows2 = rawRows.map(r => ([
        r.학년 ?? "",
        r.반 ?? "",
        (r.번호 ?? "") ? `${r.번호}번` : "",
        r.이름 ?? "",
        r.납입금명 ?? "",
        r.차수 ?? "",
        r.미납액 ?? 0,
      ]));
      const ws2 = XLSX.utils.aoa_to_sheet([header2, ...rows2]);
      ws2["!cols"] = [{wch:10},{wch:10},{wch:8},{wch:10},{wch:22},{wch:18},{wch:12}];
      XLSX.utils.book_append_sheet(wb, ws2, "추출원본");

      return XLSX.write(wb, { bookType: "xlsx", type: "array" });
    }

    function downloadXlsxOnly(){
      if(!requireApplied()) return;
      if(!requireLib("xlsx", "XLSX(엑셀)")) return;

      const settings = appliedSettings;
      const d = parseDateInput(settings.docDate) || new Date();
      const dateISO = toISODate(d);

      const buf = buildMessageWorkbookArrayBuffer(settings);
      const blob = new Blob([buf], { type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" });
      downloadBlob(blob, `미납_문구_${dateISO}.xlsx`);
    }

    async function buildPdfBlob(settings, progressCb){
      if(!(window.jspdf && window.jspdf.jsPDF)) throw new Error("jsPDF 라이브러리가 로드되지 않았습니다.");

      const { jsPDF } = window.jspdf;
      const pageW = LAYOUT.baseW, pageH = LAYOUT.baseH;
      const doc = new jsPDF({ orientation: "portrait", unit: "px", format: [pageW, pageH] });

      const tempCanvas = document.createElement("canvas");

      const allPages = [];
      for(const c of cases){
        const pages = chunkItemsForPages(c);
        for(const p of pages) allPages.push(p);
      }

      for(let i=0;i<allPages.length;i++){
        const p = allPages[i];
        renderNoticeToCanvas(p, tempCanvas, settings, { scale: EXPORT_SCALE });
        const imgData = tempCanvas.toDataURL("image/jpeg", 0.92);

        if(i > 0) doc.addPage([pageW, pageH], "portrait");
        doc.addImage(imgData, "JPEG", 0, 0, pageW, pageH);

        if(progressCb) progressCb(i+1, allPages.length);
        await sleep(0);
      }

      const ab = doc.output("arraybuffer");
      return new Blob([ab], { type: "application/pdf" });
    }

    async function downloadPdfOnly(){
      if(!requireApplied()) return;
      if(!requireLib("jspdf", "jsPDF(PDF)")) return;

      const settings = appliedSettings;
      const d = parseDateInput(settings.docDate) || new Date();
      const dateISO = toISODate(d);

      setStatus("PDF 생성중…", "");
      const pdfBlob = await buildPdfBlob(settings, (cur,total) => {
        setStatus(`PDF 생성중… (${cur}/${total})`, "");
      });
      downloadBlob(pdfBlob, `미납안내문_${dateISO}.pdf`);
      setStatus("안내문 PDF 다운로드 준비 완료", "ok");
    }

    async function downloadPngZipOnly(){
      if(!requireApplied()) return;
      if(!requireLib("jszip", "JSZip(압축)")) return;

      const settings = appliedSettings;
      const d = parseDateInput(settings.docDate) || new Date();
      const dateISO = toISODate(d);

      const zip = new JSZip();
      const folder = zip.folder("notices");
      const tempCanvas = document.createElement("canvas");

      const pagesList = [];
      for(const c of cases){
        const pages = chunkItemsForPages(c);
        for(let i=0;i<pages.length;i++){
          pagesList.push({ base: c, page: pages[i], idx: i+1, cnt: pages.length });
        }
      }

      for(let i=0;i<pagesList.length;i++){
        const { base, page, idx, cnt } = pagesList[i];
        renderNoticeToCanvas(page, tempCanvas, settings, { scale: EXPORT_SCALE });
        const blob = await canvasToBlob(tempCanvas, "image/png");

        const safeName = `${dateISO}_${base.학년}${base.반}_${base.번호 ?? ""}번_${base.이름}`
          .replace(/[\/\\?%*:|"<>]/g, "_")
          .replace(/\s+/g, " ")
          .trim();

        const suffix = (cnt > 1) ? `_p${idx}` : "";
        folder.file(`${safeName}${suffix}.png`, blob);

        setStatus(`PNG ZIP 생성중… (${i+1}/${pagesList.length})`, "");
        await sleep(0);
      }

      const zipBlob = await zip.generateAsync({ type: "blob" });
      downloadBlob(zipBlob, `미납안내문_PNG_${dateISO}.zip`);
      setStatus("안내문 PNG ZIP 다운로드 준비 완료", "ok");
    }

    async function downloadAllInOneZip(){
      if(!requireApplied()) return;
      if(!requireLib("xlsx", "XLSX(엑셀)")) return;
      if(!requireLib("jszip", "JSZip(압축)")) return;

      const includePdf = isLibOk("jspdf");
      const stepsTotal = includePdf ? 3 : 2;

      const settings = appliedSettings;
      const btn = el("btnDownloadAllZip");
      disableWhile(btn, true, "ZIP 생성중…");

      try{
        const d = parseDateInput(settings.docDate) || new Date();
        const dateISO = toISODate(d);
        const zip = new JSZip();

        setStatus(`전체 ZIP 생성중… (1/${stepsTotal}) 문구 엑셀 생성`, "");
        const xlsxBuf = buildMessageWorkbookArrayBuffer(settings);
        zip.file(`미납_문구_${dateISO}.xlsx`, xlsxBuf);

        setStatus(`전체 ZIP 생성중… (2/${stepsTotal}) 안내문 PNG 생성`, "");
        const noticesFolder = zip.folder("notices");
        const tempCanvas = document.createElement("canvas");

        const pagesList = [];
        for(const c of cases){
          const pages = chunkItemsForPages(c);
          for(let i=0;i<pages.length;i++){
            pagesList.push({ base: c, page: pages[i], idx: i+1, cnt: pages.length });
          }
        }

        for(let i=0;i<pagesList.length;i++){
          const { base, page, idx, cnt } = pagesList[i];
          renderNoticeToCanvas(page, tempCanvas, settings, { scale: EXPORT_SCALE });
          const blob = await canvasToBlob(tempCanvas, "image/png");

          const safeName = `${dateISO}_${base.학년}${base.반}_${base.번호 ?? ""}번_${base.이름}`
            .replace(/[\/\\?%*:|"<>]/g, "_")
            .replace(/\s+/g, " ")
            .trim();

          const suffix = (cnt > 1) ? `_p${idx}` : "";
          noticesFolder.file(`${safeName}${suffix}.png`, blob);

          setStatus(`전체 ZIP 생성중… (2/${stepsTotal}) 안내문 PNG 생성 (${i+1}/${pagesList.length})`, "");
          await sleep(0);
        }

        if(includePdf){
          setStatus(`전체 ZIP 생성중… (3/${stepsTotal}) 안내문 PDF 생성`, "");
          const pdfBlob = await buildPdfBlob(settings, (cur,total) => {
            setStatus(`전체 ZIP 생성중… (3/${stepsTotal}) 안내문 PDF 생성 (${cur}/${total})`, "");
          });
          zip.file(`미납안내문_${dateISO}.pdf`, pdfBlob);
        }

        setStatus("전체 ZIP 압축 중…", "");
        const zipBlob = await zip.generateAsync({ type: "blob" });
        downloadBlob(zipBlob, `미납_전체결과_${dateISO}.zip`);

        if(includePdf){
          setStatus("전체 결과 압축파일 다운로드 준비완료 (엑셀+PNG+PDF)", "ok");
        }else{
          setStatus("전체 결과 압축파일 다운로드 준비완료 (엑셀+PNG)  ※ PDF는 jsPDF 미로드로 제외됨", "warn");
        }

      }catch(err){
        console.error(err);
        setStatus(String(err?.message || err), "err");
      }finally{
        disableWhile(btn, false);
        updateUIStates();
      }
    }

    async function downloadOnePng(){
      const c = getSelectedCase();
      if(!c) return;

      const settings = collectSettings();
      const d = parseDateInput(settings.docDate) || new Date();
      const dateISO = toISODate(d);

      const canvas = document.createElement("canvas");
      const first = chunkItemsForPages(c)[0];
      renderNoticeToCanvas(first, canvas, settings, { scale: EXPORT_SCALE });

      const blob = await canvasToBlob(canvas, "image/png");
      const safeName = `${dateISO}_${c.학년}${c.반}_${c.번호 ?? ""}번_${c.이름}`
        .replace(/[\/\\?%*:|"<>]/g, "_")
        .replace(/\s+/g, " ")
        .trim();

      downloadBlob(blob, `${safeName}.png`);
    }

    async function copySelectedSms(){
      const c = getSelectedCase();
      if(!c) return;

      const live = collectSettings();
      const msg = buildSmsForCase(c, live);

      try{
        await navigator.clipboard.writeText(msg);
        setStatus("선택 학생 문자 문구를 클립보드에 복사했습니다", "ok");
      }catch(_){
        el("smsPreview").focus();
        el("smsPreview").select();
        document.execCommand("copy");
        setStatus("복사 완료", "ok");
      }
    }

    async function copyAllSms(){
      if(!requireApplied()) return;
      const settings = appliedSettings;

      const text = buildAllSmsText(settings);
      try{
        await navigator.clipboard.writeText(text);
        setStatus("전체 문자 문구를 클립보드에 복사했습니다", "ok");
      }catch(_){
        const ta = document.createElement("textarea");
        ta.value = text;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand("copy");
        ta.remove();
        setStatus("전체 복사 완료", "ok");
      }
    }

    /***********************
     * 업로드/드롭
     ***********************/
    function setupDropzone(){
      const dz = el("dropZone");
      const input = el("excelFile");

      dz.addEventListener("keydown", (e) => {
        if(e.key === "Enter" || e.key === " "){
          e.preventDefault();
          input.click();
        }
      });

      input.addEventListener("change", (e) => {
        const file = e.target.files?.[0];
        if(!file) return;
        if(!/\.xlsx?$/.test(file.name.toLowerCase())){
          setStatus("엑셀(.xlsx/.xls) 파일만 업로드할 수 있습니다.", "err");
          input.value = "";
          return;
        }
        setPendingFile(file);
        input.value = ""; // 같은 파일 재선택 가능하게
      });

      dz.addEventListener("dragenter", (e) => { e.preventDefault(); e.stopPropagation(); dz.classList.add("is-dragover"); });
      dz.addEventListener("dragover",  (e) => { e.preventDefault(); e.stopPropagation(); dz.classList.add("is-dragover"); });
      dz.addEventListener("dragleave", (e) => { e.preventDefault(); e.stopPropagation(); dz.classList.remove("is-dragover"); });

      dz.addEventListener("drop", (e) => {
        e.preventDefault();
        e.stopPropagation();
        dz.classList.remove("is-dragover");

        const file = e.dataTransfer?.files?.[0];
        if(!file) return;
        if(!/\.xlsx?$/.test(file.name.toLowerCase())){
          setStatus("엑셀(.xlsx/.xls) 파일만 업로드할 수 있습니다.", "err");
          return;
        }
        setPendingFile(file);
      });
    }

    /***********************
     * 추출 실행
     ***********************/
    async function runExtract(){
      if(!pendingFile){
        setStatus("먼저 엑셀 파일을 업로드하세요.", "err");
        return;
      }
      if(!isLibOk("xlsx")){
        setStatus(
          "XLSX 라이브러리가 준비되지 않아 추출할 수 없습니다.\n상단의 ‘필수 라이브러리 로딩’ 상태를 확인하세요.",
          "warn"
        );
        return;
      }

      const btn = el("btnExtract");
      disableWhile(btn, true, "추출중…");

      try{
        setStatus(`엑셀 읽는 중…\n- ${pendingFile.name}`, "");
        const buf = await pendingFile.arrayBuffer();

        const parsed = parseXlsx(buf);
        rawRows = parsed.rows;

        if(!rawRows.length){
          throw new Error("추출된 데이터가 없습니다. (이름/납입금명/미납액이 있는 행을 확인하세요)");
        }

        cases = buildCasesFromRaw(rawRows);
        appliedSettings = null;
        renderAll();

        const m = parsed.meta.matchedHeaders;
        const withTermCount = rawRows.filter(r => String(r.차수||"").trim()).length;

        setStatus(
          `추출 완료\n- 행 단위: ${rawRows.length}건\n- 학생별 통합: ${cases.length}건\n- 차수(행) 값이 있는 행: ${withTermCount}건\n\n[매칭된 헤더]\n- 학년: ${m.학년}\n- 반: ${m.반}\n- 번호: ${m.번호}\n- 이름: ${m.이름}\n- 납입금명: ${m.납입금명}\n- 차수: ${m.차수}\n- 미납액: ${m.미납액}\n\n이제 징수 정보/문구 입력 후 “추출한 미납자 정보 반영하기”를 누르십시오.`,
          "ok"
        );

      }catch(err){
        console.error(err);
        clearResultsOnly();
        setStatus(String(err?.message || err), "err");
      }finally{
        disableWhile(btn, false);
        updateUIStates();
      }
    }

    /***********************
     * 적용(반영)
     ***********************/
    function applyOutputs(){
      if(!cases.length){
        setStatus("먼저 1번에서 미수납자 정보를 추출하세요.", "warn");
        return;
      }
      const live = collectSettings();
      appliedSettings = { ...live };

      updateUIStates();
      setStatus(
        "입력내용 적용 완료.\n이제 전체 다운로드/개별 다운로드/전체 복사가 활성화됩니다.\n\n(입력값을 다시 수정하면 적용이 해제됩니다.)",
        "ok"
      );
      saveSettings();
      updatePreview();
    }

    /***********************
     * 이벤트 바인딩
     ***********************/
    function safeOn(id, evt, fn){
      const node = el(id);
      if(!node) return;
      node.addEventListener(evt, fn);
    }

    safeOn("btnExtract", "click", () => runExtract());
    safeOn("btnReset", "click", () => resetAll());

    safeOn("btnApply", "click", () => applyOutputs());

    safeOn("caseSelect", "change", (ev) => {
      selectedCaseKey = ev.target.value;
      updatePreview();
    });

    safeOn("btnDownloadAllZip", "click", () => cases.length && downloadAllInOneZip());
    safeOn("btnCopyAllSms", "click", () => cases.length && copyAllSms());

    safeOn("btnDownloadXlsxOnly", "click", () => cases.length && downloadXlsxOnly());
    safeOn("btnDownloadPngZipOnly", "click", () => cases.length && downloadPngZipOnly());
    safeOn("btnDownloadPdfOnly", "click", () => cases.length && downloadPdfOnly());

    safeOn("btnOnePng", "click", () => downloadOnePng());
    safeOn("btnCopySms", "click", () => copySelectedSms());

    const watchIds = ["schoolName","roundText","bankName","accountNumber","dueDate","docDate","smsTemplate"];
    for(const id of watchIds){
      safeOn(id, "input", () => {
        updatePreview();
        markNotApplied("입력값이 변경되었습니다.");
        saveSettings();
      });
      safeOn(id, "change", () => {
        updatePreview();
        markNotApplied("입력값이 변경되었습니다.");
        saveSettings();
      });
    }

    /***********************
     * 초기 로드
     ***********************/
    (function init(){
      setupDropzone();

      const loaded = loadSettings();
      if(!el("smsTemplate").value.trim()) el("smsTemplate").value = DEFAULT_SMS_TEMPLATE;
      if(!el("docDate").value) el("docDate").value = toISODate(new Date());
      if(!loaded) saveSettings();

      setPendingFile(null);
      renderLibProgress();
      updateUIStates();
      setStatus("기다리는 중. 엑셀 파일을 올리고 나서 추출하기를 누르십시오.", "");

      startLibraryLoad();
    })();
  </script>

  <script src="/static/disable-copy.js"></script>
  <script src="/static/footer.js"></script>
  <script src="/static/global-loader.js?v=1"></script>
</body>
</html>