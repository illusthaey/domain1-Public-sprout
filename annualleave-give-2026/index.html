<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>2026학년도 연차유급휴가 부여일수 계산기</title>

  <link rel="stylesheet" href="/static/style.css?v=260220" />
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <style>
    /* Drag & Drop */
    .dropzone {
      border: 2px dashed #bbb;
      border-radius: 12px;
      padding: 18px;
      text-align: center;
      cursor: pointer;
      transition: .15s;
      background: #fafafa;
    }
    .dropzone.dragover {
      border-color: #333;
      background: #f2f2f2;
    }
    .dz-title { font-weight: 700; margin-bottom: 6px; }
    .dz-desc { font-size:0.95rem; color:#666; }
  
    /* ===============================
       결과표(연차 부여일수): 나이스 개인번호 표시 토글 + 성명 틀고정
       =============================== */

    /* 기본값: 개인번호 숨김(hide-pid), 성명은 항상 고정 */
    #resultTableWrap {
      --pid-col-width: 124px; /* 개인번호 열 고정폭(틀고정 오프셋 계산용) */
      --sticky-name-left: 0px;
    }
    #resultTableWrap.show-pid { --sticky-name-left: var(--pid-col-width); }
    #resultTableWrap.hide-pid { --sticky-name-left: 0px; }

    #resultTableWrap .col-pid {
      width: var(--pid-col-width);
      min-width: var(--pid-col-width);
      max-width: var(--pid-col-width);
    }

    /* 개인번호 열 숨김 */
    #resultTableWrap.hide-pid .col-pid { display: none; }

    /* 틀고정(가로 스크롤) */
    #resultTableWrap .col-pid,
    #resultTableWrap .col-name {
      position: sticky;
      background: #fff;
    }

    /* 개인번호: 맨 왼쪽 */
    #resultTableWrap .col-pid { left: 0; z-index: 4; }

    /* 성명: 개인번호 표시 여부에 따라 left 오프셋 변경 */
    #resultTableWrap .col-name { left: var(--sticky-name-left); z-index: 3; }

    /* 헤더 배경 유지 */
    #resultTableWrap th.col-pid,
    #resultTableWrap th.col-name {
      background: #f9fafb;
      z-index: 6;
    }

    /* 경계선(가독성) */
    #resultTableWrap .col-name {
      box-shadow: 2px 0 0 rgba(0,0,0,0.06);
    }

  </style>
</head>

<body>
  <header class="site-header">
    <div class="shell">
      <h1>2026학년도 연차유급휴가 부여일수 계산기</h1>
      <p class="subtitle">교육공무직·특수운영직군(상시/비상시) 연차 부여일수 자동 계산</p>
    </div>
  </header>

  <main class="container">
    <section class="section">
      <h2>1. 학사일정(방학) 입력</h2>
      <p class="muted">
        ·비상시근로자(방학중 근무자)의 출근율 및 방학중 근무 가산 산정을 위해 필요합니다.<br/>
        ·토요일은 분모에서 제외됩니다.
      </p>

      <div class="card">
        <div class="grid two">
          <label class="stack">
            <span class="mini">여름방학 시작</span>
            <input type="date" id="summerStart" />
          </label>
          <label class="stack">
            <span class="mini">여름방학 종료</span>
            <input type="date" id="summerEnd" />
          </label>
          <label class="stack">
            <span class="mini">겨울방학 시작</span>
            <input type="date" id="winterStart" />
          </label>
          <label class="stack">
            <span class="mini">겨울방학 종료</span>
            <input type="date" id="winterEnd" />
          </label>
        </div>

        <div class="row gap" style="margin-top:10px;">
          <button class="btn primary" id="btnApplyCalendar">학사일정 적용</button>
          <button class="btn" id="btnClearCalendar">학사일정 초기화</button>
        </div>

        <div id="calendarMsg" class="msg" style="margin-top:12px;"></div>
      </div>
    </section>

    <section class="section">
      <h2>2. 인사정보 입력(대상자)</h2>
      <p class="muted">
        ·나이스 인사기록카드 엑셀 파일을 업로드하면 자동으로 대상자를 생성합니다.<br/>
        ·인사정보 파일이 없으면 수기 입력으로도 가능합니다.
      </p>

      <div class="card">
        <div class="row gap">
          <label class="row"><input type="radio" name="hrMode" value="file" checked /> 파일 업로드</label>
          <label class="row"><input type="radio" name="hrMode" value="manual" /> 수기 입력</label>
        </div>

        <div id="hrFileBox" style="margin-top:12px;">
          <div class="dropzone" id="hrDrop">
            <p class="dz-title">인사정보 파일 업로드 (엑셀/CSV)</p>
            <p class="dz-desc">(여러 개 가능 · 드래그 & 드롭 가능)</p>
          </div>
          <input type="file" id="hrFiles" accept=".xlsx,.xls,.csv" multiple class="hidden" />

          <div class="row gap" style="margin-top:10px;">
            <button class="btn primary" id="btnLoadHR">인사정보 불러오기</button>
            <button class="btn" id="btnClearWorkers">대상자 전체 초기화</button>
          </div>

          <div id="hrMsg" class="msg" style="margin-top:12px;"></div>
        </div>

        <div id="hrManualBox" class="hidden" style="margin-top:12px;">
          <h3 class="local-h3">대상자 수기 추가</h3>

          <div class="grid three">
            <label class="stack">
              <span class="mini">직군</span>
              <select id="mGroup">
                <option value="edu">교육공무직</option>
                <option value="special">특수운영</option>
              </select>
            </label>

            <label class="stack">
              <span class="mini">근무형태</span>
              <select id="mPattern">
                <option value="always">상시</option>
                <option value="emergency">비상시</option>
              </select>
            </label>

            <label class="stack">
              <span class="mini">최초임용일</span>
              <input type="date" id="mHire" />
            </label>

            <label class="stack">
              <span class="mini">1일 소정근로시간</span>
              <input type="number" id="mDailyHours" value="8" min="1" max="12" step="0.5" />
            </label>

            <label class="stack">
              <span class="mini">성명</span>
              <input type="text" id="mName" placeholder="홍길동" />
            </label>

            <label class="stack">
              <span class="mini">개인번호(나이스)</span>
              <input type="text" id="mPid" placeholder="예: 123456" />
            </label>
          </div>

          <div class="row gap" style="margin-top:10px;">
            <button class="btn primary" id="btnAddWorker">대상자 추가</button>
            <button class="btn" id="btnClearWorkers2">대상자 전체 초기화</button>
          </div>

          <div class="table-wrap">
            <table class="sheetlike table-compact" id="workersTable">
              <thead>
                <tr>
                  <th class="nowrap">성명</th>
                  <th class="nowrap">개인번호</th>
                  <th class="nowrap">직군</th>
                  <th class="nowrap">근무형태</th>
                  <th class="nowrap">최초임용일</th>
                  <th class="nowrap right">1일시간</th>
                  <th class="nowrap right">근속연수 (2026.3.1.기준)</th>
                  <th class="nowrap center">삭제</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>

          <div id="hrManualMsg" class="msg" style="margin-top:12px;"></div>
        </div>
      </div>
    </section>

    <section class="section">
      <h2>3. 근무상황(복무) 입력</h2>
      <p class="muted">
        ·나이스에서 개인별 근무상황 조회내역 엑셀 파일 수정 없이 그대로 업로드해주십시오. 수기 입력도 가능합니다.<br/>
        ·파일 업로드 시 전체 복무 사항 자동 취합·분류함.<br/>
        ·특이사항 예외사항 있는 경우에는 수기 입력하쇼.<br/>
        <span class="muted">※ <b>연차 사용일수 집계</b>는 <b>결재상태가 “완결”인 건만</b> 집계합니다.</span>
      </p>

      <div class="card">
        <div class="row gap">
          <label class="row"><input type="radio" name="workMode" value="file" checked /> 파일 업로드</label>
          <label class="row"><input type="radio" name="workMode" value="manual" /> 수기 입력</label>
        </div>

        <div id="workFileBox" style="margin-top:12px;">
          <div class="grid two">
            <div>
              <div class="dropzone" id="workDrop">
                <p class="dz-title">근무상황목록 파일 업로드 (엑셀/CSV)</p>
                <p class="dz-desc">(여러 개 가능 · 드래그 & 드롭 가능)</p>
              </div>
              <input type="file" id="workFiles" accept=".xlsx,.xls,.csv" multiple class="hidden" />
              <div class="muted" style="margin-top:8px;">※ 파일 선택 후 <b>복무사항 불러오기</b>를 눌러주세요.</div>
            </div>

            <div class="msg warn">
              <div><b>안내</b></div>
              <ul>
                <li>복무를 잘못 낸 경우를 대비해서 모든 복무 내역을 취합·분류함.</li>
                <li>자동으로 분류하기 애매한 항목은 "검토"로 표시함. (개별 확인 필요)</li>
              </ul>
            </div>
          </div>

          <div class="row gap" style="margin-top:10px;">
            <button class="btn primary" id="btnLoadWork">복무사항 불러오기</button>
            <button class="btn" id="btnClearWork">전체 초기화</button>
          </div>
          <div id="workMsg" class="msg" style="margin-top:12px;"></div>
        </div>

        <div id="workManualBox" class="hidden" style="margin-top:12px;">
          <h3 class="local-h3">복무사항 수기 입력</h3>
          <p class="muted">
            ·수기 입력 모드는 기본적으로 "정상근무"를 전제로 함. 출근율 산정에 영향이 있는 예외사항 입력할 때 사용하세요.
          </p>

          <div class="grid three">
            <label class="stack">
              <span class="mini">근로자 선택하기</span>
              <select id="wSelect"></select>
            </label>
            <label class="stack">
              <span class="mini">시작일자</span>
              <input type="date" id="wStart" />
            </label>
            <label class="stack">
              <span class="mini">종료일자</span>
              <input type="date" id="wEnd" />
            </label>

            <label class="stack">
              <span class="mini">복무 종류</span>
              <input type="text" id="wType" placeholder="질병휴직 / 결근 / 연가 등" />
            </label>

            <label class="stack">
              <span class="mini">복무 사유</span>
              <input type="text" id="wReason" placeholder="필요 시 입력" />
            </label>

            <label class="stack">
              <span class="mini">분류 방법 선택</span>
              <select id="wClass">
                <option value="auto">자동 판별</option>
                <option value="deemed">출근 간주 (분자 포함)</option>
                <option value="excluded">제외 기간 (분모·분자 제외)</option>
                <option value="absence">결근 간주</option>
                <option value="review">확인 필요 (미분류)</option>
              </select>
            </label>
          </div>

          <div class="row gap" style="margin-top:10px;">
            <label class="row">
              <input type="checkbox" id="wCredit" />
              비상시 직종의 방학중 근무 (우선채용 등)
            </label>
            <button class="btn primary" id="btnAddRecord">복무내역 추가</button>
            <button class="btn" id="btnClearManualRecords">전체 초기화</button>
          </div>

          <div id="workManualMsg" class="msg" style="margin-top:12px;"></div>
        </div>
      </div>
    </section>

    <section class="section">
      <h2>4. 연차 유급휴가 부여일수 계산 실행</h2>

      <div class="card">
        <div class="grid two">
          <div class="msg">
            <div><b>비상시근로자의 출근율</b></div>
            <ol>
              <li>출근율(학기중): 비상시근로자 기준으로 산정</li>
              <li>출근율(연간): 연간 기준으로 산정(상시근로자와 동일한 분모) · <b>비상시직종은 학기중 80% 미만일 때만 결과표에 표시</b></li>
              <li>출근율(비례산정): <b>학기중 출근율 80% 미만인 경우에만</b> 산정(제외기간 제거)</li>
            </ol>
            <div class="muted">※상시근로자는 연간 출근율이 80% 미만일 때만 비례산정 출근율을 산정합니다.</div>
          </div>

          <div class="msg">
            <div><b>계산조건 기본 설정</b></div>
            <ul>
              <li>복무실적 산정기간: 2025.3.1.~2026.2.28.</li>
              <li>연차일수 부여 기준일자: 2026.3.1.</li>
              <li>토요일은 분모에서 제외</li>
              <li>비례산정은 소수점 둘째 자리에서 반올림한 후 시간 단위로 환산함.</li>
            </ul>
          </div>
        </div>

        <div class="row gap" style="margin-top:12px;">
          <button class="btn primary" id="btnRun">계산 실행하기</button>
          <button class="btn" id="btnDownload">계산 결과 엑셀 저장</button>
        </div>

        <div id="runMsg" class="msg" style="margin-top:12px;"></div>
      </div>
    </section>

    <section class="section">
      <h2>5. 연차 부여일수 계산 결과</h2>

      <div id="resultSummary" class="msg">계산 실행 버튼 먼저 눌러주세요.</div>

      <div class="row gap" style="margin-top:10px;">
        <label class="row">
          <input type="checkbox" id="chkShowPid" />
          나이스 개인번호 표시
        </label>
        <span class="muted">※ 기본값: 숨김 (성명은 가로 스크롤해도 고정)</span>
      </div>

      <div class="table-wrap hide-pid" id="resultTableWrap">
        <table class="sheetlike table-compact" id="resultTable">
          <thead>
            <tr>
              <th class="nowrap col-pid">나이스 개인번호</th>
              <th class="nowrap col-name">성명</th>
              <th class="nowrap">직군</th>
              <th class="nowrap">근무형태</th>
              <th class="nowrap right">근속</th>
              <th class="nowrap right">출근율(학기중)</th>
              <th class="nowrap right">출근율(연간)</th>
              <th class="nowrap right">출근율(비례산정)</th>
              <th class="nowrap right">기본</th>
              <th class="nowrap right">출근가산</th>
              <th class="nowrap right">근속가산</th>
              <th class="nowrap right">기준연차(상한25)</th>
              <th class="nowrap right">최종부여</th>
              <th class="nowrap">판정</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>

      <h3>개인별 상세(복무 취합/분류 포함)</h3>

      <!-- 안내사항: 여기 한 번만 -->
      <div id="detailNotice" class="msg warn hidden" style="margin-top:10px;">
        <div><b>안내 사항</b></div>
        <ul>
          <li>“검토”로 분류된 항목은 담당자가 직접 반영 여부를 확인하세요.</li>
          <li>비상시근로자의 방학중 근무(분자 가산)는 “방학기간과 겹치는 유급근무”에만 체크하기를 권장합니다.</li>
          <li>연차 사용일수 집계는 결재상태가 <b>“완결”</b>인 내역만 집계합니다.</li>
        </ul>
      </div>

      <div id="detailBox" class="stack"></div>
    </section>
  </main>

  <div class="home-link-wrap">
    <a class="btn" href="/">메인으로 돌아가기</a>
  </div>

<script>
(() => {
  "use strict";

  const PERIOD_START = ymdToUTC("2025-03-01");
  const PERIOD_END   = ymdToUTC("2026-02-28"); // inclusive
  const GRANT_DATE   = ymdToUTC("2026-03-01");

  const DEFAULT_DAILY_HOURS = 8;
  const BASE_DAYS_ALWAYS = 15; // 상시근로자(1년 이상) 기본 연차

  const CLASS_LABEL = {
    deemed: "출근간주",
    excluded: "산정제외",
    absence: "결근성",
    review: "검토",
    auto: "자동"
  };

  const RULES_2026 = {
    excludedKeywords: [
      "질병휴직", "가족돌봄휴직", "노조전임", "유학휴직", "행방불명",
      "파업", "쟁의", "휴업", "사용자귀책"
    ],
    absenceKeywords: [
      "결근", "무단", "연차초과", "미승인", "무급결근"
    ],
    deemedKeywords: [
      "연가", "연차", "공가", "특별휴가", "경조", "유급병가", "병가",
      "산재", "요양", "출산", "유산", "사산", "배우자출산",
      "예비군", "민방위", "동원", "공민권", "보상휴가", "보상휴무", "휴일대체",
      "가족돌봄휴가", "생리휴가", "난임", "임신기", "육아기"
    ],
    creditKeywords: [
      "방학", "급식실", "청소", "우선채용", "산업안전", "직무연수", "연수", "교육"
    ],
    reviewKeywords: [
      "재량휴업", "개교기념", "단축", "외근", "출장", "조합", "노조", "대체"
    ]
  };

  const state = {
    calendar: {
      summerStart: null,
      summerEnd: null,
      winterStart: null,
      winterEnd: null,
      applied: false,
      sets: null,
    },
    workers: new Map(),
    records: [],
    results: [],
    lastRunAt: null,
    selectedFiles: { hr: [], work: [] },
  };

  const $ = (sel) => document.querySelector(sel);
  const $$ = (sel) => Array.from(document.querySelectorAll(sel));

  function setMsg(el, cls, html) {
    el.className = `msg ${cls || ""}`.trim();
    el.innerHTML = html;
  }

  function escapeHtml(s) {
    return String(s ?? "")
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  function ymdToUTC(ymd) {
    const [y, m, d] = ymd.split("-").map(Number);
    return new Date(Date.UTC(y, m - 1, d));
  }

  function utcToYmd(date) {
    const y = date.getUTCFullYear();
    const m = String(date.getUTCMonth() + 1).padStart(2, "0");
    const d = String(date.getUTCDate()).padStart(2, "0");
    return `${y}-${m}-${d}`;
  }

  function addDaysUTC(date, days) {
    return new Date(date.getTime() + days * 86400000);
  }

  function clampToPeriod(date) {
    if (date < PERIOD_START) return PERIOD_START;
    if (date > PERIOD_END) return PERIOD_END;
    return date;
  }

  function isSaturdayUTC(date) {
    return date.getUTCDay() === 6;
  }

  function normalizeRange(start, end) {
    if (!start || !end) return null;
    if (end < start) [start, end] = [end, start];
    start = clampToPeriod(start);
    end = clampToPeriod(end);
    if (end < PERIOD_START || start > PERIOD_END) return null;
    return { start, end };
  }

  function buildCalendarSets() {
    const fullSet = new Set();
    const vacationSet = new Set();

    for (let d = PERIOD_START; d <= PERIOD_END; d = addDaysUTC(d, 1)) {
      if (isSaturdayUTC(d)) continue;
      fullSet.add(utcToYmd(d));
    }

    const ss = state.calendar.summerStart;
    const se = state.calendar.summerEnd;
    const ws = state.calendar.winterStart;
    const we = state.calendar.winterEnd;

    const vacRanges = [];
    const r1 = (ss && se) ? normalizeRange(ss, se) : null;
    const r2 = (ws && we) ? normalizeRange(ws, we) : null;

    if (r1) vacRanges.push(r1);
    if (r2) vacRanges.push(r2);

    for (const r of vacRanges) {
      for (let d = r.start; d <= r.end; d = addDaysUTC(d, 1)) {
        if (isSaturdayUTC(d)) continue;
        vacationSet.add(utcToYmd(d));
      }
    }

    const semesterSet = new Set([...fullSet].filter(x => !vacationSet.has(x)));

    state.calendar.sets = {
      fullSet,
      vacationSet,
      semesterSet,
      fullCount: fullSet.size,
      vacCount: vacationSet.size,
      semCount: semesterSet.size,
    };
  }

  function renderCalendarSummary() {
    const sets = state.calendar.sets;
    if (!sets) { setMsg($("#calendarMsg"), "warn", "학사일정을 적용해주십시오."); return; }

    const msg = `
      <div><b>기간</b>: 2025-03-01 ~ 2026-02-28 (토요일 제외)</div>
      <div><b>연간 분모(상시 기준)</b>: ${sets.fullCount}일</div>
      <div><b>학기중 분모(비상시 기준)</b>: ${sets.semCount}일</div>
      <div><b>방학 분모</b>: ${sets.vacCount}일</div>
    `;
    setMsg($("#calendarMsg"), state.calendar.applied ? "ok" : "warn", msg);
  }

  function safeDiv(a, b) {
    if (!b) return 0;
    return a / b;
  }

  function pctValue(x) {
    return Math.round(x * 1000) / 10;
  }

  function classifyAnnualLeaveKind(type) {
    const s = String(type || "").replace(/\s+/g, "");
    if (!s) return null;
    if (s.includes("반일") || s.includes("0.5")) return "HALF";
    if (s.includes("지각")) return "LATE";
    if (s.includes("조퇴")) return "EARLY";
    if (s.includes("외출")) return "OUT";
    if (s.includes("연차") || s.includes("연가")) return "FULL";
    return null;
  }

  function isFinalApprovedStatus(st) {
    const s = String(st || "").trim();
    if (!s) return false;
    return s.includes("완결") || s.includes("승인") || s.includes("결재완료");
  }

  function recordClass(rec) {
    const fin = rec.finalClass;
    if (fin && fin !== "auto") return fin;
    return rec.autoClass || "review";
  }

  function computeRecordMinutesOnSet(rec, set, dailyMinutes) {
    if (!set) return 0;
    const r = normalizeRange(rec.startUTC, rec.endUTC);
    if (!r) return 0;

    let days = 0;
    for (let d = r.start; d <= r.end; d = addDaysUTC(d, 1)) {
      if (isSaturdayUTC(d)) continue;
      const ymd = utcToYmd(d);
      if (set.has(ymd)) days += 1;
    }
    return days * dailyMinutes;
  }

  function minutesToDHM(totalMinutes, dailyMinutes) {
    const days = Math.floor(totalMinutes / dailyMinutes);
    const rem = totalMinutes - days * dailyMinutes;
    const hours = Math.floor(rem / 60);
    const minutes = rem - hours * 60;
    return { days, hours, minutes };
  }

  function fmtDHM(x) {
    if (!x) return "0일";
    const parts = [];
    parts.push(`${x.days}일`);
    if (x.hours) parts.push(`${x.hours}시간`);
    if (x.minutes) parts.push(`${x.minutes}분`);
    return parts.join(" ");
  }

  function computeAnnualLeaveUsageSummary(workerKey, dailyMinutes) {
    if (!state.calendar.sets) buildCalendarSets();
    const sets = state.calendar.sets;

    const byKind = { FULL:0, HALF:0, LATE:0, EARLY:0, OUT:0 };
    let total = 0;

    const recs = state.records.filter(r => r.workerKey === workerKey);
    for (const r of recs) {
      const kind = classifyAnnualLeaveKind(r.type);
      if (!kind) continue;
      if (!isFinalApprovedStatus(r.approvalStatus)) continue;

      const mins = computeRecordMinutesOnSet(r, sets.fullSet, dailyMinutes);
      total += mins;
      byKind[kind] += mins;
    }

    return { total, byKind };
  }

  // ==========================
  // 출근율/연차부여 계산
  // ==========================

  // (수정) 기본연차는 직종/근무형태로만 결정
  // - 상시: BASE_DAYS_ALWAYS(기본 15일)
  // - 비상시(방학중): 교육공무직 12일 / 특수운영직군 11일
  function baseDaysForWorker(w) {
    const isEmergency = (w.pattern === "emergency");
    const isSpecial = (w.group === "special");
    if (!isEmergency) return BASE_DAYS_ALWAYS;
    return isSpecial ? 11 : 12;
  }

  // (수정) 비상시직종: 학기중 출근율 80% 이상이면 "상시근로자 기본연차"에 맞추도록 가산
  // - 교육공무직 비상시: 12일 → +3일
  // - 특수운영직군 비상시: 11일 → +4일
  // 즉, (기본연차 + 출근가산) = BASE_DAYS_ALWAYS 가 되도록 보정
  function bonusDaysForWorker(w, rates) {
    if (w.pattern !== "emergency") return 0;

    const rSem = rates.rateSemester ?? 0;
    if (rSem < 0.8) return 0;

    const base = baseDaysForWorker(w);
    return Math.max(0, BASE_DAYS_ALWAYS - base);
  }

  function totalStandardDays(w, baseDays, bonusDays) {
    const add = w.addDays ?? 0; // 근속가산(3년차부터 2년에 1일)
    return Math.min(25, baseDays + (bonusDays || 0) + add);
  }

  function calcRatesForWorker(w) {
    const dailyHours = Number(w.dailyHours || DEFAULT_DAILY_HOURS);
    const dailyMinutes = dailyHours * 60;

    if (!state.calendar.sets) buildCalendarSets();
    const sets = state.calendar.sets;

    const workerRecords = state.records.filter(r => r.workerKey === w.key);

    let excludedFull = 0, absenceFull = 0;
    let excludedSem = 0, absenceSem = 0;
    let creditVac = 0;

    for (const r of workerRecords) {
      const cls = recordClass(r);

      const mFull = computeRecordMinutesOnSet(r, sets.fullSet, dailyMinutes);
      if (cls === "excluded") excludedFull += mFull;
      if (cls === "absence") absenceFull += mFull;

      const mSem = computeRecordMinutesOnSet(r, sets.semesterSet, dailyMinutes);
      if (cls === "excluded") excludedSem += mSem;
      if (cls === "absence") absenceSem += mSem;

      if (r.credit) {
        const mVac = computeRecordMinutesOnSet(r, sets.vacationSet, dailyMinutes);
        creditVac += mVac;
      }
    }

    const fullTotal = sets.fullCount * dailyMinutes;

    // 상시
    if (w.pattern !== "emergency") {
      const attended = Math.max(0, fullTotal - excludedFull - absenceFull);
      const rateFull = safeDiv(attended, fullTotal);

      const rateProportional = (rateFull < 0.8)
        ? safeDiv(attended, Math.max(1, fullTotal - excludedFull))
        : null;

      return {
        dailyMinutes,
        fullTotal,
        semTotal: null,
        excludedFull, absenceFull,
        excludedSem: null, absenceSem: null,
        creditVac: null,
        attendedFull: attended,
        attendedSem: null,
        rateSemester: null,
        rateFull,
        rateProportional
      };
    }

    // 비상시
    const semTotal = sets.semCount * dailyMinutes;
    const attendedSem = Math.max(0, semTotal - excludedSem - absenceSem);
    const attendedFull = Math.max(0, attendedSem + creditVac);

    const rateSemester = safeDiv(attendedSem, semTotal);
    const rateFull = safeDiv(attendedFull, fullTotal);

    const rateProportional = (rateSemester < 0.8)
      ? safeDiv(attendedSem, Math.max(1, semTotal - excludedSem))
      : null;

    return {
      dailyMinutes,
      fullTotal,
      semTotal,
      excludedFull, absenceFull,
      excludedSem, absenceSem,
      creditVac,
      attendedFull,
      attendedSem,
      rateSemester,
      rateFull,
      rateProportional
    };
  }

  function roundToOneDecimalDays(days) {
    return Math.round(days * 10) / 10;
  }

  function daysToDaysHours(days, dailyHours) {
    const d = Math.floor(days);
    const frac = days - d;
    let h = Math.round(frac * dailyHours);
    let dd = d;
    if (h >= dailyHours) { dd += 1; h = 0; }
    return { days: dd, hours: h };
  }

  // (추가) YYYY-MM 형태
  function toYm(dateUTC) {
    const y = dateUTC.getUTCFullYear();
    const m = String(dateUTC.getUTCMonth() + 1).padStart(2, "0");
    return `${y}-${m}`;
  }

  function startOfMonthUTC(dateUTC) {
    return new Date(Date.UTC(dateUTC.getUTCFullYear(), dateUTC.getUTCMonth(), 1));
  }

  function startOfNextMonthUTC(dateUTC) {
    return new Date(Date.UTC(dateUTC.getUTCFullYear(), dateUTC.getUTCMonth() + 1, 1));
  }

  // 1개월 "개근"을 달력월 기준으로 보기 위해:
  // - 입사일이 1일이면 그 달부터,
  // - 1일이 아니면 다음 달 1일부터를 첫 "완전한 개근월" 시작으로 봄.
  function firstFullMonthStartUTC(hireUTC) {
    if (!hireUTC) return PERIOD_START;
    const ms = startOfMonthUTC(hireUTC);
    if (hireUTC.getUTCDate() === 1) return ms;
    return startOfNextMonthUTC(hireUTC);
  }

  function enumerateMonths(startUTC, endUTC) {
    const res = [];
    let y = startUTC.getUTCFullYear();
    let m = startUTC.getUTCMonth() + 1;
    const ey = endUTC.getUTCFullYear();
    const em = endUTC.getUTCMonth() + 1;

    while (y < ey || (y === ey && m <= em)) {
      res.push(`${y}-${String(m).padStart(2,"0")}`);
      m += 1;
      if (m === 13) { m = 1; y += 1; }
    }
    return res;
  }

  function anyAbsenceInMonth(absenceDates, ym) {
    for (const ymd of absenceDates) {
      if (ymd.startsWith(ym + "-")) return true;
    }
    return false;
  }

  function anyAbsenceInVacation(absenceDates) {
    const sets = state.calendar.sets;
    if (!sets) return false;
    for (const ymd of absenceDates) {
      if (sets.vacationSet.has(ymd)) return true;
    }
    return false;
  }

  // (추가) 특정 기간(방학 등) 내 결근성 여부 확인
  function anyAbsenceInRange(absenceDates, startUTC, endUTC) {
    if (!startUTC || !endUTC) return false;
    const r = normalizeRange(startUTC, endUTC);
    if (!r) return false;
    for (let d = r.start; d <= r.end; d = addDaysUTC(d, 1)) {
      if (isSaturdayUTC(d)) continue;
      const ymd = utcToYmd(d);
      if (absenceDates.has(ymd)) return true;
    }
    return false;
  }

  function calcMonthlyAccrual(w) {
    const dailyHours = Number(w.dailyHours || DEFAULT_DAILY_HOURS);
    const dailyMinutes = dailyHours * 60;

    const workerRecords = state.records.filter(r => r.workerKey === w.key && recordClass(r) === "absence");
    const sets = state.calendar.sets;

    const absenceDates = new Set();

    for (const r of workerRecords) {
      for (let d = r.startUTC; d <= r.endUTC; d = addDaysUTC(d, 1)) {
        if (isSaturdayUTC(d)) continue;
        const ymd = utcToYmd(d);
        if (!sets || sets.fullSet.has(ymd)) absenceDates.add(ymd);
      }
    }

    // (수정) 근속 0년(1년 미만)인데 입사 전 달까지 개근월로 카운트되던 문제 방지
    let accrualStart = PERIOD_START;
    if (w.hireDateUTC) {
      const hire = w.hireDateUTC;
      if (hire > PERIOD_START) {
        accrualStart = firstFullMonthStartUTC(hire);
      }
    }
    if (accrualStart < PERIOD_START) accrualStart = PERIOD_START;

    if (w.pattern !== "emergency") {
      const months = enumerateMonths(accrualStart, PERIOD_END);
      let okCount = 0;
      for (const ym of months) {
        const hasAbs = anyAbsenceInMonth(absenceDates, ym);
        if (!hasAbs) okCount += 1;
      }
      const capped = Math.min(11, okCount);
      const spanText = months.length ? `${months[0]}~${months[months.length - 1]}` : "해당없음";
      return { days: capped, hours: 0, note: `개근월수(상시): ${okCount}개월 중 ${capped}일(최대11) 부여 · 산정월(${spanText})` };
    }

    const bucketMonths = ["2025-03","2025-04","2025-05","2025-06","2025-09","2025-10","2025-11"];
    const startYM = toYm(accrualStart);

    let ok = 0;
    let vacBucketsAdded = 0;

    for (const ym of bucketMonths) {
      if (ym < startYM) continue; // 입사 전(또는 완전 개근월 시작 전) 달은 제외
      const hasAbs = anyAbsenceInMonth(absenceDates, ym);
      if (!hasAbs) ok += 1;
    }

    // (수정) 방학버킷을 무조건 +2 하던 로직 제거
    // → 실제 입력된 여름/겨울방학 각각을 "버킷 1개"로 보고, 입사 이후 방학만 반영
    if (state.calendar.applied && sets && sets.vacCount > 0) {
      const vacs = [];
      if (state.calendar.summerStart && state.calendar.summerEnd) {
        const r = normalizeRange(state.calendar.summerStart, state.calendar.summerEnd);
        if (r) vacs.push({ name: "여름방학", start: r.start, end: r.end });
      }
      if (state.calendar.winterStart && state.calendar.winterEnd) {
        const r = normalizeRange(state.calendar.winterStart, state.calendar.winterEnd);
        if (r) vacs.push({ name: "겨울방학", start: r.start, end: r.end });
      }

      for (const v of vacs) {
        if (v.start < accrualStart) continue; // 입사 이전 방학은 제외
        const hasAbs = anyAbsenceInRange(absenceDates, v.start, v.end);
        if (!hasAbs) { ok += 1; vacBucketsAdded += 1; }
      }
    }

    const capped = Math.min(9, ok);
    const noteParts = [];
    noteParts.push(`개근월수(비상시): 버킷 ${ok}개 중 ${capped}일(최대9) 부여`);
    noteParts.push(`산정 시작월: ${startYM}`);
    if (!state.calendar.applied || !sets || sets.vacCount === 0) noteParts.push("방학 미입력: 방학버킷(최대2) 미반영");
    else noteParts.push(`방학버킷 반영: ${vacBucketsAdded}개`);
    return { days: capped, hours: 0, note: noteParts.join(" · ") };
  }

  function calcGrantForWorker(w) {
    const rates = calcRatesForWorker(w);

    const baseDays = baseDaysForWorker(w);
    const bonusDays = bonusDaysForWorker(w, rates); // 비상시 학기중 80% 이상이면 상시 기본연차에 맞춤(출근가산)
    const standard = totalStandardDays(w, baseDays, bonusDays);

    const serviceYears = w.serviceYears ?? 0;
    const isEmergency = (w.pattern === "emergency");

    if (serviceYears < 1) {
      const monthly = calcMonthlyAccrual(w);
      return {
        workerKey: w.key,
        baseDays,
        bonusDays: 0, // 신규(1년 미만) 월차에는 출근가산 개념 적용 안 함
        addDays: w.addDays ?? 0,
        standardDays: totalStandardDays(w, baseDays, 0),
        finalDays: monthly.days,
        finalHours: monthly.hours,
        method: "신규(1년 미만) 1개월 개근 1일",
        note: monthly.note,
        rates
      };
    }

    // 상시
    if (!isEmergency) {
      const rate1 = rates.rateFull ?? 0;
      const rateP = rates.rateProportional ?? 0;

      if (rate1 >= 0.8) {
        return { workerKey: w.key, baseDays, bonusDays: 0, addDays: w.addDays ?? 0, standardDays: standard, finalDays: standard, finalHours: 0, method: "정상부여(연간 출근율 80% 이상)", note: "", rates };
      }

      if (rates.rateProportional != null && rateP >= 0.8) {
        const fullDays = state.calendar.sets ? state.calendar.sets.fullCount : 0;
        const excludedDays = Math.round((rates.excludedFull ?? 0) / rates.dailyMinutes);
        const ratio = safeDiv(Math.max(0, fullDays - excludedDays), Math.max(1, fullDays));
        const raw = standard * ratio;
        const rounded = roundToOneDecimalDays(raw);
        const dh = daysToDaysHours(rounded, (w.dailyHours || DEFAULT_DAILY_HOURS));
        return { workerKey: w.key, baseDays, bonusDays: 0, addDays: w.addDays ?? 0, standardDays: standard, finalDays: dh.days, finalHours: dh.hours, method: "비례부여(비례산정 출근율 80% 충족)", note: `비례: ${standard} × (${fullDays - excludedDays}/${fullDays}) = ${rounded}일`, rates };
      }

      const monthly = calcMonthlyAccrual(w);
      return { workerKey: w.key, baseDays, bonusDays: 0, addDays: w.addDays ?? 0, standardDays: standard, finalDays: monthly.days, finalHours: monthly.hours, method: "80% 미달 → 개근월수(1개월 1일)", note: monthly.note, rates };
    }

    // 비상시
    const rateSem = rates.rateSemester ?? 0;
    const rateP = rates.rateProportional ?? 0;

    if (rateSem >= 0.8) {
      // (수정) 비상시: 학기중 80% 이상이면 (기본 12/11) + (출근가산: 상시 기본연차 맞춤) + 근속가산
      return { workerKey: w.key, baseDays, bonusDays, addDays: w.addDays ?? 0, standardDays: standard, finalDays: standard, finalHours: 0, method: "정상부여(학기중 출근율 80% 이상)", note: "", rates };
    }

    if (rates.rateProportional != null && rateP >= 0.8) {
      const semDays = state.calendar.sets ? state.calendar.sets.semCount : 0;
      const excludedDays = Math.round((rates.excludedSem ?? 0) / rates.dailyMinutes);
      const ratio = safeDiv(Math.max(0, semDays - excludedDays), Math.max(1, semDays));
      const raw = standard * ratio; // 여기서 standard는 bonusDays=0 상태(학기중 80% 미만이므로)
      const rounded = roundToOneDecimalDays(raw);
      const dh = daysToDaysHours(rounded, (w.dailyHours || DEFAULT_DAILY_HOURS));
      return { workerKey: w.key, baseDays, bonusDays: 0, addDays: w.addDays ?? 0, standardDays: standard, finalDays: dh.days, finalHours: dh.hours, method: "비례부여(비례산정 출근율 80% 충족)", note: `비례: ${standard} × (${semDays - excludedDays}/${semDays}) = ${rounded}일`, rates };
    }

    const monthly = calcMonthlyAccrual(w);
    return { workerKey: w.key, baseDays, bonusDays: 0, addDays: w.addDays ?? 0, standardDays: standard, finalDays: monthly.days, finalHours: monthly.hours, method: "80% 미달 → 개근월수(1개월 1일)", note: monthly.note, rates };
  }

  function pct(x) {
    return (x * 100).toFixed(1) + "%";
  }

  function minutesToDays(mins, dailyMinutes) {
    const days = (mins / dailyMinutes);
    const rounded = Math.round(days * 10) / 10;
    const dh = daysToDaysHours(rounded, dailyMinutes/60);
    return (dh.hours > 0) ? `${dh.days}일 ${dh.hours}시간` : `${dh.days}일`;
  }

  function formatStdCompact(r) {
    const parts = [];
    parts.push(String(r.baseDays ?? 0));
    if (r.bonusDays) parts.push(String(r.bonusDays));
    if (r.addDays) parts.push(String(r.addDays));
    return `${parts.join("+")}=${r.standardDays ?? 0}`;
  }

  function renderRecordRow(rec) {
    const auto = rec.autoClass || "review";
    const fin = rec.finalClass || "auto";
    const range = `${utcToYmd(rec.startUTC)} ~ ${utcToYmd(rec.endUTC)}`;
    const opt = (value, label) => `<option value="${value}" ${fin===value ? "selected":""}>${label}</option>`;

    return `
      <tr>
        <td class="nowrap">${escapeHtml(range)}</td>
        <td class="nowrap">${escapeHtml(rec.type || "")}</td>
        <td class="nowrap">${escapeHtml(rec.reason || "")}</td>
        <td class="nowrap">${escapeHtml(rec.approvalStatus || "")}</td>
        <td class="nowrap">${escapeHtml(CLASS_LABEL[auto] || auto)}</td>
        <td class="nowrap">
          <select data-rec-id="${escapeHtml(rec.id)}" data-field="finalClass">
            ${opt("auto", "자동")}
            ${opt("deemed", "출근간주")}
            ${opt("excluded", "산정제외")}
            ${opt("absence", "결근성")}
            ${opt("review", "검토")}
          </select>
        </td>
        <td class="center nowrap">
          <input type="checkbox" data-rec-id="${escapeHtml(rec.id)}" data-field="credit" ${rec.credit ? "checked":""} />
        </td>
        <td class="center nowrap">
          <button class="btn danger" data-rec-id="${escapeHtml(rec.id)}" data-field="delete">삭제</button>
        </td>
      </tr>
    `;
  }

  function safeFilename(s) {
    return String(s || "").replace(/[\\/:*?"<>|]/g, "_").slice(0, 60);
  }

  function ensureXLSX() {
    if (!window.XLSX) throw new Error("xlsx 라이브러리를 불러오지 못했습니다.");
  }

  function downloadWorkerDetailXlsx(workerKey) {
    ensureXLSX();

    const w = state.workers.get(workerKey);
    const rr = state.results.find(x => x.workerKey === workerKey);

    if (!w || !rr) {
      alert("개인별 상세를 저장하려면 먼저 계산을 실행해주세요.");
      return;
    }

    if (!state.calendar.sets) buildCalendarSets();
    const sets = state.calendar.sets;

    const dailyMinutes = rr.rates.dailyMinutes || Math.round(Number(w.dailyHours || DEFAULT_DAILY_HOURS) * 60);
    const records = state.records.filter(x => x.workerKey === workerKey).sort((a,b) => a.startUTC - b.startUTC);

    const sum = { deemed:0, excluded:0, absence:0, review:0, creditVac:0, total: sets.fullCount * dailyMinutes };
    for (const rec of records) {
      const cls = recordClass(rec);
      const mFull = computeRecordMinutesOnSet(rec, sets.fullSet, dailyMinutes);
      sum[cls] = (sum[cls] || 0) + mFull;

      if (rec.credit) {
        sum.creditVac += computeRecordMinutesOnSet(rec, sets.vacationSet, dailyMinutes);
      }
    }

    const leaveUsage = computeAnnualLeaveUsageSummary(workerKey, dailyMinutes);

    const rateSem = (rr.rates.rateSemester == null) ? "-" : pct(rr.rates.rateSemester);

    // 비상시근로자: 학기중 출근율 80% 이상이면 연간 출근율은 요약에서 숨김(혼동 방지)
    const hideFullRate = (w?.pattern === "emergency") && ((rr.rates.rateSemester ?? 0) >= 0.8);
    const rateFull = hideFullRate ? "" : pct(rr.rates.rateFull ?? 0);

    const rateProp = (rr.rates.rateProportional == null) ? "-" : pct(rr.rates.rateProportional);

    const finalText = (rr.finalHours > 0) ? `${rr.finalDays}일 ${rr.finalHours}시간` : `${rr.finalDays}일`;
    const stdText = formatStdCompact(rr);

    const ss = state.calendar.summerStart ? utcToYmd(state.calendar.summerStart) : "";
    const se = state.calendar.summerEnd ? utcToYmd(state.calendar.summerEnd) : "";
    const ws = state.calendar.winterStart ? utcToYmd(state.calendar.winterStart) : "";
    const we = state.calendar.winterEnd ? utcToYmd(state.calendar.winterEnd) : "";

    const wb = XLSX.utils.book_new();

    const rows1 = [];
    rows1.push(["항목","값"]);
    rows1.push(["나이스개인번호", w.key || ""]);
    rows1.push(["성명", w.name || ""]);
    rows1.push(["직군", w.group==="special" ? "특수운영직군" : "교육공무직"]);
    rows1.push(["근무형태", w.pattern==="emergency" ? "방학중비상시" : "상시"]);
    rows1.push(["최초임용일", w.hireDateUTC ? utcToYmd(w.hireDateUTC) : ""]);
    rows1.push(["1일 소정근로시간", String(w.dailyHours ?? DEFAULT_DAILY_HOURS)]);
    rows1.push(["근속연수(2026-03-01)", String(w.serviceYears ?? 0) + "년"]);
    rows1.push(["학사일정(여름)", (ss && se) ? `${ss}~${se}` : ""]);
    rows1.push(["학사일정(겨울)", (ws && we) ? `${ws}~${we}` : ""]);
    rows1.push(["출근율(학기중)", rateSem]);
    rows1.push(["출근율(연간)", rateFull]);
    rows1.push(["출근율(비례산정)", rateProp]);
    rows1.push(["기본연차(비상시 기본 12/11)", String(rr.baseDays ?? "")]);
    rows1.push(["출근가산(비상시80%→상시기본맞춤)", String(rr.bonusDays ?? 0)]);
    rows1.push(["근속가산(3년차부터 2년에 1일)", String(rr.addDays ?? 0)]);
    rows1.push(["기본+가산(상한25)", stdText]);
    rows1.push(["최종부여", finalText]);
    rows1.push(["판정", rr.method || ""]);
    rows1.push(["비고", rr.note || ""]);
    rows1.push(["연차 사용(완결만 집계)", fmtDHM(minutesToDHM(leaveUsage.total, dailyMinutes))]);
    rows1.push(["복무-산정제외(연간)", minutesToDays(sum.excluded, dailyMinutes)]);
    rows1.push(["복무-결근성(연간)", minutesToDays(sum.absence, dailyMinutes)]);
    rows1.push(["복무-출근간주(연간)", minutesToDays(sum.deemed, dailyMinutes)]);
    rows1.push(["복무-검토(연간)", minutesToDays(sum.review, dailyMinutes)]);
    if (w.pattern === "emergency") {
      rows1.push(["비상시 방학중 근무(분자 가산)", minutesToDays(sum.creditVac, dailyMinutes)]);
    }

    const ws1 = XLSX.utils.aoa_to_sheet(rows1);
    XLSX.utils.book_append_sheet(wb, ws1, "요약");

    const rows2 = [];
    rows2.push(["기간시작","기간종료","종별","사유","결재상태","자동분류","최종분류","방학중근무가산","분(저장값)","원본시간/일수","파일"]);
    for (const rec of records) {
      const auto = rec.autoClass || "review";
      const fin = rec.finalClass || "auto";
      rows2.push([
        utcToYmd(rec.startUTC),
        utcToYmd(rec.endUTC),
        rec.type || "",
        rec.reason || "",
        rec.approvalStatus || "",
        CLASS_LABEL[auto] || auto,
        fin === "auto" ? "자동" : (CLASS_LABEL[fin] || fin),
        rec.credit ? "Y" : "",
        (rec.minutes == null ? "" : rec.minutes),
        rec.rawDur || "",
        rec.sourceFile || ""
      ]);
    }

    const ws2 = XLSX.utils.aoa_to_sheet(rows2);
    XLSX.utils.book_append_sheet(wb, ws2, "복무내역");

    const out = XLSX.write(wb, { bookType: "xlsx", type: "array" });
    const blob = new Blob([out], { type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" });

    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `2026학년도_개인별상세_${safeFilename(w.name)}_${safeFilename(w.key)}.xlsx`;
    document.body.appendChild(a);
    a.click();
    a.remove();
  }

  function renderDetail() {
    const box = $("#detailBox");
    box.innerHTML = "";

    const resArr = state.results.slice().sort((a,b) => {
      const wa = state.workers.get(a.workerKey);
      const wb = state.workers.get(b.workerKey);
      return (wa?.name || "").localeCompare(wb?.name || "", "ko");
    });

    for (const rr of resArr) {
      const w = state.workers.get(rr.workerKey);
      const records = state.records.filter(x => x.workerKey === rr.workerKey).sort((a,b) => a.startUTC - b.startUTC);

      const sets = state.calendar.sets;
      const dailyMinutes = rr.rates.dailyMinutes || (Number(w?.dailyHours||DEFAULT_DAILY_HOURS)*60);

      const sum = { deemed:0, excluded:0, absence:0, review:0, creditVac:0, total:0 };
      if (sets) sum.total = sets.fullCount * dailyMinutes;

      for (const rec of records) {
        const cls = recordClass(rec);
        const mFull = sets ? computeRecordMinutesOnSet(rec, sets.fullSet, dailyMinutes) : 0;
        sum[cls] = (sum[cls] || 0) + mFull;

        if (rec.credit && sets) {
          sum.creditVac += computeRecordMinutesOnSet(rec, sets.vacationSet, dailyMinutes);
        }
      }

      const rateSem = (rr.rates.rateSemester == null) ? "-" : pct(rr.rates.rateSemester);

      // 비상시근로자: 학기중 출근율 80% 이상이면 연간 출근율은 상세에서도 숨김(혼동 방지)
      const hideFullRate = (w?.pattern === "emergency") && ((rr.rates.rateSemester ?? 0) >= 0.8);
      const rateFull = hideFullRate ? "" : pct(rr.rates.rateFull ?? 0);

      const rateProp = (rr.rates.rateProportional == null) ? "-" : pct(rr.rates.rateProportional);

      const rateLine = hideFullRate
        ? `학기중 ${rateSem} · 비례산정 ${rateProp}`
        : `학기중 ${rateSem} · 연간 ${rateFull} · 비례산정 ${rateProp}`;

      const final = (rr.finalHours > 0) ? `${rr.finalDays}일 ${rr.finalHours}시간` : `${rr.finalDays}일`;
      const stdCompact = formatStdCompact(rr);

      const stdParts = [];
      stdParts.push(`기본 ${rr.baseDays}일`);
      if (rr.bonusDays) stdParts.push(`출근가산 ${rr.bonusDays}일`);
      if (rr.addDays) stdParts.push(`근속가산 ${rr.addDays}일`);
      stdParts.push(`= ${rr.standardDays}일`);

      const leaveUsage = computeAnnualLeaveUsageSummary(rr.workerKey, dailyMinutes);

      const details = document.createElement("details");
      details.className = "card";
      details.open = false;

      details.innerHTML = `
        <summary>
          ${escapeHtml(w?.name || rr.workerKey)} (${escapeHtml(w?.key || rr.workerKey)})
          · <span class="pill">${w?.group==="special" ? "특수운영" : "교육공무직"}</span>
          · <span class="pill">${w?.pattern==="emergency" ? "비상시" : "상시"}</span>
          · 최종 <b>${final}</b> (${escapeHtml(rr.method)})
        </summary>

        <div class="row gap" style="margin-top:10px;">
          <button class="btn" data-action="downloadDetail" data-worker="${escapeHtml(rr.workerKey)}">개인별 상세 엑셀 저장</button>
        </div>

        <div style="margin-top:12px;" class="grid two">
          <div class="msg">
            <div><b>기본/가산</b>: ${escapeHtml(stdParts.join(" + "))} <span class="muted">(${escapeHtml(stdCompact)})</span> (상한25 적용)</div>
            <div><b>근속</b>: ${escapeHtml(String(w?.serviceYears ?? 0))}년 (기준일 2026-03-01)</div>
            <div><b>출근율</b>: ${rateLine}</div>
            <div><b>연차 사용(완결만)</b>: ${fmtDHM(minutesToDHM(leaveUsage.total, dailyMinutes))}</div>
            ${rr.note ? `<div class="muted">※ ${escapeHtml(rr.note)}</div>` : ""}
          </div>

          <div class="msg">
            <div><b>복무 분류 합계(연간 기준)</b></div>
            <ul>
              <li>산정제외: ${minutesToDays(sum.excluded, dailyMinutes)}</li>
              <li>결근성: ${minutesToDays(sum.absence, dailyMinutes)}</li>
              <li>출근간주: ${minutesToDays(sum.deemed, dailyMinutes)} <span class="muted">(정보성)</span></li>
              <li>검토: ${minutesToDays(sum.review, dailyMinutes)}</li>
              ${w?.pattern==="emergency" ? `<li>비상시직종 방학중 근무 (분자 가산): ${minutesToDays(sum.creditVac, dailyMinutes)}</li>` : ""}
            </ul>
            <div class="muted">※애매한 건 검토 필요로 분류함.</div>
          </div>
        </div>

        <hr />

        <h4>복무 전체 목록(최종분류 수정 가능)</h4>
        <div class="table-wrap">
          <table class="sheetlike table-compact">
            <thead>
              <tr>
                <th class="nowrap">기간</th>
                <th class="nowrap">종별</th>
                <th class="nowrap">사유</th>
                <th class="nowrap">결재상태</th>
                <th class="nowrap">자동</th>
                <th class="nowrap">최종</th>
                <th class="nowrap">비상시직종방학추가근무</th>
                <th class="nowrap center">삭제</th>
              </tr>
            </thead>
            <tbody>
              ${records.map(rec => renderRecordRow(rec)).join("")}
            </tbody>
          </table>
        </div>
      `;

      box.appendChild(details);
    }

    box.querySelectorAll("[data-rec-id]").forEach(el => {
      const rid = el.getAttribute("data-rec-id");
      const field = el.getAttribute("data-field");

      if (field === "finalClass") {
        el.addEventListener("change", () => {
          const rec = state.records.find(x => x.id === rid);
          if (!rec) return;
          const v = el.value;
          rec.finalClass = (v === "auto") ? null : v;
          runCalculation();
        });
      }

      if (field === "credit") {
        el.addEventListener("change", () => {
          const rec = state.records.find(x => x.id === rid);
          if (!rec) return;
          rec.credit = !!el.checked;
          runCalculation();
        });
      }

      if (field === "delete") {
        el.addEventListener("click", () => {
          state.records = state.records.filter(x => x.id !== rid);
          runCalculation();
        });
      }
    });

    box.querySelectorAll("button[data-action='downloadDetail']").forEach(btn => {
      btn.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        const wk = btn.getAttribute("data-worker");
        if (!wk) return;
        try { downloadWorkerDetailXlsx(wk); } catch (err) { alert(err.message); }
      });
    });
  }

  // 결과표: 나이스 개인번호 열 표시 토글(기본 숨김)
  function setResultPidVisibility(show) {
    const wrap = $("#resultTableWrap");
    if (!wrap) return;
    wrap.classList.toggle("show-pid", !!show);
    wrap.classList.toggle("hide-pid", !show);
  }

  function renderResults() {
    const tbody = $("#resultTable tbody");
    tbody.innerHTML = "";

    const detailNotice = $("#detailNotice");

    if (!state.results || state.results.length === 0) {
      setMsg($("#resultSummary"), "warn", "계산 결과가 없습니다. <b>계산 실행</b>을 먼저 수행하세요.");
      $("#detailBox").innerHTML = "";
      detailNotice.classList.add("hidden");
      return;
    }

    detailNotice.classList.remove("hidden");

    const resArr = state.results.slice().sort((a,b) => {
      const wa = state.workers.get(a.workerKey);
      const wb = state.workers.get(b.workerKey);
      return (wa?.name || "").localeCompare(wb?.name || "", "ko");
    });

    setMsg($("#resultSummary"), "ok", `
      <div><b>계산 완료</b> · 대상자 ${resArr.length}명 · 실행시각: ${escapeHtml(new Date(state.lastRunAt).toLocaleString())}</div>
      <div class="muted">※ 상세에서 복무 자동분류를 <b>최종분류로 수정</b>하면 즉시 재계산됩니다.</div>
    `);

    for (const r of resArr) {
      const w = state.workers.get(r.workerKey);

      const rateSem = (r.rates.rateSemester == null) ? "-" : pct(r.rates.rateSemester);

      // 비상시근로자: 학기중 출근율 80% 이상이면 연간 출근율은 결과표에서 숨김(혼동 방지)
      const hideFullRate = (w?.pattern === "emergency") && ((r.rates.rateSemester ?? 0) >= 0.8);
      const rateFull = hideFullRate ? "" : pct(r.rates.rateFull ?? 0);

      const rateProp = (r.rates.rateProportional == null) ? "-" : pct(r.rates.rateProportional);

      const baseDays = (r.baseDays ?? 0);
      const bonusDays = (r.bonusDays ?? 0);
      const addDays = (r.addDays ?? 0);
      const standardDays = (r.standardDays ?? 0);

      const final = (r.finalHours > 0) ? `${r.finalDays}일 ${r.finalHours}시간` : `${r.finalDays}일`;

      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td class="nowrap col-pid">${escapeHtml(w?.key || r.workerKey)}</td>
        <td class="nowrap col-name">${escapeHtml(w?.name || "")}</td>
        <td class="nowrap">${w?.group==="special" ? "특수운영" : "교육공무직"}</td>
        <td class="nowrap">${w?.pattern==="emergency" ? "비상시" : "상시"}</td>
        <td class="right nowrap">${escapeHtml(String(w?.serviceYears ?? 0))}년</td>
        <td class="right nowrap">${rateSem}</td>
        <td class="right nowrap">${rateFull}</td>
        <td class="right nowrap">${rateProp}</td>
        <td class="right nowrap">${escapeHtml(String(baseDays))}</td>
        <td class="right nowrap">${escapeHtml(String(bonusDays))}</td>
        <td class="right nowrap">${escapeHtml(String(addDays))}</td>
        <td class="right nowrap">${escapeHtml(String(standardDays))}</td>
        <td class="right nowrap"><b>${final}</b></td>
        <td class="nowrap">${escapeHtml(r.method)}</td>
      `;
      tbody.appendChild(tr);
    }

    renderDetail();
  }

  function readFileAsArrayBuffer(file) {
    return new Promise((resolve, reject) => {
      const fr = new FileReader();
      fr.onload = () => resolve(fr.result);
      fr.onerror = () => reject(new Error("파일 읽기 실패"));
      fr.readAsArrayBuffer(file);
    });
  }

  function sheetToJson(workbook) {
    const sheetName = workbook.SheetNames[0];
    const ws = workbook.Sheets[sheetName];
    return XLSX.utils.sheet_to_json(ws, { header: 1, raw: false, defval: "" });
  }

  function normalizeHeader(s) {
    return String(s || "").replace(/\s+/g, "").replace(/[()]/g, "").toLowerCase();
  }

  function findHeaderRow(rows, mustHaveAny) {
    let bestIdx = -1;
    let bestScore = -1;

    for (let i = 0; i < Math.min(rows.length, 30); i++) {
      const row = rows[i];
      if (!Array.isArray(row)) continue;

      const nh = row.map(normalizeHeader);
      const joined = nh.join("|");

      const hit = mustHaveAny.some(k => joined.includes(normalizeHeader(k)));
      if (!hit) continue;

      const score = nh.filter(x => x && x.length >= 2).length;
      if (score > bestScore) {
        bestScore = score;
        bestIdx = i;
      }
    }
    return bestIdx;
  }

  function findColumnIndex(headers, candidates) {
    const nh = headers.map(normalizeHeader);
    for (const c of candidates) {
      const nc = normalizeHeader(c);
      const idx = nh.findIndex(h => h === nc);
      if (idx >= 0) return idx;
    }
    for (const c of candidates) {
      const nc = normalizeHeader(c);
      const idx = nh.findIndex(h => h.includes(nc) || nc.includes(h));
      if (idx >= 0) return idx;
    }
    return -1;
  }

  function parseDateLoose(v) {
    const s = String(v || "").trim();
    if (!s) return null;

    const m = s.match(/(\d{4})[.\-/](\d{1,2})[.\-/](\d{1,2})/);
    if (m) {
      const y = Number(m[1]);
      const mo = Number(m[2]);
      const d = Number(m[3]);
      return new Date(Date.UTC(y, mo - 1, d));
    }
    return null;
  }

  function computeServiceYears(hireUTC) {
    if (!hireUTC) return 0;
    const diff = GRANT_DATE.getTime() - hireUTC.getTime();
    if (diff <= 0) return 0;
    const years = diff / (365.2425 * 86400000);
    return Math.floor(years + 1e-9);
  }

  function computeAddDays(serviceYears) {
    if (!serviceYears || serviceYears < 3) return 0;
    return Math.floor((serviceYears - 1) / 2) - 1;
  }

  function upsertWorker(worker) {
    state.workers.set(worker.key, worker);
  }

  function removeWorker(workerKey) {
    state.workers.delete(workerKey);
    state.records = state.records.filter(r => r.workerKey !== workerKey);
    state.results = state.results.filter(r => r.workerKey !== workerKey);
  }

  function renderWorkerSelect() {
    const sel = $("#wSelect");
    sel.innerHTML = "";

    const workers = Array.from(state.workers.values()).sort((a,b) => (a.name || "").localeCompare(b.name || "", "ko"));
    for (const w of workers) {
      const opt = document.createElement("option");
      opt.value = w.key;
      opt.textContent = `${w.name || "(이름없음)"} (${w.key})`;
      sel.appendChild(opt);
    }
  }

  function renderWorkersTable() {
    const tbody = $("#workersTable tbody");
    tbody.innerHTML = "";

    const workers = Array.from(state.workers.values()).sort((a,b) => (a.name || "").localeCompare(b.name || "", "ko"));

    for (const w of workers) {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td class="nowrap">${escapeHtml(w.name || "")}</td>
        <td class="nowrap">${escapeHtml(w.key || "")}</td>
        <td class="nowrap">${w.group==="special" ? "특수운영" : "교육공무직"}</td>
        <td class="nowrap">${w.pattern==="emergency" ? "비상시" : "상시"}</td>
        <td class="nowrap">${w.hireDateUTC ? utcToYmd(w.hireDateUTC) : ""}</td>
        <td class="right nowrap">${escapeHtml(String(w.dailyHours ?? DEFAULT_DAILY_HOURS))}</td>
        <td class="right nowrap">${escapeHtml(String(w.serviceYears ?? 0))}년</td>
        <td class="center nowrap"><button class="btn danger" data-worker="${escapeHtml(w.key)}">삭제</button></td>
      `;
      tr.querySelector("button").addEventListener("click", () => {
        removeWorker(w.key);
        renderWorkersTable();
        renderWorkerSelect();
        renderResults();
      });
      tbody.appendChild(tr);
    }
  }

  function addRecord(rec) {
    const id = "rec_" + Math.random().toString(36).slice(2,10) + Date.now().toString(36);
    state.records.push({
      id,
      workerKey: rec.workerKey,
      startUTC: rec.startUTC,
      endUTC: rec.endUTC,
      type: rec.type || "",
      reason: rec.reason || "",
      autoClass: rec.autoClass || null,
      finalClass: rec.finalClass || null,
      credit: !!rec.credit,
      approvalStatus: rec.approvalStatus || "",
      rawDur: rec.rawDur || "",
      sourceFile: rec.sourceFile || ""
    });
  }

  function applyCalendar() {
    state.calendar.summerStart = $("#summerStart").value ? ymdToUTC($("#summerStart").value) : null;
    state.calendar.summerEnd   = $("#summerEnd").value ? ymdToUTC($("#summerEnd").value) : null;
    state.calendar.winterStart = $("#winterStart").value ? ymdToUTC($("#winterStart").value) : null;
    state.calendar.winterEnd   = $("#winterEnd").value ? ymdToUTC($("#winterEnd").value) : null;

    state.calendar.applied = true;
    buildCalendarSets();
    renderCalendarSummary();
  }

  function clearCalendar() {
    $("#summerStart").value = "";
    $("#summerEnd").value = "";
    $("#winterStart").value = "";
    $("#winterEnd").value = "";

    state.calendar.summerStart = null;
    state.calendar.summerEnd = null;
    state.calendar.winterStart = null;
    state.calendar.winterEnd = null;
    state.calendar.applied = false;

    buildCalendarSets();
    renderCalendarSummary();
  }

  function bindModeRadios() {
    $$("input[name='hrMode']").forEach(r => {
      r.addEventListener("change", () => {
        const mode = $$("input[name='hrMode']").find(x => x.checked)?.value || "file";
        $("#hrFileBox").classList.toggle("hidden", mode !== "file");
        $("#hrManualBox").classList.toggle("hidden", mode !== "manual");
      });
    });

    $$("input[name='workMode']").forEach(r => {
      r.addEventListener("change", () => {
        const mode = $$("input[name='workMode']").find(x => x.checked)?.value || "file";
        $("#workFileBox").classList.toggle("hidden", mode !== "file");
        $("#workManualBox").classList.toggle("hidden", mode !== "manual");
      });
    });
  }

  function bindDropZone(zoneEl, inputEl, onFiles) {
    zoneEl.addEventListener("click", () => inputEl.click());

    ["dragenter","dragover"].forEach(evt => {
      zoneEl.addEventListener(evt, (e) => {
        e.preventDefault();
        e.stopPropagation();
        zoneEl.classList.add("dragover");
      });
    });

    ["dragleave","drop"].forEach(evt => {
      zoneEl.addEventListener(evt, (e) => {
        e.preventDefault();
        e.stopPropagation();
        zoneEl.classList.remove("dragover");
      });
    });

    zoneEl.addEventListener("drop", (e) => {
      const files = Array.from(e.dataTransfer.files || []);
      if (files.length) onFiles(files);
    });

    inputEl.addEventListener("change", () => {
      const files = Array.from(inputEl.files || []);
      if (files.length) onFiles(files);
    });
  }

  async function loadHRFiles(files) {
    if (!files.length) throw new Error("파일이 없습니다.");

    let added = 0;

    for (const f of files) {
      const buf = await readFileAsArrayBuffer(f);
      const wb = XLSX.read(buf, { type: "array" });
      const rows = sheetToJson(wb);

      const hRow = findHeaderRow(rows, ["성명", "이름", "개인번호", "사번"]);
      if (hRow < 0) continue;
      const headers = rows[hRow];

      const idxName = findColumnIndex(headers, ["성명","이름"]);
      const idxPid  = findColumnIndex(headers, ["개인번호","사번","나이스개인번호"]);
      const idxHire = findColumnIndex(headers, ["최초임용일","임용일","최초임용"]);
      const idxGroup = findColumnIndex(headers, ["직군","직종","직종명"]);
      const idxPattern = findColumnIndex(headers, ["근무형태","상시/비상시","근무구분"]);
      const idxDailyHours = findColumnIndex(headers, ["1일시간","1일소정근로시간","소정근로시간"]);

      for (let i = hRow + 1; i < rows.length; i++) {
        const row = rows[i];
        if (!row || !row.length) continue;

        const name = String(row[idxName] || "").trim();
        const pid  = String(row[idxPid] || "").trim();
        if (!pid) continue;

        const hireDateUTC = parseDateLoose(row[idxHire]);
        const serviceYears = computeServiceYears(hireDateUTC);
        const addDays = computeAddDays(serviceYears);

        const gRaw = String(row[idxGroup] || "").replace(/\s+/g, "");
        const pRaw = String(row[idxPattern] || "").replace(/\s+/g, "");
        const group = (gRaw.includes("특수") || gRaw.includes("운영")) ? "special" : "edu";
        const pattern = (pRaw.includes("비상") || pRaw.includes("방학")) ? "emergency" : "always";

        const dailyHours = Number(row[idxDailyHours] || DEFAULT_DAILY_HOURS) || DEFAULT_DAILY_HOURS;

        upsertWorker({
          key: pid,
          name,
          group,
          pattern,
          hireDateUTC,
          dailyHours,
          serviceYears,
          addDays,
        });
        added += 1;
      }
    }

    renderWorkersTable();
    renderWorkerSelect();
    return { added };
  }

  function autoClassify(type, reason) {
    const txt = (String(type || "") + " " + String(reason || "")).replace(/\s+/g, "");
    if (!txt) return "review";

    const hit = (arr) => arr.some(k => txt.includes(k.replace(/\s+/g, "")));

    if (hit(RULES_2026.excludedKeywords)) return "excluded";
    if (hit(RULES_2026.absenceKeywords)) return "absence";
    if (hit(RULES_2026.deemedKeywords)) return "deemed";
    if (hit(RULES_2026.creditKeywords)) return "deemed";
    if (hit(RULES_2026.reviewKeywords)) return "review";
    return "review";
  }

  async function loadWorkFiles(files) {
    if (!files.length) throw new Error("파일이 없습니다.");

    let totalRows = 0;
    let totalRecs = 0;
    let createdWorkers = 0;

    let annualCandidate = 0;
    let annualApproved = 0;
    let annualExcludedByStatus = 0;

    for (const f of files) {
      const buf = await readFileAsArrayBuffer(f);
      const wb = XLSX.read(buf, { type: "array" });
      const rows = sheetToJson(wb);

      const hRow = findHeaderRow(rows, ["개인번호", "성명", "근무상황", "복무"]);
      if (hRow < 0) continue;

      const headers = rows[hRow];
      const idxPid  = findColumnIndex(headers, ["개인번호","사번","나이스개인번호"]);
      const idxName = findColumnIndex(headers, ["성명","이름"]);
      const idxStart = findColumnIndex(headers, ["시작일", "기간시작", "시작"]);
      const idxEnd = findColumnIndex(headers, ["종료일", "기간종료", "종료"]);
      const idxType = findColumnIndex(headers, ["근무상황", "복무", "종별", "구분"]);
      const idxReason = findColumnIndex(headers, ["사유", "내용"]);
      const idxApproval = findColumnIndex(headers, ["결재상태", "상태", "승인"]);

      const idxDur = findColumnIndex(headers, ["시간", "일수", "기간", "사용"]);
      totalRows += Math.max(0, rows.length - (hRow + 1));

      for (let i = hRow + 1; i < rows.length; i++) {
        const row = rows[i];
        if (!row || !row.length) continue;

        const pid = String(row[idxPid] || "").trim();
        if (!pid) continue;
        const name = String(row[idxName] || "").trim();

        let w = state.workers.get(pid);
        if (!w) {
          upsertWorker({
            key: pid,
            name: name || "",
            group: "edu",
            pattern: "always",
            hireDateUTC: null,
            dailyHours: DEFAULT_DAILY_HOURS,
            serviceYears: 0,
            addDays: 0,
          });
          createdWorkers += 1;
          w = state.workers.get(pid);
        } else if (!w.name && name) {
          w.name = name;
        }

        const s = parseDateLoose(row[idxStart]);
        const e = parseDateLoose(row[idxEnd]);
        if (!s || !e) continue;

        const type = String(row[idxType] || "").trim();
        const reason = String(row[idxReason] || "").trim();
        const approvalStatus = String(row[idxApproval] || "").trim();
        const rawDur = String(row[idxDur] || "").trim();

        const auto = autoClassify(type, reason);

        addRecord({
          workerKey: pid,
          startUTC: s,
          endUTC: e,
          type,
          reason,
          autoClass: auto,
          finalClass: null,
          credit: false,
          approvalStatus,
          rawDur,
          sourceFile: f.name
        });
        totalRecs += 1;

        const kind = classifyAnnualLeaveKind(type);
        if (kind) {
          annualCandidate += 1;
          if (isFinalApprovedStatus(approvalStatus)) annualApproved += 1;
          else annualExcludedByStatus += 1;
        }
      }
    }

    renderWorkerSelect();
    renderWorkersTable();
    state.results = [];
    renderResults();

    return { totalRows, totalRecs, createdWorkers, annualCandidate, annualApproved, annualExcludedByStatus };
  }

  function downloadXlsx() {
    ensureXLSX();

    if (!state.results || state.results.length === 0) {
      alert("계산 결과가 없습니다. 먼저 계산 실행을 눌러주세요.");
      return;
    }

    const wb = XLSX.utils.book_new();

    const rows1 = [];
    rows1.push([
      "나이스개인번호","성명","직군","근무형태","최초임용일","근속(2026-03-01)",
      "출근율(학기중)","출근율(연간)","출근율(비례산정)",
      "기본","출근가산(비상시80%→상시기본맞춤)","근속가산","표준합계(상한적용)",
      "최종부여(일)","최종부여(시간)","판정","비고"
    ]);

    for (const r of state.results) {
      const w = state.workers.get(r.workerKey);

      // 비상시근로자: 학기중 출근율 80% 이상이면 연간 출근율은 빈칸 처리(혼동 방지)
      const hideFullRate = (w?.pattern === "emergency") && ((r.rates.rateSemester ?? 0) >= 0.8);

      rows1.push([
        w?.key || r.workerKey,
        w?.name || "",
        w?.group==="special" ? "특수운영직군" : "교육공무직",
        w?.pattern==="emergency" ? "방학중비상시" : "상시",
        w?.hireDateUTC ? utcToYmd(w.hireDateUTC) : "",
        w?.serviceYears ?? 0,
        r.rates.rateSemester==null ? "" : pctValue(r.rates.rateSemester),
        hideFullRate ? "" : pctValue(r.rates.rateFull ?? 0),
        r.rates.rateProportional==null ? "" : pctValue(r.rates.rateProportional),
        r.baseDays,
        r.bonusDays ?? 0,
        r.addDays,
        r.standardDays,
        r.finalDays,
        r.finalHours,
        r.method,
        r.note || ""
      ]);
    }

    const ws1 = XLSX.utils.aoa_to_sheet(rows1);
    XLSX.utils.book_append_sheet(wb, ws1, "연차부여결과");

    const rows2 = [];
    rows2.push([
      "나이스개인번호","성명","기간시작","기간종료","종별","사유","결재상태",
      "자동분류","최종분류","방학중근무(비상시직종)","분(저장값)","원본시간/일수","파일"
    ]);

    for (const rec of state.records) {
      const w = state.workers.get(rec.workerKey);
      const auto = rec.autoClass || "review";
      const fin = rec.finalClass || "auto";
      rows2.push([
        rec.workerKey,
        w?.name || "",
        utcToYmd(rec.startUTC),
        utcToYmd(rec.endUTC),
        rec.type || "",
        rec.reason || "",
        rec.approvalStatus || "",
        CLASS_LABEL[auto] || auto,
        fin === "auto" ? "자동" : (CLASS_LABEL[fin] || fin),
        rec.credit ? "Y" : "",
        rec.minutes == null ? "" : rec.minutes,
        rec.rawDur || "",
        rec.sourceFile || ""
      ]);
    }

    const ws2 = XLSX.utils.aoa_to_sheet(rows2);
    XLSX.utils.book_append_sheet(wb, ws2, "복무취합(전체)");

    const rows3 = [];
    rows3.push(["나이스개인번호","성명","연차사용(완결만)_분","연차사용(완결만)_표시","연차","반일연차","연차(지각)","연차(조퇴)","연차(외출)"]);

    const workersSorted = Array.from(state.workers.values()).sort((a,b) => (a.name||"").localeCompare(b.name||"", "ko"));
    for (const w of workersSorted) {
      const dailyMinutes = Math.round(Number(w.dailyHours || DEFAULT_DAILY_HOURS) * 60);
      const usage = computeAnnualLeaveUsageSummary(w.key, dailyMinutes);

      const toText = (mins) => fmtDHM(minutesToDHM(mins, dailyMinutes));

      rows3.push([
        w.key,
        w.name || "",
        usage.total,
        toText(usage.total),
        toText(usage.byKind.FULL),
        toText(usage.byKind.HALF),
        toText(usage.byKind.LATE),
        toText(usage.byKind.EARLY),
        toText(usage.byKind.OUT)
      ]);
    }

    const ws3 = XLSX.utils.aoa_to_sheet(rows3);
    XLSX.utils.book_append_sheet(wb, ws3, "연차사용(완결만)");

    const out = XLSX.write(wb, { bookType: "xlsx", type: "array" });
    const blob = new Blob([out], { type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" });

    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "2026학년도_연차휴가_부여일수_계산결과.xlsx";
    document.body.appendChild(a);
    a.click();
    a.remove();
  }

  function runCalculation() {
    if (!state.calendar.sets) buildCalendarSets();

    const workers = Array.from(state.workers.values());
    if (workers.length === 0) {
      setMsg($("#runMsg"), "err", "대상자가 없습니다. 인사정보를 먼저 입력하세요.");
      state.results = [];
      renderResults();
      return;
    }

    const hasEmergency = workers.some(w => w.pattern === "emergency");
    if (hasEmergency && !state.calendar.applied) {
      setMsg($("#runMsg"), "warn", `
        <div class="warn-line">
          <b>경고</b>: 비상시근로자가 포함되어 있으나 학사일정이 입력되지 않았습니다.<br/>
          비상시직종의 출근율 및 방학중 추가근무로 인한 출근율 산정 정확도가 떨어질 수 있습니다.
        </div>
      `);
    } else {
      setMsg($("#runMsg"), "ok", "계산 들어갑니다.");
    }

    state.results = workers.map(w => calcGrantForWorker(w));
    state.lastRunAt = Date.now();

    renderResults();
  }

  function bindEvents() {
    bindModeRadios();

    $("#btnApplyCalendar").addEventListener("click", () => {
      applyCalendar();
      setMsg($("#calendarMsg"), "ok", "학사일정을 적용했습니다.");
    });

    $("#btnClearCalendar").addEventListener("click", () => {
      clearCalendar();
      setMsg($("#calendarMsg"), "warn", "학사일정을 초기화했습니다.");
    });

    bindDropZone($("#hrDrop"), $("#hrFiles"), (files) => {
      state.selectedFiles.hr = files;
      setMsg($("#hrMsg"), "ok", `${files.length}개 파일 선택됨`);
    });

    bindDropZone($("#workDrop"), $("#workFiles"), (files) => {
      state.selectedFiles.work = files;
      setMsg($("#workMsg"), "ok", `${files.length}개 파일 선택됨`);
    });

    $("#btnLoadHR").addEventListener("click", async () => {
      const files = (state.selectedFiles.hr && state.selectedFiles.hr.length)
        ? state.selectedFiles.hr
        : Array.from($("#hrFiles").files || []);

      if (!files.length) { setMsg($("#hrMsg"), "err", "인사정보 파일을 선택하세요."); return; }

      try {
        const out = await loadHRFiles(files);
        setMsg($("#hrMsg"), "ok", `<b>인사정보 불러오기 완료</b> · ${out.added}명 반영`);
      } catch (e) {
        setMsg($("#hrMsg"), "err", `<b>오류</b>: ${escapeHtml(e.message)}`);
      }
    });

    $("#btnClearWorkers").addEventListener("click", () => {
      state.workers.clear();
      state.records = [];
      renderWorkersTable();
      renderWorkerSelect();
      setMsg($("#hrMsg"), "warn", "전체 삭제 완료");
    });
    $("#btnClearWorkers2").addEventListener("click", () => {
      state.workers.clear();
      state.records = [];
      renderWorkersTable();
      renderWorkerSelect();
      setMsg($("#hrManualMsg"), "warn", "전체 삭제 완료");
    });

    $("#btnAddWorker").addEventListener("click", () => {
      const group = $("#mGroup").value;
      const pattern = $("#mPattern").value;
      const hireDateUTC = $("#mHire").value ? ymdToUTC($("#mHire").value) : null;

      const pid = String($("#mPid").value || "").trim();
      const name = String($("#mName").value || "").trim();
      if (!pid) { setMsg($("#hrManualMsg"), "err", "개인번호는 필수입니다."); return; }

      const dailyHours = Number($("#mDailyHours").value || DEFAULT_DAILY_HOURS) || DEFAULT_DAILY_HOURS;
      const serviceYears = computeServiceYears(hireDateUTC);
      const addDays = computeAddDays(serviceYears);

      upsertWorker({
        key: pid,
        name,
        group,
        pattern,
        hireDateUTC,
        dailyHours,
        serviceYears,
        addDays,
      });

      $("#mName").value = "";
      $("#mPid").value = "";

      renderWorkersTable();
      renderWorkerSelect();
      setMsg($("#hrManualMsg"), "ok", "대상자를 추가했습니다.");
    });

    $("#btnClearWorkers").addEventListener("click", () => {
      state.workers.clear();
      state.records = [];
      renderWorkersTable();
      renderWorkerSelect();
      setMsg($("#hrManualMsg"), "warn", "전체 삭제 완료");
    });

    $("#btnLoadWork").addEventListener("click", async () => {
      const files = (state.selectedFiles.work && state.selectedFiles.work.length)
        ? state.selectedFiles.work
        : Array.from($("#workFiles").files || []);

      if (!files.length) { setMsg($("#workMsg"), "err", "근무상황 파일을 선택하세요."); return; }

      try {
        const out = await loadWorkFiles(files);
        setMsg($("#workMsg"), "ok", `
          <div><b>근무상황 파일 불러오기 완료</b></div>
          <ul>
            <li>처리 파일: ${files.length}개</li>
            <li>전체 행(대략): ${out.totalRows.toLocaleString("ko-KR")}행</li>
            <li>복무사항 추출(전체): ${out.totalRecs.toLocaleString("ko-KR")}건</li>
            <li>인사정보가 없어서 임시로 생성: ${out.createdWorkers.toLocaleString("ko-KR")}명</li>
            <li><b>연차 집계 후보</b>: ${out.annualCandidate.toLocaleString("ko-KR")}건</li>
            <li><b>연차 집계(완결만)</b>: ${out.annualApproved.toLocaleString("ko-KR")}건</li>
            <li>연차 제외(결재상태 미완결): ${out.annualExcludedByStatus.toLocaleString("ko-KR")}건</li>
          </ul>
          <div class="muted">※ 임시 생성자의 직군, 근무형태, 최초임용일 등의 인사 정보는 필요시 수기 입력하십시오.</div>
        `);
      } catch (e) {
        setMsg($("#workMsg"), "err", `<b>오류</b>: ${escapeHtml(e.message)}`);
      }
    });

    $("#btnClearWork").addEventListener("click", () => {
      state.records = [];
      state.results = [];
      state.selectedFiles.work = [];
      renderResults();
      setMsg($("#workMsg"), "warn", "복무사항 초기화 완료");
    });

    $("#btnAddRecord").addEventListener("click", () => {
      const wk = $("#wSelect").value;
      if (!wk) { setMsg($("#workManualMsg"), "err", "대상자를 선택해주십시오."); return; }

      const s = $("#wStart").value ? ymdToUTC($("#wStart").value) : null;
      const e = $("#wEnd").value ? ymdToUTC($("#wEnd").value) : null;
      if (!s || !e) { setMsg($("#workManualMsg"), "err", "시작일자와 종료일자는 필수 입력사항입니다."); return; }

      const type = $("#wType").value.trim();
      const reason = $("#wReason").value.trim();
      const clsMode = $("#wClass").value;
      const credit = $("#wCredit").checked;

      try {
        addRecord({
          workerKey: wk,
          startUTC: s,
          endUTC: e,
          type,
          reason,
          finalClass: clsMode === "auto" ? null : clsMode,
          credit,
          approvalStatus: "",
          rawDur: "",
          sourceFile: "수기입력"
        });
        setMsg($("#workManualMsg"), "ok", "복무 항목을 추가했습니다.");
        $("#wType").value = "";
        $("#wReason").value = "";
      } catch (err) {
        setMsg($("#workManualMsg"), "err", `<b>오류</b>: ${escapeHtml(err.message)}`);
      }
    });

    $("#btnClearManualRecords").addEventListener("click", () => {
      state.records = [];
      setMsg($("#workManualMsg"), "warn", "전체 삭제 완료");
    });

    // 결과표: 나이스 개인번호 열 표시 토글(기본 숨김)
    const chkShowPid = $("#chkShowPid");
    if (chkShowPid) {
      chkShowPid.addEventListener("change", () => setResultPidVisibility(chkShowPid.checked));
    }

    $("#btnRun").addEventListener("click", runCalculation);

    $("#btnDownload").addEventListener("click", () => {
      try { downloadXlsx(); } catch (e) { alert(e.message); }
    });
  }

  function init() {
    setMsg($("#hrMsg"), "", "인사정보를 입력해주세요.");
    setMsg($("#workMsg"), "", "근무상황을 입력해주세요.");
    setMsg($("#runMsg"), "", "인사 및 복무사항 입력 후 계산 버튼을 눌러주세요.");

    buildCalendarSets();
    renderCalendarSummary();
    renderWorkerSelect();

    // 결과표 기본 설정: 개인번호 숨김(체크박스 기본 해제)
    const chkShowPid = $("#chkShowPid");
    if (chkShowPid) chkShowPid.checked = false;
    setResultPidVisibility(false);

    bindEvents();
    renderWorkersTable();
    renderResults();
  }

  init();

})();
</script>

<script src="/static/global-loader.js?v=1"></script>
<script src="/static/footer.js"></script>
<script src="/static/disable-copy.js"></script>

</body>
</html>