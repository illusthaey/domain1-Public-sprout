<!doctype html>

<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>학교별 전입·전출 인사발령자 명단 집계기</title>
  <link id="commonStyle" rel="stylesheet" href="/static/style.css" />
  <script>
    (function () {
      const link = document.getElementById("commonStyle");
      if (!link) return;
      link.addEventListener("error", function () {
        const alt = document.createElement("link");
        alt.rel = "stylesheet";
        alt.href = "static/style.css";
        document.head.appendChild(alt);
        console.warn("[style] /static/style.css 로드 실패 → static/style.css 로 폴백");
      });
    })();
  </script>
  <style>
    :root{
      --bg:#ffffff;
      --ink:#111827;
      --muted:#6b7280;
      --line:#e5e7eb;
      --card:#ffffff;
      --soft:#f9fafb;
      --red:#b91c1c;
      --blue:#1d4ed8;
      --green:#047857;
      --amber:#b45309;
    }
    body{ margin:0; background:var(--bg); color:var(--ink); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple SD Gothic Neo","Noto Sans KR","Malgun Gothic",sans-serif; }
    .shell{ max-width: 1100px; margin:0 auto; padding: 0 16px; }
    .container{ max-width: 1100px; margin: 0 auto; padding: 0 16px 36px; }
    .site-header{ padding: 22px 0 10px; border-bottom:1px solid var(--line); background:#fff; }
    .site-header h1{ margin:0; font-size: 1.55rem; }
    .subtitle{ margin: 8px 0 0; color: var(--muted); line-height: 1.55; text-align:left; }

    .tool-card{ margin: 18px 0; padding: 14px; border:1px solid var(--line); border-radius: 14px; background: var(--card); }
    .tool-head{ display:flex; align-items:flex-start; justify-content:space-between; gap: 12px; flex-wrap: wrap; }
    .tool-title{ margin:0; font-size: 1.15rem; }
    .tool-sub{ margin: 6px 0 0; color: var(--muted); }

    hr{ border:0; border-top:1px solid var(--line); margin: 14px 0; }

    .btn-row{ display:flex; gap:10px; flex-wrap: wrap; justify-content:flex-start; align-items:center; }
    .btn{ appearance:none; border:1px solid var(--line); background: #fff; padding: 9px 12px; border-radius: 10px; cursor:pointer; font-weight: 600; }
    .btn.primary{ background:#111827; color:#fff; border-color:#111827; }
    .btn.ghost{ background: transparent; }
    .btn:disabled{ opacity: .55; cursor:not-allowed; }

    .field{ margin: 10px 0; }
    .field label{ display:block; font-weight: 700; margin-bottom: 6px; }
    .field .help{ color: var(--muted); font-size: .92rem; }

    input[type="text"], textarea, select{
      width: 100%;
      max-width: 100%;
      box-sizing: border-box;
      padding: 10px 12px;
      border:1px solid var(--line);
      border-radius: 10px;
      background:#fff;
      font-size: 1rem;
      color: var(--ink);
      min-width: 0;
    }
    select{
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    select option{
      white-space: normal;
      word-break: break-word;
      max-width: 100%;
    }
    textarea{ resize: vertical; min-height: 92px; }

    .row{ display:flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .row.stretch > *{ flex: 1 1 260px; min-width: 0; }
    .between{ justify-content: space-between; }

    .pill{
      display:inline-block;
      padding: 2px 10px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: var(--soft);
      font-size: 0.9rem;
      line-height: 1.4;
      white-space: nowrap;
    }
    .pill.red{ border-color: #fecaca; background:#fef2f2; color:#991b1b; }
    .pill.blue{ border-color: #bfdbfe; background:#eff6ff; color:#1d4ed8; }
    .pill.green{ border-color: #bbf7d0; background:#f0fdf4; color:#047857; }
    .pill.amber{ border-color: #fed7aa; background:#fff7ed; color:#9a3412; }
    .pill.gray{ border-color: #e5e7eb; background:#f9fafb; color:#6b7280; }

    .muted{ color: var(--muted); }

    .dropzone{
      border: 2px dashed #cbd5e1;
      background: #f8fafc;
      padding: 18px 14px;
      border-radius: 14px;
      text-align:left;
      cursor:pointer;
      outline: none;
    }
    .dropzone strong{ display:block; margin-bottom: 6px; }
    .dropzone.dragover{ border-color: #111827; background: #eef2ff; }

    details{ border:1px solid var(--line); border-radius: 12px; padding: 10px 12px; background:#fff; }
    summary{ cursor:pointer; font-weight: 800; }

    .table-wrap{ width:100%; overflow:auto; border-radius: 12px; border:1px solid var(--line); }
    table{ border-collapse: collapse; width: 100%; min-width: 720px; }
    th, td{ border-bottom:1px solid var(--line); padding: 10px 10px; text-align:left; vertical-align: top; }
    thead th{ position: sticky; top: 0; background: var(--soft); z-index: 2; }
    td.numeric, th.numeric{ text-align:right; }
    tr.clickable:hover{ background: #f3f4f6; cursor:pointer; }
    tr.is-selected{ outline: 2px solid rgba(0,0,0,0.18); outline-offset: -2px; }

    th.sortable{ user-select:none; cursor:pointer; }
    th.sortable:hover{ background: #eef2ff; }
    .sort-ind{ margin-left: 6px; font-size: .9rem; color: var(--muted); }

    .grid-two{ display:grid; grid-template-columns: 1fr 1fr; gap: 14px; }
    @media (max-width: 900px){
      .grid-two{ grid-template-columns: 1fr; }
      table{ min-width: 860px; }
    }

    #tooltip{
      position: fixed;
      z-index: 9999;
      max-width: min(560px, 92vw);
      background: #fff;
      color: #111;
      border: 1px solid #111;
      border-radius: 10px;
      padding: 10px 12px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.12);
      display:none;
      pointer-events:none;
      white-space: normal;
      line-height: 1.45;
      font-size: .95rem;
    }

    .clean-list{ list-style:none; margin:0; padding:0; }
    .clean-list li{ padding: 8px 0; border-bottom:1px dashed #e5e7eb; }
    .clean-list li:last-child{ border-bottom:0; }
    .who{ font-weight: 800; }
    .meta{ display:block; color: var(--muted); font-size: .95rem; margin-top: 2px; }
    .mini{ font-size: .92rem; }

    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.95rem;
      border: 1px solid #e5e7eb;
      background: #f9fafb;
      padding: 2px 6px;
      border-radius: 6px;
    }

    .banner{
      border: 1px solid var(--line);
      background: var(--soft);
      border-radius: 12px;
      padding: 10px 12px;
    }
    .banner .title{ font-weight: 900; }
    .badge-row{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin-top:6px; }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .small-note{ font-size: .9rem; color: var(--muted); line-height: 1.45; }
    .wrap-any{ overflow-wrap:anywhere; word-break: break-word; }

    /* ✅ 집계 진행 상태바 */
    .progress-track{
      width:100%;
      height: 12px;
      background: #e5e7eb;
      border: 1px solid #d1d5db;
      border-radius: 999px;
      overflow:hidden;
    }
    .progress-fill{
      height:100%;
      width:0%;
      background:#111827;
      transition: width .18s ease;
    }

    /* ✅ 요약 표 체크박스 */
    .td-check{ text-align:center; vertical-align: middle; }
    .th-check{ text-align:center; vertical-align: middle; width:48px; }
    .th-check input{ transform: translateY(1px); }
  </style>
</head>
<body>
  <div id="tooltip"></div>

  <header class="site-header">
    <div class="shell">
      <h1>학교별 전입·전출 인사발령자 명단 집계기</h1>
      <p class="muted">
        ·에듀파인 업무지원-일반게시판에서 인사발령 엑셀 첨부파일 다운받아서 한꺼번에 업로드하면 학교별 전입자, 전출자 명단 집계해주는 기능 <br/>
        ·발령 일자가 같은 모든 직군의 엑셀 파일을 한꺼번에 다 올리시면 됩니다. 교육공무원, 지방공무원, 교육공무직 한번에 집계 가능
      </p>
    </div>
  </header>

  <main class="container">
<!-- 1) 업로드/설정 -->
<section class="tool-card" id="uploadSection">
  <div class="tool-head">
    <div>
      <h2 class="tool-title">1. 인사발령 엑셀파일 업로드</h2>
      <p class="tool-sub">
        ·드래그해서 업로드 가능합니다.
      </p>
    </div>
  </div>

  <hr/>

  <div class="btn-row" style="margin-bottom: 10px;">
    <label class="btn" for="fileInput">파일 선택하기</label>

    <!-- display:none 대신 화면 밖으로 보내서 브라우저 호환성(특히 iOS Safari) 개선 -->
    <input id="fileInput" type="file" accept=".xlsx,.xls" multiple
           style="position:absolute; left:-9999px; width:1px; height:1px; opacity:0;" />

    <button id="btnAnalyze" class="btn primary">발령 정보 집계하기</button>
    <button id="btnClear" class="btn ghost">초기화하기</button>

    <span id="fileMeta" class="muted mini"></span>
  </div>

  <!-- ✅ 집계 단위 선택 -->
  <div class="row stretch" style="margin-top:10px;">
    <div>
      <label class="mini" style="display:block; font-weight:800; margin-bottom:6px;">집계 단위</label>
      <select id="groupMode" title="집계 단위">
        <option value="workplace" selected>근무지(학교/기관)</option>
        <option value="sgg">시군구</option>
      </select>
      <div class="help mini">집계 후에도 언제든 바꿀 수 있습니다.</div>
    </div>
  </div>

  <div id="dropZone" class="dropzone" tabindex="0" role="button" aria-label="여기에 엑셀 파일을 드래그해서 업로드">
    <strong>여기에 엑셀 파일을 드래그해서 놓기</strong>
    <div class="muted mini">지원: .xlsx, .xls · 여러 개 파일 가능</div>
  </div>

  <!-- ✅ 집계 진행 상태바: 드래그 영역과 집계 결과 요약 사이 -->
  <div id="progressWrap" class="banner" style="display:none; margin-top: 12px;">
    <div class="title">집계 진행 상황</div>
    <div id="progressText" class="small-note" style="margin-top:6px;"></div>
    <div id="progressTrack" class="progress-track" style="margin-top:8px;" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
      <div id="progressBar" class="progress-fill"></div>
    </div>
    <div class="row between" style="margin-top:8px;">
      <span id="progressPct" class="pill gray">0%</span>
      <span id="progressElapsed" class="muted mini"></span>
    </div>
  </div>

  <div id="analyzeBanner" class="banner" style="display:none; margin-top: 12px;">
    <div class="title">집계 결과 요약</div>
    <div id="globalTotals" class="small-note" style="margin-top:6px;"></div>
    <div class="badge-row" id="globalBadges"></div>
  </div>

  <div class="field" style="margin-top: 14px;">
    <details id="advancedDetails">
      <summary>데이터 추출 방식 상세 설정</summary>
      <div style="margin-top: 10px;">
        <div class="row stretch">
          <label class="mini" style="display:flex; gap:8px; align-items:center; font-weight:700;">
            <input id="optAutoDetect" type="checkbox" checked />
            <span>자동 컬럼 감지(추천)</span>
          </label>

          <label class="mini" style="display:flex; gap:8px; align-items:center; font-weight:700;">
            <input id="optNormalize" type="checkbox" checked />
            <span>근무지명 공백 및 개행 정리</span>
          </label>

          <label class="mini" style="display:flex; gap:8px; align-items:center; font-weight:700;">
            <input id="optPrefixRegion" type="checkbox" checked />
            <span>관할 태그 붙이기 (여러 지역 조회할 경우)</span>
          </label>

          <label class="mini" style="display:flex; gap:8px; align-items:center; font-weight:700;">
            <input id="optUseSubject" type="checkbox" checked />
            <span>교육공무원 과목이 있으면 직종에 포함</span>
          </label>

          <!-- ✅ 기본값: OFF (본명 전체 표시) -->
          <label class="mini" style="display:flex; gap:8px; align-items:center; font-weight:700;">
            <input id="optMaskNames" type="checkbox" />
            <span>이름 마스킹하기 (선택)</span>
          </label>
        </div>

        <div class="field">
          <label class="mini">근무지 판단 키워드 </label>
          <div class="help">쉼표, 줄바꿈으로 구분. 학교급과 기관 키워드를 추가하면 근무지 판별 정확도 올라감.</div>
          <textarea id="placeKeywords" style="width:100%;">유치원, 초등학교, 중학교, 고등학교, 특수학교, 학교, 교육지원청, 교육청, 도서관, 센터, 유, 초, 중, 고</textarea>
        </div>

        <!-- ✅ 시군구 추출 키워드 -->
        <div class="field">
          <label class="mini">시군구(권역) 추출 키워드</label>
          <div class="help">
            쉼표, 줄바꿈으로 구분. 근무지명에 포함된 키워드로 시군구를 판정합니다.
            (예: “속초양양”처럼 긴 키워드를 먼저 쓰면 정확도가 올라갑니다)
          </div>
          <textarea id="sggKeywords" style="width:100%;">춘천, 원주, 강릉, 동해, 태백, 속초, 삼척, 홍천, 횡성, 영월, 평창, 정선, 철원, 화천, 양구, 인제, 고성, 양양, 속초양양</textarea>
        </div>

        <div class="field">
          <label class="mini">자동 감지 실패 시 수동 집계</label>
          <div class="help">모든 시트에 동일 적용. 컬럼은 A,B,C… 형태로 입력합니다.</div>

          <div class="row stretch">
            <div>
              <label class="mini">연번/번호</label>
              <input id="colSeq" type="text" value="A" maxlength="3" />
            </div>
            <div>
              <label class="mini">성명</label>
              <input id="colName" type="text" value="B" maxlength="3" />
            </div>
            <div>
              <label class="mini">직종/직급</label>
              <input id="colJob" type="text" value="C" maxlength="3" />
            </div>
            <div>
              <label class="mini">전입자 발령 근무지</label>
              <input id="colIn" type="text" value="D" maxlength="3" />
            </div>
            <div>
              <label class="mini">전출자 현소속 근무지</label>
              <input id="colOut" type="text" value="F" maxlength="3" />
            </div>
            <div>
              <label class="mini">비고</label>
              <input id="colNote" type="text" value="H" maxlength="3" />
            </div>
          </div>

          <div class="help">
            ※ 교육공무원 서식의 비고는 자동 감지 후 전출근무지 보정으로 활용함.
          </div>
        </div>

        <p id="libWarn" class="muted" style="display:none; margin: 8px 0 0;"></p>
      </div>
    </details>
  </div>

  <div class="field">
    <details id="fileListDetails">
      <summary id="fileListSummary">선택된 파일 (0개)</summary>
      <div style="margin-top: 10px;">
        <ul id="fileList" class="clean-list"></ul>
      </div>
    </details>
  </div>
</section>

<!-- 2) 상세 -->
<section class="tool-card" id="detailSection" style="display:none;">
  <div class="tool-head">
    <div>
      <h2 class="tool-title">2. <span id="detailTitleGroup">근무지</span> 상세 발령 내역</h2>
      <p class="tool-sub">
        ·선택하면 전체 전입 전출자 확인 가능.
      </p>
    </div>
    <div class="btn-row">
      <!-- ✅ 기본값: OFF (본명 전체 표시) -->
      <label class="mini" style="display:flex; gap:8px; align-items:center; font-weight:700;">
        <input id="optMaskNamesQuick" type="checkbox" />
        <span>이름 마스킹</span>
      </label>
      <button id="btnDownloadDetail" class="btn">현재 상세 CSV</button>
    </div>
  </div>

  <hr/>

  <div class="field">
    <label><span id="detailSearchLabel">학교/부서</span> 검색</label>
    <input id="workplaceSearch" type="text" placeholder="예: oo교육지원청, oo초 ..." />
    <div class="help">공백/괄호/대소문자 차이는 무시함. 정규화합니다.</div>
  </div>

  <div class="field">
    <label><span id="detailSelectLabel">학교/부서</span> 선택</label>
    <select id="workplaceSelect" title="항목 선택"></select>
    <div id="workplaceMeta" class="muted mini" style="margin-top:6px;"></div>
  </div>

  <div class="field">
    <label>직종(직급·과목) 선택</label>
    <select id="jobSelect" title="직종 선택"></select>
    <div id="jobMeta" class="muted mini" style="margin-top:6px;"></div>
  </div>

  <p class="muted mini" style="margin:0 0 8px;">
    ·아래 표 행에 마우스를 올리면 요약이 뜨고, 클릭하면 <b>아래 명단</b>이 해당 직종으로 전환됨.
  </p>

  <div class="table-wrap">
    <table id="jobTable">
      <thead>
        <tr>
          <th class="sortable" data-sort="staffType">구분<span class="sort-ind"></span></th>
          <th class="sortable" data-sort="jobName">직종(직급·과목)<span class="sort-ind"></span></th>
          <th class="numeric sortable" data-sort="out">전출<span class="sort-ind"></span></th>
          <th class="numeric sortable" data-sort="in">전입<span class="sort-ind"></span></th>
          <th class="numeric sortable" data-sort="diff">차이(전출-전입)<span class="sort-ind"></span></th>
          <th class="numeric sortable" data-sort="total">총변동<span class="sort-ind"></span></th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <div id="detailLists" style="margin-top: 14px;"></div>
</section>

<!-- 3) 요약 -->
<section class="tool-card" id="summarySection" style="display:none;">
  <div class="tool-head">
    <div>
      <h2 class="tool-title">3. <span id="summaryTitleGroup">근무지</span>별 요약</h2>
      <p class="tool-sub">기본적으로 오름차순 정렬임. 행 클릭 시 상세로 이동.</p>
    </div>
    <div class="btn-row">
      <button id="btnDownloadXlsxAll" class="btn">전체 항목 엑셀</button>
      <button id="btnDownloadXlsxSelected" class="btn primary">선택 항목 엑셀</button>
      <button id="btnClearSelected" class="btn ghost">선택 해제</button>
      <button id="btnDownloadSummary" class="btn">현재 요약 CSV</button>
    </div>
  </div>

  <hr/>

  <div class="field">
    <label>검색</label>
    <input id="summarySearch" type="text" placeholder="예: oo초, 교육지원청..." />
  </div>

  <div class="field">
    <label>보기</label>
    <select id="summaryFilter">
      <option value="all" selected>전체</option>
      <option value="outMore">전출자가 더 많은 항목</option>
      <option value="inMore">전입자가 더 많은 항목</option>
      <option value="equal">전입전출 일치 항목</option>
    </select>
  </div>

  <p id="summaryStats" class="muted" style="margin:0 0 10px;"></p>
  <p class="muted mini" style="margin:0 0 10px;">
    ·표 왼쪽 체크로 항목을 선택한 뒤 <b>선택 엑셀</b>을 누르면 선택한 항목만 한 번에 저장됩니다.
  </p>

  <div class="table-wrap">
    <table id="summaryTable">
      <thead>
        <tr>
          <th class="th-check"><input id="summaryCheckAll" type="checkbox" title="현재 표시 목록 전체 선택" /></th>
          <th class="sortable" data-sort="name"><span id="summaryGroupHeadText">근무지</span><span class="sort-ind"></span></th>
          <th class="numeric sortable" data-sort="out">전출<span class="sort-ind"></span></th>
          <th class="numeric sortable" data-sort="in">전입<span class="sort-ind"></span></th>
          <th class="numeric sortable" data-sort="total">총 인사변동<span class="sort-ind"></span></th>
          <th class="numeric sortable" data-sort="diff">차이(전출-전입)<span class="sort-ind"></span></th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
</section>

<!-- 4) 결원 의심 -->
<section class="tool-card" id="suspectSection" style="display:none;">
  <div class="tool-head">
    <div>
      <h2 class="tool-title">4. <span id="suspectTitleGroup">근무지</span> 기준 결원 의심 선별</h2>
      <p class="tool-sub">
        ·정원 및 배치기준 등 확인 필요. 간단하게 스크리닝 용도임임.
      </p>
    </div>
    <div class="btn-row">
      <button id="btnDownloadSuspect" class="btn">현재 목록 CSV</button>
    </div>
  </div>

  <hr/>

  <div class="row stretch">
    <div class="field" style="margin:0;">
      <label>검색</label>
      <input id="suspectSearch" type="text" placeholder="항목/직종 검색 (예: 조리, 국어, oo중)" />
    </div>
    <div class="field" style="margin:0;">
      <label>구분</label>
      <select id="suspectType">
        <option value="ALL" selected>전체</option>
        <option value="교육공무직">교육공무직</option>
        <option value="교육공무원">교육공무원</option>
        <option value="지방공무원">지방공무원</option>
      </select>
    </div>
  </div>

  <p id="suspectStats" class="muted" style="margin:10px 0;"></p>

  <div class="table-wrap">
    <table id="suspectTable">
      <thead>
        <tr>
          <th class="sortable" data-sort="staffType">구분<span class="sort-ind"></span></th>
          <th class="sortable" data-sort="workplace"><span id="suspectGroupHeadText">근무지</span><span class="sort-ind"></span></th>
          <th class="sortable" data-sort="jobName">직종(직급·과목)<span class="sort-ind"></span></th>
          <th class="numeric sortable" data-sort="out">전출<span class="sort-ind"></span></th>
          <th class="numeric sortable" data-sort="in">전입<span class="sort-ind"></span></th>
          <th class="numeric sortable" data-sort="diff">결원 의심(전출-전입)<span class="sort-ind"></span></th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
</section>

<!-- 5) 로그 -->
<section class="tool-card">
  <details id="logDetails">
    <summary>처리 로그</summary>
    <div style="margin-top:10px;">
      <pre id="logBox" class="muted" style="white-space: pre-wrap; margin:0;"></pre>
    </div>
  </details>
</section>

<p><a class="btn" href="../index.html">메인으로 돌아가기</a></p>

  </main>

<script>
(() => {
  "use strict";

  // ---------------------------
  // DOM
  // ---------------------------
  const $ = (s) => document.querySelector(s);

  const el = {
    tooltip: $("#tooltip"),

    fileInput: $("#fileInput"),
    dropZone: $("#dropZone"),
    btnAnalyze: $("#btnAnalyze"),
    btnClear: $("#btnClear"),
    fileMeta: $("#fileMeta"),

    // ✅ group mode / sgg keywords
    groupMode: $("#groupMode"),
    sggKeywords: $("#sggKeywords"),

    // ✅ dynamic UI text nodes
    detailTitleGroup: $("#detailTitleGroup"),
    summaryTitleGroup: $("#summaryTitleGroup"),
    suspectTitleGroup: $("#suspectTitleGroup"),
    detailSearchLabel: $("#detailSearchLabel"),
    detailSelectLabel: $("#detailSelectLabel"),
    summaryGroupHeadText: $("#summaryGroupHeadText"),
    suspectGroupHeadText: $("#suspectGroupHeadText"),

    // progress
    progressWrap: $("#progressWrap"),
    progressText: $("#progressText"),
    progressTrack: $("#progressTrack"),
    progressBar: $("#progressBar"),
    progressPct: $("#progressPct"),
    progressElapsed: $("#progressElapsed"),

    analyzeBanner: $("#analyzeBanner"),
    globalTotals: $("#globalTotals"),
    globalBadges: $("#globalBadges"),

    optAutoDetect: $("#optAutoDetect"),
    optNormalize: $("#optNormalize"),
    optPrefixRegion: $("#optPrefixRegion"),
    optUseSubject: $("#optUseSubject"),
    optMaskNames: $("#optMaskNames"),
    optMaskNamesQuick: $("#optMaskNamesQuick"),
    placeKeywords: $("#placeKeywords"),

    colSeq: $("#colSeq"),
    colName: $("#colName"),
    colJob: $("#colJob"),
    colIn: $("#colIn"),
    colOut: $("#colOut"),
    colNote: $("#colNote"),

    libWarn: $("#libWarn"),

    fileListSummary: $("#fileListSummary"),
    fileList: $("#fileList"),

    detailSection: $("#detailSection"),
    workplaceSearch: $("#workplaceSearch"),
    workplaceSelect: $("#workplaceSelect"),
    workplaceMeta: $("#workplaceMeta"),
    jobSelect: $("#jobSelect"),
    jobMeta: $("#jobMeta"),
    jobTableBody: $("#jobTable tbody"),
    detailLists: $("#detailLists"),
    btnDownloadDetail: $("#btnDownloadDetail"),

    summarySection: $("#summarySection"),
    summarySearch: $("#summarySearch"),
    summaryFilter: $("#summaryFilter"),
    summaryStats: $("#summaryStats"),
    summaryTableBody: $("#summaryTable tbody"),
    summaryCheckAll: $("#summaryCheckAll"),

    btnDownloadSummary: $("#btnDownloadSummary"),
    btnDownloadXlsxAll: $("#btnDownloadXlsxAll"),
    btnDownloadXlsxSelected: $("#btnDownloadXlsxSelected"),
    btnClearSelected: $("#btnClearSelected"),

    suspectSection: $("#suspectSection"),
    suspectSearch: $("#suspectSearch"),
    suspectType: $("#suspectType"),
    suspectStats: $("#suspectStats"),
    suspectTableBody: $("#suspectTable tbody"),
    btnDownloadSuspect: $("#btnDownloadSuspect"),

    logBox: $("#logBox"),
  };

  // ---------------------------
  // State
  // ---------------------------
  const state = {
    files: [],
    analyzed: false,

    // ✅ 집계 단위: workplace | sgg
    groupMode: "workplace",

    moves: [], // flat list

    workplaces: new Map(), // workplaceKey -> group
    workplaceOrder: [],

    districts: new Map(), // sggKey -> group
    districtOrder: [],

    // 시군구 토큰(집계 시점에 build)
    sggTokens: [],

    selectedWorkplaceKey: "",
    selectedJobKey: "ALL",

    // summary selection (모드별)
    summarySelectedWorkplace: new Set(),
    summarySelectedSgg: new Set(),
    summaryLastKeysWorkplace: [],
    summaryLastKeysSgg: [],

    // sorting states
    sortSummary: { key: "name", dir: "asc" },
    sortJobs: { key: "staffType", dir: "asc" },
    sortSuspect: { key: "diff", dir: "desc" },

    heur: null,
    regionTags: new Map(), // fileName -> regionTag

    // default: unmasked
    maskNames: false,

    dedupe: {
      strictSeen: new Set(),
      strictSkipped: 0,
      looseMap: new Map(), // looseKey -> firstNote
      looseCollisions: 0,
      looseExamples: [],   // {name, jobName, inWorkplace, outWorkplace, noteA, noteB, sheetName, seq}
    },

    stats: null, // global stats
  };

  // ---------------------------
  // Logging
  // ---------------------------
  function log(line) {
    const ts = new Date().toLocaleTimeString();
    el.logBox.textContent += `[${ts}] ${line}
`;
    el.logBox.scrollTop = el.logBox.scrollHeight;
  }
  function clearLog() { el.logBox.textContent = ""; }

  // ---------------------------
  // Tooltip
  // ---------------------------
  function showTooltip(html, x, y) {
    el.tooltip.innerHTML = html;
    el.tooltip.style.display = "block";

    const pad = 14;
    const rect = el.tooltip.getBoundingClientRect();
    const vw = window.innerWidth;
    const vh = window.innerHeight;

    let left = x + 12;
    let top = y + 12;
    if (left + rect.width + pad > vw) left = Math.max(pad, vw - rect.width - pad);
    if (top + rect.height + pad > vh) top = Math.max(pad, y - rect.height - 12);

    el.tooltip.style.left = left + "px";
    el.tooltip.style.top = top + "px";
  }
  function hideTooltip() {
    el.tooltip.style.display = "none";
    el.tooltip.innerHTML = "";
  }

  // ---------------------------
  // Progress helpers
  // ---------------------------
  let progressStartAt = 0;

  function formatElapsed(ms) {
    const sec = Math.max(0, Math.floor(ms / 1000));
    const m = Math.floor(sec / 60);
    const s = sec % 60;
    return `${m}:${String(s).padStart(2, "0")}`;
  }

  function showProgress() { el.progressWrap.style.display = ""; }

  function hideProgress() {
    progressStartAt = 0;
    el.progressWrap.style.display = "none";
    el.progressBar.style.width = "0%";
    el.progressTrack?.setAttribute("aria-valuenow", "0");
    el.progressPct.textContent = "0%";
    el.progressText.textContent = "";
    el.progressElapsed.textContent = "";
  }

  function startProgress(text = "준비 중...") {
    progressStartAt = Date.now();
    showProgress();
    setProgress(0, text);
  }

  function setProgress(pct, text = "") {
    const p = Math.max(0, Math.min(100, Number(pct) || 0));
    showProgress();
    el.progressBar.style.width = `${p.toFixed(1)}%`;
    el.progressTrack?.setAttribute("aria-valuenow", String(Math.round(p)));
    el.progressPct.textContent = `${Math.round(p)}%`;
    el.progressText.textContent = text;

    if (progressStartAt) {
      const ms = Date.now() - progressStartAt;
      el.progressElapsed.textContent = `경과 ${formatElapsed(ms)}`;
    } else {
      el.progressElapsed.textContent = "";
    }
  }

  function doneProgress(text = "집계 완료 ✅") { setProgress(100, text); }

  function rafTick() {
    return new Promise((resolve) => requestAnimationFrame(() => resolve(true)));
  }

  // ---------------------------
  // Utilities
  // ---------------------------
  function escapeHtml(s) {
    return String(s ?? "")
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");
  }

  function normalizeSpaces(v) {
    return String(v ?? "").replace(/\s+/g, " ").trim();
  }

  function normalizeKey(v) {
    return normalizeSpaces(v).replace(/\s+/g, "");
  }

  function normalizeSearch(v) {
    return String(v ?? "")
      .toLowerCase()
      .replace(/\s+/g, "")
      .replace(/[\{\}<>]/g, "")
      .replace(/[·ㆍ\.\-_,]/g, "");
  }
  function includesNorm(hay, needle) {
    const n = normalizeSearch(needle);
    if (!n) return true;
    return normalizeSearch(hay).includes(n);
  }

  function bytesToHuman(bytes) {
    if (!Number.isFinite(bytes)) return "-";
    const units = ["B","KB","MB","GB"];
    let v = bytes, i = 0;
    while (v >= 1024 && i < units.length - 1) { v /= 1024; i++; }
    return `${v.toFixed(i === 0 ? 0 : 1)} ${units[i]}`;
  }

  function toIntLike(v) {
    if (typeof v === "number" && Number.isFinite(v)) return Math.trunc(v);
    const s = String(v ?? "").trim();
    if (!s) return null;
    if (/^\d+$/.test(s)) return parseInt(s, 10);
    const m = s.match(/^(\d+)\s*[\.\)\-]$/);
    if (m) return parseInt(m[1], 10);
    return null;
  }

  function colToIndex(col) {
    const s = String(col ?? "").trim().toUpperCase();
    if (!s) return null;
    let n = 0;
    for (let i = 0; i < s.length; i++) {
      const code = s.charCodeAt(i);
      if (code < 65 || code > 90) return null;
      n = n * 26 + (code - 64);
    }
    return n - 1;
  }

  function indexToCol(idx) {
    if (!Number.isFinite(idx) || idx < 0) return "";
    let n = idx + 1;
    let out = "";
    while (n > 0) {
      const r = (n - 1) % 26;
      out = String.fromCharCode(65 + r) + out;
      n = Math.floor((n - 1) / 26);
    }
    return out;
  }

  function downloadCsv(filename, rows2d) {
    const bom = "\uFEFF";
    const csv = rows2d.map(row => row.map(cell => {
      const raw = String(cell ?? "");
      const escaped = raw.replace(/"/g,'""');
      return `"${escaped}"`;
    }).join(",")).join("\n");

    const blob = new Blob([bom + csv], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename.replace(/[\\/:*?"<>|]/g, "_");
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1200);
  }

  function debounce(fn, wait = 160) {
    let t = null;
    return (...args) => {
      if (t) clearTimeout(t);
      t = setTimeout(() => fn(...args), wait);
    };
  }

  function safeShort(s, max = 36) {
    const v = String(s ?? "");
    if (v.length <= max) return v;
    return v.slice(0, max - 1) + "…";
  }

  // 이름 마스킹 (김○○ / 홍○동)
  function maskName(name) {
    const raw = normalizeSpaces(name);
    if (!raw) return "";
    const hangul = raw.replace(/[^가-힣]/g, "");
    if (hangul.length < 2) return raw;

    const first = hangul[0];
    const last = hangul[hangul.length - 1];
    const middleCount = Math.max(1, hangul.length - 2);
    const masked = first + "○".repeat(middleCount) + (hangul.length >= 3 ? last : "");
    if (hangul.length === 2) return first + "○";
    return masked;
  }

  function displayName(name) {
    const n = normalizeSpaces(name);
    return state.maskNames ? maskName(n) : n;
  }

  // ---------------------------
  // ✅ Group mode helpers (근무지 / 시군구)
  // ---------------------------
  function groupLabel() {
    return state.groupMode === "sgg" ? "시군구" : "근무지";
  }
  function detailGroupLabel() {
    return state.groupMode === "sgg" ? "시군구" : "학교/부서";
  }
  function getActiveGroupMap() {
    return state.groupMode === "sgg" ? state.districts : state.workplaces;
  }
  function getActiveGroupOrder() {
    return state.groupMode === "sgg" ? state.districtOrder : state.workplaceOrder;
  }
  function getActiveSelectedSet() {
    return state.groupMode === "sgg" ? state.summarySelectedSgg : state.summarySelectedWorkplace;
  }
  function getActiveLastKeys() {
    return state.groupMode === "sgg" ? state.summaryLastKeysSgg : state.summaryLastKeysWorkplace;
  }
  function setActiveLastKeys(keys) {
    if (state.groupMode === "sgg") state.summaryLastKeysSgg = keys.slice();
    else state.summaryLastKeysWorkplace = keys.slice();
  }

  function updateGroupUiText() {
    const gl = groupLabel();
    const dl = detailGroupLabel();

    if (el.detailTitleGroup) el.detailTitleGroup.textContent = gl;
    if (el.summaryTitleGroup) el.summaryTitleGroup.textContent = gl;
    if (el.suspectTitleGroup) el.suspectTitleGroup.textContent = gl;

    if (el.detailSearchLabel) el.detailSearchLabel.textContent = dl;
    if (el.detailSelectLabel) el.detailSelectLabel.textContent = dl;

    if (el.summaryGroupHeadText) el.summaryGroupHeadText.textContent = gl;
    if (el.suspectGroupHeadText) el.suspectGroupHeadText.textContent = gl;

    // 버튼 텍스트도 자연스럽게
    if (el.btnDownloadXlsxAll) el.btnDownloadXlsxAll.textContent = `전체 ${gl} 엑셀`;
    if (el.btnDownloadXlsxSelected) el.btnDownloadXlsxSelected.textContent = `선택 ${gl} 엑셀`;
  }

  // 시군구 토큰 빌드(긴 키워드 우선 매칭)
  function buildSggTokens() {
    const raw = String(el.sggKeywords?.value || "");
    const tokens = raw.split(/[\n,]/).map(s => normalizeSpaces(s)).filter(Boolean);

    const set = new Set();
    const list = [];
    for (const t of tokens) {
      const key = normalizeSearch(t);
      if (!key || set.has(key)) continue;
      set.add(key);
      list.push({ label: t, key });
    }
    list.sort((a, b) => (b.key.length - a.key.length) || a.label.localeCompare(b.label, "ko"));
    return list;
  }

  function stripBracketTag(s) {
    const m = String(s || "").match(/^\[([^\]]+)\]\s*/);
    if (!m) return { tag: "", rest: normalizeSpaces(s) };
    return { tag: normalizeSpaces(m[1]), rest: normalizeSpaces(String(s).slice(m[0].length)) };
  }

  // 근무지명 -> 시군구 추출
  function inferSgg(workplace) {
    const s0 = normalizeSpaces(workplace);
    if (!s0) return "";

    // [태그]가 있으면 태그 우선
    const { tag, rest } = stripBracketTag(s0);
    if (tag) return tag;

    const s = rest;
    const compact = s.replace(/\s+/g, "");
    const wKey = normalizeSearch(s);
    if (!wKey) return "미상";

    // 도교육청/본청 계열
    if (/(강원특별자치도교육청|도교육청)/.test(compact)) return "도교육청";
    if (/(행정국|정책국|교육국|감사관)/.test(s)) return "도교육청";

    // 키워드 포함 매칭
    for (const t of state.sggTokens) {
      if (wKey.includes(t.key)) return t.label;
    }

    // "OO교육지원청" 패턴이면 OO를 시군구로
    const idx = compact.indexOf("교육지원청");
    if (idx > 0) {
      const prefix = compact.slice(0, idx);
      const pKey = normalizeSearch(prefix);
      for (const t of state.sggTokens) {
        if (pKey.endsWith(t.key)) return t.label;
      }
      if (prefix.length <= 10) return prefix;
    }

    // 첫 단어 fallback
    const first = normalizeSpaces(s).split(/\s+/)[0];
    if (first) {
      const fKey = normalizeSearch(first);
      for (const t of state.sggTokens) {
        if (fKey === t.key) return t.label;
      }
      if (first.length <= 10) return first;
    }

    return "미상";
  }

  // ---------------------------
  // XLSX attaching
  // ---------------------------
  function loadScript(src) {
    return new Promise((resolve, reject) => {
      const s = document.createElement("script");
      s.src = src;
      s.onload = () => resolve(true);
      s.onerror = () => reject(new Error("script load fail: " + src));
      document.head.appendChild(s);
    });
  }

  async function ensureXLSX() {
    if (window.XLSX) return true;
    const sources = [
      "/static/xlsx.full.min.js",
      "static/xlsx.full.min.js",
      "https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"
    ];
    for (const src of sources) {
      try {
        log(`엑셀 파서 로드 시도: ${src}`);
        await loadScript(src);
        if (window.XLSX) {
          log("엑셀 파서 로드 완료 ✅");
          return true;
        }
      } catch {
        log(`로드 실패: ${src}`);
      }
    }
    return false;
  }

  function setLibWarning(ok) {
    if (ok) {
      el.libWarn.style.display = "none";
      el.btnAnalyze.disabled = false;
      return;
    }
    el.libWarn.style.display = "";
    el.libWarn.textContent =
      "⚠️ 엑셀 파서(XLSX)가 로드되지 않았습니다. " +
      "폐쇄망이면 /static/xlsx.full.min.js 를 프로젝트에 추가하세요. (또는 인터넷 환경에서 CDN 사용)";
    el.btnAnalyze.disabled = true;
  }

  // ---------------------------
  // Heuristics
  // ---------------------------
  function escapeRegExp(s) {
    return String(s).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }

  function cellStr(v) {
    return String(v ?? "").replace(/\s+/g, " ").trim();
  }
  function cellKey(v) {
    return normalizeKey(cellStr(v));
  }

  function buildHeuristics() {
    const raw = String(el.placeKeywords.value || "");
    const tokens = raw.split(/[\n,]/).map(s => normalizeSpaces(s)).filter(Boolean);

    const oneChar = tokens.filter(t => t.length === 1);
    const normal = tokens.filter(t => t.length >= 2);

    const strongRe = normal.length ? new RegExp(normal.map(x => escapeRegExp(x)).join("|")) : null;
    const suffixRe = oneChar.length ? new RegExp("(" + oneChar.map(x => escapeRegExp(x)).join("|") + ")$") : null;

    function isPlaceLike(s) {
      const v = normalizeSpaces(s);
      if (!v) return false;
      if (strongRe && strongRe.test(v)) return true;
      if (suffixRe && suffixRe.test(v.replace(/\s+/g,""))) return true;

      if (/(유치원|초등학교|중학교|고등학교|특수학교|학교|교육지원청|교육청|지원청|도서관|센터|기관)/.test(v)) return true;
      if (/(초|중|고|유)$/.test(v.replace(/\s+/g,""))) return true;
      return false;
    }

    function isSchoolLike(s) {
      const v = normalizeSpaces(s);
      if (!v) return false;
      if (/(유치원|초등학교|중학교|고등학교|특수학교|학교)/.test(v)) return true;
      if (/(초|중|고|유)$/.test(v.replace(/\s+/g,""))) return true;
      return false;
    }

    function isEduOfficeLike(s) {
      const v = normalizeSpaces(s);
      if (!v) return false;
      return /(교육지원청|교육청|지원청|도교육청|특별자치도교육청)/.test(v);
    }

    function looksLikeName(val) {
      const raw = normalizeSpaces(val);
      if (!raw) return false;
      if (/[0-9]/.test(raw)) return false;
      if (/[A-Za-z]/.test(raw)) return false;
      if (/[\/\{\}]/.test(raw)) return false;

      const compact = raw.replace(/\s+/g, "");
      if (!compact) return false;

      if (compact.length < 2 || compact.length > 4) return false;

      const isHangulName =
        /^[가-힣]{2,4}$/.test(compact) ||
        /^[가-힣]{1,4}[·\s][가-힣]{1,4}$/.test(raw);
      if (!isHangulName) return false;

      if (/(학교|유치원|교육지원청|교육청|지원청|도서관|센터)/.test(raw)) return false;
      if (/(초|중|고|유)$/.test(compact)) return false;

      return true;
    }

    function looksLikeJob(val) {
      const s = cellStr(val);
      if (!s) return false;
      return /(교사|교감|원감|원로|주무관|행정|실무사|전담사|영양사|조리|사서|상담|보건|전문상담|치료|간호|운전|시설|청소|돌봄|늘봄)/.test(s);
    }

    return { tokens, isPlaceLike, isSchoolLike, isEduOfficeLike, looksLikeName, looksLikeJob };
  }

  // ---------------------------
  // Layout detection + data cross-check
  // ---------------------------
  function forwardFill(keys) {
    const out = [];
    let last = "";
    for (const k of keys) {
      if (k) { last = k; out.push(k); }
      else { out.push(last); }
    }
    return out;
  }

  function countHeaderSignals(keys, RE) {
    let c = 0;
    for (const k of keys) {
      if (!k) continue;
      if (RE.seq.test(k) || RE.name.test(k) || RE.job.test(k) || RE.note.test(k) || RE.place.test(k) || RE.subject.test(k)) c++;
    }
    return c;
  }

  function findIdxPrefer(primaryKeys, secondaryKeys, re) {
    for (let i = 0; i < primaryKeys.length; i++) {
      if (primaryKeys[i] && re.test(primaryKeys[i])) return i;
    }
    for (let i = 0; i < secondaryKeys.length; i++) {
      if (secondaryKeys[i] && re.test(secondaryKeys[i])) return i;
    }
    return -1;
  }

  function analyzeColumnStats(rows, dataStart, colIdx, heur, maxScanRows = 300) {
    let nonEmpty = 0;
    let placeLike = 0;
    let schoolLike = 0;
    let eduOfficeLike = 0;
    const uniqSet = new Set();

    const end = Math.min(rows.length, dataStart + maxScanRows);
    for (let r = dataStart; r < end; r++) {
      const row = rows[r] || [];
      const v = cellStr(row[colIdx]);
      if (!v) continue;
      nonEmpty++;
      uniqSet.add(v);
      if (heur.isPlaceLike(v)) placeLike++;
      if (heur.isSchoolLike(v)) schoolLike++;
      if (heur.isEduOfficeLike(v)) eduOfficeLike++;
    }

    return {
      nonEmpty,
      uniqueCount: uniqSet.size,
      placeLikeRatio: nonEmpty ? placeLike / nonEmpty : 0,
      schoolLikeRatio: nonEmpty ? schoolLike / nonEmpty : 0,
      eduOfficeLikeRatio: nonEmpty ? eduOfficeLike / nonEmpty : 0,
    };
  }

  function analyzeLikeRatio(rows, dataStart, colIdx, predicate, maxScanRows = 120) {
    let nonEmpty = 0;
    let hit = 0;
    const end = Math.min(rows.length, dataStart + maxScanRows);
    for (let r = dataStart; r < end; r++) {
      const row = rows[r] || [];
      const s = cellStr(row[colIdx]);
      if (!s) continue;
      nonEmpty++;
      if (predicate(row[colIdx])) hit++;
    }
    return nonEmpty ? hit / nonEmpty : 0;
  }

  function analyzeSeqRatio(rows, dataStart, colIdx, maxScanRows = 120) {
    let nonEmpty = 0;
    let hit = 0;
    const end = Math.min(rows.length, dataStart + maxScanRows);
    for (let r = dataStart; r < end; r++) {
      const row = rows[r] || [];
      const s = cellStr(row[colIdx]);
      if (!s) continue;
      nonEmpty++;
      if (toIntLike(row[colIdx]) !== null) hit++;
    }
    return nonEmpty ? hit / nonEmpty : 0;
  }

  // ✅ 교체 적용: detectLayoutPlus() (병합 헤더 대응 + placeCols top/bot 전체 수집)
  function detectLayoutPlus(rows, heur) {
    const RE = {
      seq: /(연번|순번|일련|번호)/,
      name: /(성명|이름)/,
      job: /(직종|직종명|직명|직급|직위)/,
      note: /(비고|특이|사유|전소속)/,
      subject: /(과목|교과|담당|전공)/,
      place: /(부서|근무처|근무지|기관명|기관|학교명|학교기관명|교육지원청|소속|부서명|학교)/,

      inHint: /(발령|임용|전입|전보후|발령후|신규|임지|변경후|발령사항|임용사항)/,
      outHint: /(현소속|현직|현근무|현근무처|전출|퇴직|발령전|출발|변경전|종전|전보전|전소속)/,
    };

    const maxScan = Math.min(rows.length, 70);
    let best = null;

    for (let r = 0; r < maxScan - 1; r++) {
      const topRow = rows[r] || [];
      const botRow = rows[r + 1] || [];

      const n = Math.max(topRow.length, botRow.length);
      if (n <= 0) continue;

      const topKeys = Array.from({ length: n }, (_, i) => cellKey(topRow[i]));
      const botKeys = Array.from({ length: n }, (_, i) => cellKey(botRow[i]));
      const topFF = forwardFill(topKeys);

      const topCnt = countHeaderSignals(topKeys, RE);
      const botCnt = countHeaderSignals(botKeys, RE);

      const fieldKeys = (botCnt >= topCnt) ? botKeys : topKeys;
      const otherKeys = (fieldKeys === botKeys) ? topKeys : botKeys;

      const seqIdx = findIdxPrefer(fieldKeys, otherKeys, RE.seq);
      const nameIdx = findIdxPrefer(fieldKeys, otherKeys, RE.name);
      const jobIdx = findIdxPrefer(fieldKeys, otherKeys, RE.job);
      const noteIdx = findIdxPrefer(fieldKeys, otherKeys, RE.note);
      const subjectIdx = findIdxPrefer(fieldKeys, otherKeys, RE.subject);

      const placeSet = new Set();
      for (let i = 0; i < n; i++) {
        const kField = fieldKeys[i];
        const kOther = otherKeys[i];
        const kTop = topKeys[i];
        const kBot = botKeys[i];

        if (kField && RE.place.test(kField)) placeSet.add(i);
        if (kOther && RE.place.test(kOther)) placeSet.add(i);
        if (kTop && RE.place.test(kTop)) placeSet.add(i);
        if (kBot && RE.place.test(kBot)) placeSet.add(i);
      }

      if (noteIdx >= 0) placeSet.delete(noteIdx);
      if (seqIdx >= 0) placeSet.delete(seqIdx);
      if (nameIdx >= 0) placeSet.delete(nameIdx);
      if (jobIdx >= 0) placeSet.delete(jobIdx);
      if (subjectIdx >= 0) placeSet.delete(subjectIdx);

      let placeCols = [...placeSet].sort((a, b) => a - b);
      if (nameIdx < 0 || placeCols.length < 1) continue;

      const dataStart = r + 2;

      if (placeCols.length < 2) {
        const threshold = 0.22;
        const exclude = new Set([seqIdx, nameIdx, jobIdx, noteIdx, subjectIdx].filter(x => x >= 0));

        for (let i = 0; i < n; i++) {
          if (exclude.has(i)) continue;
          if (placeSet.has(i)) continue;

          const stats = analyzeColumnStats(rows, dataStart, i, heur, 120);
          if (stats.placeLikeRatio >= threshold) placeCols.push(i);
        }
        placeCols = [...new Set(placeCols)].sort((a, b) => a - b);
      }

      const scored = placeCols.map((i) => {
        const combined = (topFF[i] || "") + " " + (fieldKeys[i] || "");
        const inScore = RE.inHint.test(combined) ? 3 : 0;
        const outScore = RE.outHint.test(combined) ? 3 : 0;
        const stats = analyzeColumnStats(rows, dataStart, i, heur, 120);
        const dataScore = stats.placeLikeRatio;
        return { i, combined, inScore, outScore, dataScore, stats };
      });

      let inIdx = -1;
      let outIdx = -1;

      const inSorted = [...scored].sort((a, b) => (b.inScore - a.inScore) || (b.dataScore - a.dataScore) || (a.i - b.i));
      const outSorted = [...scored].sort((a, b) => (b.outScore - a.outScore) || (b.dataScore - a.dataScore) || (b.i - a.i));

      if (inSorted[0] && inSorted[0].inScore > 0) inIdx = inSorted[0].i;
      if (outSorted[0] && outSorted[0].outScore > 0) outIdx = outSorted[0].i;

      const threshold = 0.22;
      if (inIdx < 0) {
        const leftToRight = scored.slice().sort((a, b) => a.i - b.i);
        inIdx = leftToRight.find(x => x.dataScore >= threshold)?.i ?? -1;
      }
      if (outIdx < 0) {
        const rightToLeft = scored.slice().sort((a, b) => b.i - a.i);
        outIdx = rightToLeft.find(x => x.dataScore >= threshold)?.i ?? -1;
      }

      if (placeCols.length === 1) {
        const only = scored[0];
        if (only) {
          if (only.inScore > only.outScore) { inIdx = only.i; outIdx = -1; }
          else if (only.outScore > only.inScore) { outIdx = only.i; inIdx = -1; }
          else { inIdx = only.i; outIdx = -1; }
        }
      } else {
        if (inIdx < 0 && placeCols.length) inIdx = Math.min(...placeCols);
        if (outIdx < 0 && placeCols.length) outIdx = Math.max(...placeCols);
        if (inIdx === outIdx && placeCols.length >= 2) {
          inIdx = placeCols[0];
          outIdx = placeCols[1];
        }
      }

      const nameRatio = (nameIdx >= 0) ? analyzeLikeRatio(rows, dataStart, nameIdx, heur.looksLikeName, 120) : 0;
      const seqRatio = (seqIdx >= 0) ? analyzeSeqRatio(rows, dataStart, seqIdx, 120) : 0;

      const score =
        (seqIdx >= 0 ? 2 : 0) +
        (nameIdx >= 0 ? 2 : 0) +
        (placeCols.length >= 2 ? 2 : 1) +
        (jobIdx >= 0 ? 1 : 0) +
        (noteIdx >= 0 ? 1 : 0) +
        (subjectIdx >= 0 ? 0.5 : 0) +
        (nameRatio >= 0.25 ? 1 : 0) +
        (seqRatio >= 0.35 ? 1 : 0);

      if (!best || score > best.score) {
        best = {
          detected: true,
          headerRow: r,
          subRow: r + 1,
          dataStart,
          seqIdx,
          nameIdx,
          jobIdx,
          inIdx,
          outIdx,
          noteIdx,
          subjectIdx,
          placeCols,
          score,
          fieldKeys,
        };
      }
    }

    if (!best) {
      for (let r = 0; r < maxScan; r++) {
        const row = rows[r] || [];
        const n = row.length;
        if (n <= 0) continue;

        const keys = Array.from({ length: n }, (_, i) => cellKey(row[i]));
        const seqIdx = findIdxPrefer(keys, [], RE.seq);
        const nameIdx = findIdxPrefer(keys, [], RE.name);
        const jobIdx = findIdxPrefer(keys, [], RE.job);
        const noteIdx = findIdxPrefer(keys, [], RE.note);
        const subjectIdx = findIdxPrefer(keys, [], RE.subject);

        const placeCols = [];
        for (let i = 0; i < n; i++) if (keys[i] && RE.place.test(keys[i])) placeCols.push(i);
        if (nameIdx < 0 || placeCols.length < 1) continue;

        const dataStart = r + 1;

        const statsArr = placeCols.map(i => ({ i, stats: analyzeColumnStats(rows, dataStart, i, heur, 120) }));
        const threshold = 0.22;
        let inIdx = statsArr.sort((a,b)=>a.i-b.i).find(x=>x.stats.placeLikeRatio>=threshold)?.i ?? placeCols[0];
        let outIdx = statsArr.sort((a,b)=>b.i-a.i).find(x=>x.stats.placeLikeRatio>=threshold)?.i ?? placeCols[placeCols.length-1];

        if (placeCols.length === 1) {
          const combined = keys[inIdx] || "";
          const inScore = RE.inHint.test(combined) ? 1 : 0;
          const outScore = RE.outHint.test(combined) ? 1 : 0;
          if (outScore > inScore) { outIdx = inIdx; inIdx = -1; }
          else { outIdx = -1; }
        } else if (inIdx === outIdx) {
          outIdx = -1;
        }

        const nameRatio = (nameIdx >= 0) ? analyzeLikeRatio(rows, dataStart, nameIdx, heur.looksLikeName, 120) : 0;
        const seqRatio = (seqIdx >= 0) ? analyzeSeqRatio(rows, dataStart, seqIdx, 120) : 0;

        const score =
          (seqIdx >= 0 ? 2 : 0) +
          (nameIdx >= 0 ? 2 : 0) +
          (placeCols.length >= 2 ? 2 : 1) +
          (jobIdx >= 0 ? 1 : 0) +
          (noteIdx >= 0 ? 1 : 0) +
          (nameRatio >= 0.25 ? 1 : 0) +
          (seqRatio >= 0.35 ? 1 : 0);

        best = {
          detected: true,
          headerRow: r,
          subRow: r,
          dataStart,
          seqIdx,
          nameIdx,
          jobIdx,
          inIdx,
          outIdx,
          noteIdx,
          subjectIdx,
          placeCols,
          score,
          fieldKeys: keys,
        };
        break;
      }
    }

    return best;
  }

  // ---------------------------
  // Staff type inference
  // ---------------------------
  function detectStaffType(fileName, sheetName, jobName) {
    const s = `${fileName} ${sheetName} ${jobName}`.toLowerCase();

    if (/(교육공무직|공무직|조리실무사|행정실무사|교무행정사|늘봄|돌봄|시설관리|미화)/.test(s)) return "교육공무직";
    if (/(교육공무원|교사|교감|원감|원로교사|유치원|초등|중등|고등|특수)/.test(s)) return "교육공무원";
    if (/(지방공무원|주무관|서기|행정직|시설직|운전직|공업직|기능직)/.test(s)) return "지방공무원";

    if (/(교사|교감|원감|원로)/.test(jobName)) return "교육공무원";
    if (/(주무관|서기|행정직|시설직|운전직)/.test(jobName)) return "지방공무원";
    return "교육공무직";
  }

  // ---------------------------
  // Workplace normalization / region tag
  // ---------------------------
  function inferRegionTag(fileName) {
    const m = String(fileName).match(/^\s*([^]+)\]/);
    if (m) return normalizeSpaces(m[1]);
    // 일반적인 [춘천] 형태도 지원
    const m2 = String(fileName).match(/^\s*\[([^\]]+)\]/);
    if (m2) return normalizeSpaces(m2[1]);
    return "";
  }

  function normalizeWorkplace(raw, regionTag, opt) {
    const s0 = normalizeSpaces(raw);
    if (!s0) return "";
    let s = s0;
    if (opt.normalizeOn) s = s.replace(/\s+/g, " ").trim();

    if (opt.prefixOn && regionTag) {
      if (!/^\[[^\]]+\]/.test(s)) {
        s = `[${regionTag}] ${s}`;
      }
    }
    return s;
  }

  // ---------------------------
  // Note parsing (전소속교 → 전출 근무지 추정)
  // ---------------------------
  function noteHeaderSuggestsPrevAffiliation(headerKey) {
    return /(전소속|전소속교|전소속\/직급|전소속\/직위|전소속\/직명)/.test(headerKey);
  }

  function parsePlaceFromNote(note, heur) {
    const s = normalizeSpaces(note);
    if (!s) return "";

    if (s.includes("/")) {
      const left = s.split("/")[0].trim();
      if (heur.isPlaceLike(left)) return left;
    }

    const cleaned = s.replace(/.*?/g, " ").replace(/\s+/g, " ").trim();
    const parts = cleaned.split(/[,\s]+/).filter(Boolean);

    let best = "";
    for (let i = 0; i < parts.length; i++) {
      let acc = "";
      for (let j = i; j < Math.min(parts.length, i + 6); j++) {
        acc = (acc ? acc + " " : "") + parts[j];
        if (heur.isPlaceLike(acc) && acc.length > best.length) best = acc;
      }
    }

    if (!best && heur.isPlaceLike(cleaned)) best = cleaned;
    return best;
  }

  // ---------------------------
  // Data model: group aggregation
  // ---------------------------
  function getGroup(map, key, name) {
    if (!map.has(key)) {
      map.set(key, {
        key,
        name,
        inMoves: [],
        outMoves: [],
        jobs: new Map(), // jobKey -> { staffType, jobKey, jobName, inMoves, outMoves }
      });
    }
    return map.get(key);
  }

  function getJobAgg(g, jobKey, staffType, jobName) {
    if (!g.jobs.has(jobKey)) {
      g.jobs.set(jobKey, { staffType, jobKey, jobName, inMoves: [], outMoves: [] });
    }
    return g.jobs.get(jobKey);
  }

  function addMoveToMap(map, groupKey, move, dir /* "in" | "out" */) {
    if (!groupKey) return;
    const g = getGroup(map, groupKey, groupKey);
    if (dir === "in") {
      g.inMoves.push(move);
      const j = getJobAgg(g, move.jobKey, move.staffType, move.jobName);
      j.inMoves.push(move);
    } else {
      g.outMoves.push(move);
      const j = getJobAgg(g, move.jobKey, move.staffType, move.jobName);
      j.outMoves.push(move);
    }
  }

  function addMove(move) {
    state.moves.push(move);

    // 근무지 기준
    if (move.inWorkplace) addMoveToMap(state.workplaces, move.inWorkplace, move, "in");
    if (move.outWorkplace) addMoveToMap(state.workplaces, move.outWorkplace, move, "out");

    // 시군구 기준
    if (move.inSgg) addMoveToMap(state.districts, move.inSgg, move, "in");
    if (move.outSgg) addMoveToMap(state.districts, move.outSgg, move, "out");
  }

  // ---------------------------
  // Sorting helpers
  // ---------------------------
  function toggleSort(sortState, key) {
    if (sortState.key === key) {
      sortState.dir = (sortState.dir === "asc") ? "desc" : "asc";
    } else {
      sortState.key = key;
      sortState.dir = (key === "name" || key === "workplace" || key === "jobName" || key === "staffType") ? "asc" : "desc";
    }
  }

  function compare(a, b, dir) {
    if (a === b) return 0;
    const s = (dir === "asc") ? 1 : -1;
    return (a > b ? 1 : -1) * s;
  }

  function cmpKo(a, b, dir) {
    const s = (dir === "asc") ? 1 : -1;
    return a.localeCompare(b, "ko") * s;
  }

  function renderSortIndicators(tableEl, sortState) {
    const ths = [...tableEl.querySelectorAll("thead th.sortable")];
    ths.forEach(th => {
      const span = th.querySelector(".sort-ind");
      if (!span) return;
      const key = th.dataset.sort;
      if (key === sortState.key) {
        span.textContent = sortState.dir === "asc" ? "▲" : "▼";
      } else {
        span.textContent = "";
      }
    });
  }

  // ---------------------------
  // Rendering: analysis banner
  // ---------------------------
  function renderAnalyzeBanner() {
    if (!state.stats) return;

    el.analyzeBanner.style.display = "";

    const s = state.stats;
    const netText = s.netDiff > 0 ? `+${s.netDiff}` : String(s.netDiff);

    el.globalTotals.innerHTML = `
      총 레코드 <b>${s.totalRecords}</b>건 · 전출(출발) <b>${s.totalOut}</b> · 전입(도착) <b>${s.totalIn}</b> · 총차이(전출-전입) <b class="mono">${escapeHtml(netText)}</b>
      <br/>
      (전출만 <b>${s.onlyOut}</b>, 전입만 <b>${s.onlyIn}</b>, 양쪽 모두 <b>${s.both}</b>)
    `;

    el.globalBadges.innerHTML = "";
    const frag = document.createDocumentFragment();

    const wCnt = state.workplaceOrder.length;
    const dCnt = state.districtOrder.length;

    const pillW = document.createElement("span");
    pillW.className = "pill gray";
    pillW.textContent = `근무지 ${wCnt}개`;
    frag.appendChild(pillW);

    const pillD = document.createElement("span");
    pillD.className = "pill gray";
    pillD.textContent = `시군구 ${dCnt}개`;
    frag.appendChild(pillD);

    const pillMode = document.createElement("span");
    pillMode.className = "pill gray";
    pillMode.textContent = `현재 보기: ${groupLabel()}`;
    frag.appendChild(pillMode);

    if (state.dedupe.strictSkipped > 0) {
      const p = document.createElement("span");
      p.className = "pill red";
      p.textContent = `중복 레코드 ${state.dedupe.strictSkipped}건 제외됨`;
      frag.appendChild(p);
    } else {
      const p = document.createElement("span");
      p.className = "pill green";
      p.textContent = `중복(완전 동일) 제외: 0건`;
      frag.appendChild(p);
    }

    if (state.dedupe.looseCollisions > 0) {
      const p = document.createElement("span");
      p.className = "pill amber";
      p.textContent = `중복 의심 ${state.dedupe.looseCollisions}건(값 일부 상이)`;
      frag.appendChild(p);
    } else {
      const p = document.createElement("span");
      p.className = "pill gray";
      p.textContent = `중복 의심: 0건`;
      frag.appendChild(p);
    }

    const pMask = document.createElement("span");
    pMask.className = "pill gray";
    pMask.textContent = state.maskNames ? "이름 마스킹: ON" : "이름 마스킹: OFF(본명 표시)";
    frag.appendChild(pMask);

    el.globalBadges.appendChild(frag);
  }

  // ---------------------------
  // Rendering: Group select + job select
  // ---------------------------
  function renderWorkplaceSelect() {
    const q = (el.workplaceSearch.value || "").trim();
    const opts = [];

    const order = getActiveGroupOrder();
    const groups = getActiveGroupMap();

    for (const key of order) {
      const g = groups.get(key);
      if (!g) continue;
      if (q && !includesNorm(g.name, q)) continue;
      opts.push({ key: g.key, name: g.name });
    }

    const current = state.selectedWorkplaceKey;
    const hasCurrent = opts.some(o => o.key === current);

    el.workplaceSelect.innerHTML = "";
    const frag = document.createDocumentFragment();
    for (const o of opts) {
      const opt = document.createElement("option");
      opt.value = o.key;
      opt.textContent = o.name;
      frag.appendChild(opt);
    }
    el.workplaceSelect.appendChild(frag);

    if (!hasCurrent) state.selectedWorkplaceKey = (opts[0]?.key || "");
    el.workplaceSelect.value = state.selectedWorkplaceKey;

    el.workplaceMeta.textContent = `표시 중: ${opts.length}개 ${groupLabel()}`;
  }

  function renderJobSelect() {
    const groups = getActiveGroupMap();
    const g = groups.get(state.selectedWorkplaceKey);
    if (!g) return;

    const list = [];
    for (const [, j] of g.jobs) {
      const inC = j.inMoves.length;
      const outC = j.outMoves.length;
      const diff = outC - inC;
      list.push({
        staffType: j.staffType,
        jobKey: j.jobKey,
        jobName: j.jobName,
        inC,
        outC,
        diff,
        total: inC + outC,
      });
    }

    list.sort((a,b) => (b.total - a.total) || cmpKo(a.jobName, b.jobName, "asc"));

    el.jobSelect.innerHTML = "";
    const frag = document.createDocumentFragment();

    const optAll = document.createElement("option");
    optAll.value = "ALL";
    optAll.textContent = `전체 직종`;
    frag.appendChild(optAll);

    for (const r of list) {
      const opt = document.createElement("option");
      opt.value = r.jobKey;
      const badge =
        r.diff > 0 ? `결원 의심 +${r.diff}` :
        r.diff < 0 ? `순증가 ${-r.diff}` :
        `균형 0`;
      opt.textContent = `[${r.staffType}] ${r.jobName} (전출 ${r.outC}/전입 ${r.inC} · ${badge})`;
      frag.appendChild(opt);
    }

    el.jobSelect.appendChild(frag);

    if (state.selectedJobKey !== "ALL" && !list.some(x => x.jobKey === state.selectedJobKey)) {
      state.selectedJobKey = "ALL";
    }
    el.jobSelect.value = state.selectedJobKey;

    el.jobMeta.textContent = `직종(직급·과목) ${list.length}개`;
  }

  // ---------------------------
  // Rendering: Group detail
  // ---------------------------
  function renderWorkplaceDetail() {
    const groups = getActiveGroupMap();
    const g = groups.get(state.selectedWorkplaceKey);
    if (!g) return;

    const rows = [];
    for (const [, j] of g.jobs) {
      const inC = j.inMoves.length;
      const outC = j.outMoves.length;
      rows.push({
        staffType: j.staffType,
        jobKey: j.jobKey,
        jobName: j.jobName,
        in: inC,
        out: outC,
        diff: outC - inC,
        total: inC + outC,
        agg: j,
      });
    }

    rows.sort((a,b) => {
      const k = state.sortJobs.key;
      const dir = state.sortJobs.dir;
      if (k === "staffType") return cmpKo(a.staffType, b.staffType, dir) || cmpKo(a.jobName, b.jobName, "asc");
      if (k === "jobName") return cmpKo(a.jobName, b.jobName, dir);
      if (k === "in") return compare(a.in, b.in, dir) || cmpKo(a.jobName, b.jobName, "asc");
      if (k === "out") return compare(a.out, b.out, dir) || cmpKo(a.jobName, b.jobName, "asc");
      if (k === "diff") return compare(a.diff, b.diff, dir) || cmpKo(a.jobName, b.jobName, "asc");
      if (k === "total") return compare(a.total, b.total, dir) || cmpKo(a.jobName, b.jobName, "asc");
      return cmpKo(a.jobName, b.jobName, "asc");
    });

    const inTotal = g.inMoves.length;
    const outTotal = g.outMoves.length;
    const diffTotal = outTotal - inTotal;

    const badge =
      diffTotal > 0 ? `<span class="pill red">결원 의심 +${diffTotal}</span>` :
      diffTotal < 0 ? `<span class="pill blue">순증가 ${-diffTotal}</span>` :
      `<span class="pill gray">균형 0</span>`;

    el.workplaceMeta.innerHTML = `전출 ${outTotal} · 전입 ${inTotal} · 총변동 ${inTotal + outTotal} · ${badge}`;

    el.jobTableBody.innerHTML = "";
    const frag = document.createDocumentFragment();

    for (const r of rows) {
      const tr = document.createElement("tr");
      tr.className = "clickable";
      tr.dataset.jobKey = r.jobKey;

      const diffPill =
        r.diff > 0 ? `<span class="pill red">+${r.diff}</span>` :
        r.diff < 0 ? `<span class="pill blue">${r.diff}</span>` :
        `<span class="pill gray">0</span>`;

      tr.innerHTML = `
        <td>${escapeHtml(r.staffType)}</td>
        <td><b>${escapeHtml(r.jobName)}</b></td>
        <td class="numeric">${r.out}</td>
        <td class="numeric">${r.in}</td>
        <td class="numeric">${diffPill}</td>
        <td class="numeric">${r.total}</td>
      `;

      tr.addEventListener("mouseenter", (e) => {
        const html = `
          <div><b>${escapeHtml(g.name)}</b></div>
          <div class="mini">[${escapeHtml(r.staffType)}] ${escapeHtml(r.jobName)}</div>
          <div class="mini" style="margin-top:6px;">
            전출 <b>${r.out}</b> · 전입 <b>${r.in}</b> · 차이 <b>${escapeHtml(r.diff>0?`+${r.diff}`:String(r.diff))}</b>
          </div>
          <div class="mini muted" style="margin-top:6px;">클릭하면 아래 명단이 이 직종으로 전환됩니다.</div>
        `;
        showTooltip(html, e.clientX, e.clientY);
      });
      tr.addEventListener("mousemove", (e) => {
        if (el.tooltip.style.display === "block") showTooltip(el.tooltip.innerHTML, e.clientX, e.clientY);
      });
      tr.addEventListener("mouseleave", hideTooltip);

      tr.addEventListener("click", () => {
        state.selectedJobKey = r.jobKey;
        el.jobSelect.value = r.jobKey;
        renderListsForSelectedJob();

        [...el.jobTableBody.querySelectorAll("tr")].forEach(x => x.classList.remove("is-selected"));
        tr.classList.add("is-selected");
      });

      frag.appendChild(tr);
    }

    el.jobTableBody.appendChild(frag);
    renderSortIndicators(document.getElementById("jobTable"), state.sortJobs);

    setTimeout(() => {
      const trs = [...el.jobTableBody.querySelectorAll("tr")];
      trs.forEach(t => t.classList.remove("is-selected"));
      if (state.selectedJobKey !== "ALL") {
        const hit = trs.find(t => t.dataset.jobKey === state.selectedJobKey);
        if (hit) hit.classList.add("is-selected");
      }
    }, 0);

    renderListsForSelectedJob();
  }

  function renderListsForSelectedJob() {
    const groups = getActiveGroupMap();
    const g = groups.get(state.selectedWorkplaceKey);
    if (!g) return;

    const jobKey = state.selectedJobKey;
    let inMoves = [];
    let outMoves = [];
    let title = "";

    if (jobKey === "ALL") {
      inMoves = g.inMoves.slice();
      outMoves = g.outMoves.slice();
      title = `전체 직종`;
    } else {
      const agg = g.jobs.get(jobKey);
      if (agg) {
        inMoves = agg.inMoves.slice();
        outMoves = agg.outMoves.slice();
        title = `[${agg.staffType}] ${agg.jobName}`;
      }
    }

    inMoves.sort((a,b) => a.seq - b.seq);
    outMoves.sort((a,b) => a.seq - b.seq);

    const makeEvidence = (m) => {
      const fileShort = safeShort(m.fileName, 34);
      const sheetShort = safeShort(m.sheetName, 24);
      const full = `${m.fileName} / ${m.sheetName} / ${m.rowIndex}행`;
      return `<span class="mono muted mini wrap-any" title="${escapeHtml(full)}">(${escapeHtml(fileShort)} / ${escapeHtml(sheetShort)} / ${m.rowIndex}행)</span>`;
    };

    const inList = inMoves.map(m => `
      <li>
        <span class="who">${escapeHtml(displayName(m.name) || "(이름없음)")}</span>
        <span class="meta">
          ← ${escapeHtml(m.outWorkplace || "-")}
          ${m.note ? ` <span class="pill gray">${escapeHtml(m.note)}</span>` : ""}
          ${m.staffType ? ` <span class="pill gray">${escapeHtml(m.staffType)}</span>` : ""}
          ${makeEvidence(m)}
        </span>
      </li>
    `).join("");

    const outList = outMoves.map(m => `
      <li>
        <span class="who">${escapeHtml(displayName(m.name) || "(이름없음)")}</span>
        <span class="meta">
          → ${escapeHtml(m.inWorkplace || "-")}
          ${m.note ? ` <span class="pill gray">${escapeHtml(m.note)}</span>` : ""}
          ${m.staffType ? ` <span class="pill gray">${escapeHtml(m.staffType)}</span>` : ""}
          ${makeEvidence(m)}
        </span>
      </li>
    `).join("");

    const diff = outMoves.length - inMoves.length;
    const badge =
      diff > 0 ? `<span class="pill red">결원 의심 +${diff}</span>` :
      diff < 0 ? `<span class="pill blue">순증가 ${-diff}</span>` :
      `<span class="pill gray">균형 0</span>`;

    el.detailLists.innerHTML = `
      <div class="tool-card" style="margin:0; border-color: var(--line);">
        <div class="row between" style="flex-wrap:wrap; margin-bottom:8px;">
          <div>
            <div class="mini muted">선택 ${escapeHtml(groupLabel())}</div>
            <div style="font-weight:900; font-size:1.05rem;">${escapeHtml(g.name)}</div>
            <div class="mini muted" style="margin-top:4px;">직종: <b>${escapeHtml(title)}</b></div>
            <div class="mini muted" style="margin-top:4px;">※ 원본 근거(파일/시트/행)는 명단 항목 오른쪽 괄호에 표시됩니다.</div>
          </div>
          <div style="display:flex; flex-direction:column; align-items:flex-end; gap:6px;">
            ${badge}
            <span class="pill gray">전출 ${outMoves.length} · 전입 ${inMoves.length}</span>
          </div>
        </div>

        <hr/>

        <div class="grid-two">
          <div class="tool-card" style="margin:0; background:#fff;">
            <h3 class="tool-title" style="margin:0; font-size:1.05rem;">전출/퇴직 명단</h3>
            <p class="muted mini" style="margin:6px 0 0;">(이 ${escapeHtml(groupLabel())}을(를) 떠나는 사람들)</p>
            <ul class="clean-list" style="margin-top:8px;">${outList || `<li class="muted">없음</li>`}</ul>
          </div>
          <div class="tool-card" style="margin:0; background:#fff;">
            <h3 class="tool-title" style="margin:0; font-size:1.05rem;">전입 명단</h3>
            <p class="muted mini" style="margin:6px 0 0;">(이 ${escapeHtml(groupLabel())}로 오는 사람들)</p>
            <ul class="clean-list" style="margin-top:8px;">${inList || `<li class="muted">없음</li>`}</ul>
          </div>
        </div>
      </div>
    `;
  }

  // ---------------------------
  // Summary selection meta
  // ---------------------------
  function updateSummarySelectionMeta(displayKeys) {
    const selectedSet = getActiveSelectedSet();

    const totalSelected = selectedSet.size;
    const displaySelected = displayKeys.reduce((acc, k) => acc + (selectedSet.has(k) ? 1 : 0), 0);
    el.summaryStats.textContent = `표시 중: ${displayKeys.length}개 ${groupLabel()} · 선택: ${totalSelected}개 (현재 표시 중 ${displaySelected}개)`;

    if (el.summaryCheckAll) {
      el.summaryCheckAll.checked = displayKeys.length > 0 && displaySelected === displayKeys.length;
      el.summaryCheckAll.indeterminate = displaySelected > 0 && displaySelected < displayKeys.length;
    }
  }

  // ---------------------------
  // Rendering: Summary table (with selection)
  // ---------------------------
  function renderSummary() {
    const q = el.summarySearch.value || "";
    const mode = el.summaryFilter.value;

    const order = getActiveGroupOrder();
    const groups = getActiveGroupMap();
    const selectedSet = getActiveSelectedSet();

    const list = [];
    for (const key of order) {
      const g = groups.get(key);
      if (!g) continue;
      if (q && !includesNorm(g.name, q)) continue;

      const inC = g.inMoves.length;
      const outC = g.outMoves.length;
      const diff = outC - inC;
      const total = inC + outC;

      if (mode === "outMore" && diff <= 0) continue;
      if (mode === "inMore" && diff >= 0) continue;
      if (mode === "equal" && diff !== 0) continue;

      list.push({ key, name: g.name, in: inC, out: outC, diff, total });
    }

    list.sort((a,b) => {
      const k = state.sortSummary.key;
      const dir = state.sortSummary.dir;
      if (k === "name") return cmpKo(a.name, b.name, dir);
      if (k === "in") return compare(a.in, b.in, dir) || cmpKo(a.name, b.name, "asc");
      if (k === "out") return compare(a.out, b.out, dir) || cmpKo(a.name, b.name, "asc");
      if (k === "diff") return compare(a.diff, b.diff, dir) || cmpKo(a.name, b.name, "asc");
      if (k === "total") return compare(a.total, b.total, dir) || cmpKo(a.name, b.name, "asc");
      return cmpKo(a.name, b.name, "asc");
    });

    const displayKeys = list.map(x => x.key);
    setActiveLastKeys(displayKeys);
    updateSummarySelectionMeta(displayKeys);

    el.summaryTableBody.innerHTML = "";
    const frag = document.createDocumentFragment();

    for (const r of list) {
      const tr = document.createElement("tr");
      tr.className = "clickable";
      tr.dataset.key = r.key;

      const checked = selectedSet.has(r.key);

      const diffPill =
        r.diff > 0 ? `<span class="pill red">+${r.diff}</span>` :
        r.diff < 0 ? `<span class="pill blue">${r.diff}</span>` :
        `<span class="pill gray">0</span>`;

      tr.innerHTML = `
        <td class="td-check">
          <input type="checkbox" class="summaryRowCheck" ${checked ? "checked" : ""} aria-label="항목 선택" />
        </td>
        <td><b>${escapeHtml(r.name)}</b></td>
        <td class="numeric">${r.out}</td>
        <td class="numeric">${r.in}</td>
        <td class="numeric">${r.total}</td>
        <td class="numeric">${diffPill}</td>
      `;

      // checkbox handlers (stop row click)
      const cb = tr.querySelector(".summaryRowCheck");
      cb.addEventListener("click", (e) => e.stopPropagation());
      cb.addEventListener("change", (e) => {
        e.stopPropagation();
        if (cb.checked) selectedSet.add(r.key);
        else selectedSet.delete(r.key);
        updateSummarySelectionMeta(getActiveLastKeys());
      });

      tr.addEventListener("mouseenter", (e) => {
        const html = `
          <div><b>${escapeHtml(r.name)}</b></div>
          <div class="mini" style="margin-top:6px;">
            전출 <b>${r.out}</b> · 전입 <b>${r.in}</b> · 총변동 <b>${r.total}</b> · 차이 <b>${escapeHtml(r.diff>0?`+${r.diff}`:String(r.diff))}</b>
          </div>
          <div class="mini muted" style="margin-top:6px;">행 클릭: 상세로 이동 · 체크: 선택 엑셀 저장 대상</div>
        `;
        showTooltip(html, e.clientX, e.clientY);
      });
      tr.addEventListener("mousemove", (e) => {
        if (el.tooltip.style.display === "block") showTooltip(el.tooltip.innerHTML, e.clientX, e.clientY);
      });
      tr.addEventListener("mouseleave", hideTooltip);

      tr.addEventListener("click", () => {
        state.selectedWorkplaceKey = r.key;
        renderWorkplaceSelect();
        renderJobSelect();
        renderWorkplaceDetail();
        document.getElementById("detailSection")?.scrollIntoView({ behavior:"smooth", block:"start" });
      });

      frag.appendChild(tr);
    }

    el.summaryTableBody.appendChild(frag);
    renderSortIndicators(document.getElementById("summaryTable"), state.sortSummary);
  }

  // ---------------------------
  // Rendering: Suspect list
  // ---------------------------
  function renderSuspect() {
    const q = el.suspectSearch.value || "";
    const type = el.suspectType.value;

    const order = getActiveGroupOrder();
    const groups = getActiveGroupMap();

    const rows = [];
    for (const key of order) {
      const g = groups.get(key);
      if (!g) continue;

      for (const [, j] of g.jobs) {
        const inC = j.inMoves.length;
        const outC = j.outMoves.length;
        const diff = outC - inC;
        if (diff <= 0) continue;

        const jobName = j.jobName;
        const staffType = j.staffType;

        if (type !== "ALL" && staffType !== type) continue;

        if (q) {
          const hay = `${g.name} ${jobName} ${staffType}`;
          if (!includesNorm(hay, q)) continue;
        }

        rows.push({
          workplaceKey: g.key,
          workplace: g.name,
          staffType,
          jobKey: j.jobKey,
          jobName,
          in: inC,
          out: outC,
          diff,
        });
      }
    }

    rows.sort((a,b) => {
      const k = state.sortSuspect.key;
      const dir = state.sortSuspect.dir;
      if (k === "staffType") return cmpKo(a.staffType, b.staffType, dir) || cmpKo(a.workplace, b.workplace, "asc");
      if (k === "workplace") return cmpKo(a.workplace, b.workplace, dir) || cmpKo(a.jobName, b.jobName, "asc");
      if (k === "jobName") return cmpKo(a.jobName, b.jobName, dir);
      if (k === "in") return compare(a.in, b.in, dir) || compare(a.diff, b.diff, "desc");
      if (k === "out") return compare(a.out, b.out, dir) || compare(a.diff, b.diff, "desc");
      if (k === "diff") return compare(a.diff, b.diff, dir) || cmpKo(a.workplace, b.workplace, "asc");
      return compare(a.diff, b.diff, "desc");
    });

    el.suspectStats.textContent = `결원 의심 ${rows.length}건`;

    el.suspectTableBody.innerHTML = "";
    const frag = document.createDocumentFragment();

    for (const r of rows) {
      const tr = document.createElement("tr");
      tr.className = "clickable";
      tr.dataset.workplaceKey = r.workplaceKey;
      tr.dataset.jobKey = r.jobKey;

      tr.innerHTML = `
        <td>${escapeHtml(r.staffType)}</td>
        <td><b>${escapeHtml(r.workplace)}</b></td>
        <td>${escapeHtml(r.jobName)}</td>
        <td class="numeric">${r.out}</td>
        <td class="numeric">${r.in}</td>
        <td class="numeric"><span class="pill red">+${r.diff}</span></td>
      `;

      tr.addEventListener("mouseenter", (e) => {
        const html = `
          <div><b>${escapeHtml(r.workplace)}</b></div>
          <div class="mini">[${escapeHtml(r.staffType)}] ${escapeHtml(r.jobName)}</div>
          <div class="mini" style="margin-top:6px;">
            전출 <b>${r.out}</b> · 전입 <b>${r.in}</b> · 결원 의심 <b>+${r.diff}</b>
          </div>
          <div class="mini muted" style="margin-top:6px;">클릭하면 2) 상세에서 명단을 확인할 수 있습니다.</div>
        `;
        showTooltip(html, e.clientX, e.clientY);
      });
      tr.addEventListener("mousemove", (e) => {
        if (el.tooltip.style.display === "block") showTooltip(el.tooltip.innerHTML, e.clientX, e.clientY);
      });
      tr.addEventListener("mouseleave", hideTooltip);

      tr.addEventListener("click", () => {
        state.selectedWorkplaceKey = r.workplaceKey;
        state.selectedJobKey = r.jobKey;

        renderWorkplaceSelect();
        renderJobSelect();
        renderWorkplaceDetail();

        el.jobSelect.value = r.jobKey;
        renderListsForSelectedJob();

        setTimeout(() => {
          const trs = [...el.jobTableBody.querySelectorAll("tr")];
          trs.forEach(t => t.classList.remove("is-selected"));
          const hit = trs.find(t => t.dataset.jobKey === r.jobKey);
          if (hit) hit.classList.add("is-selected");
        }, 0);

        document.getElementById("detailSection")?.scrollIntoView({ behavior:"smooth", block:"start" });
      });

      frag.appendChild(tr);
    }

    el.suspectTableBody.appendChild(frag);
    renderSortIndicators(document.getElementById("suspectTable"), state.sortSuspect);
  }

  // ---------------------------
  // File selection / drag & drop
  // ---------------------------
  function updateFileMeta() {
    const n = state.files.length;
    el.fileMeta.textContent = n ? `선택됨: ${n}개 · 총 ${bytesToHuman(state.files.reduce((a,f)=>a+f.size,0))}` : "";
    el.fileListSummary.textContent = `선택된 파일 (${n}개)`;
  }

  function renderFileList() {
    el.fileList.innerHTML = "";
    const frag = document.createDocumentFragment();
    for (const f of state.files) {
      const li = document.createElement("li");
      li.innerHTML = `
        <div class="wrap-any"><b>${escapeHtml(f.name)}</b></div>
        <div class="mini muted">${bytesToHuman(f.size)} · 수정 ${escapeHtml(new Date(f.lastModified).toLocaleString())}</div>
      `;
      frag.appendChild(li);
    }
    el.fileList.appendChild(frag);
  }

  function setFiles(files) {
    state.files = Array.from(files || []);
    updateFileMeta();
    renderFileList();
  }

  // ---------------------------
  // Dedupe helpers
  // ---------------------------
  function resetDedupe() {
    state.dedupe.strictSeen = new Set();
    state.dedupe.strictSkipped = 0;
    state.dedupe.looseMap = new Map();
    state.dedupe.looseCollisions = 0;
    state.dedupe.looseExamples = [];
  }

  function makeStrictKey(m) {
    return [
      m.sheetName,
      m.seq,
      m.staffType,
      m.jobName,
      m.name,
      m.inWorkplace,
      m.outWorkplace,
      m.note
    ].join("||");
  }

  function makeLooseKey(m) {
    return [
      m.sheetName,
      m.seq,
      m.staffType,
      m.jobName,
      m.name,
      m.inWorkplace,
      m.outWorkplace
    ].join("||");
  }

  function tryDedupe(m) {
    const strictKey = makeStrictKey(m);
    if (state.dedupe.strictSeen.has(strictKey)) {
      state.dedupe.strictSkipped++;
      return false;
    }
    state.dedupe.strictSeen.add(strictKey);

    const looseKey = makeLooseKey(m);
    const prev = state.dedupe.looseMap.get(looseKey);
    if (prev !== undefined && prev !== m.note) {
      state.dedupe.looseCollisions++;
      if (state.dedupe.looseExamples.length < 12) {
        state.dedupe.looseExamples.push({
          name: m.name,
          jobName: m.jobName,
          inWorkplace: m.inWorkplace,
          outWorkplace: m.outWorkplace,
          noteA: prev,
          noteB: m.note,
          sheetName: m.sheetName,
          seq: m.seq,
        });
      }
    } else if (prev === undefined) {
      state.dedupe.looseMap.set(looseKey, m.note);
    }

    return true;
  }

  // ---------------------------
  // ✅ XLSX export helpers
  // ---------------------------
  function pad2(n){ return String(n).padStart(2,"0"); }
  function nowStamp() {
    const d = new Date();
    return `${d.getFullYear()}${pad2(d.getMonth()+1)}${pad2(d.getDate())}_${pad2(d.getHours())}${pad2(d.getMinutes())}`;
  }

  function sanitizeFileName(name) {
    return String(name || "인사집계").replace(/[\\/:*?"<>|]/g, "_");
  }

  function sanitizeSheetName(name) {
    let s = String(name || "시트");
    // Excel sheet invalid chars: \ / ? * [ ] :
    s = s.replace(/[\\\/\?\*\[\]:]/g, "_").trim();
    if (!s) s = "시트";
    // limit 31
    if (s.length > 31) s = s.slice(0, 31);
    return s;
  }

  function uniqueSheetName(base, used) {
    let name = sanitizeSheetName(base);
    if (!used.has(name)) { used.add(name); return name; }

    let i = 2;
    while (i < 1000) {
      const suffix = `_${i}`;
      const cut = Math.max(1, 31 - suffix.length);
      const candidate = sanitizeSheetName(name.slice(0, cut) + suffix);
      if (!used.has(candidate)) { used.add(candidate); return candidate; }
      i++;
    }
    // extreme fallback
    const fallback = `시트_${used.size+1}`;
    used.add(fallback);
    return fallback;
  }

  function buildSummaryAoa(groupKeys) {
    const firstCol = groupLabel();
    const rows = [[firstCol, "전출", "전입", "총 인사변동", "차이(전출-전입)"]];
    const groups = getActiveGroupMap();

    for (const key of groupKeys) {
      const g = groups.get(key);
      if (!g) continue;
      const inC = g.inMoves.length;
      const outC = g.outMoves.length;
      const diff = outC - inC;
      const total = inC + outC;
      rows.push([g.name, outC, inC, total, diff]);
    }
    return rows;
  }

  function buildGroupDetailAoa(g) {
    const firstCol = `${groupLabel()}(기준)`;
    const rows = [[
      firstCol,
      "구분",
      "성명",
      "직종(직급·과목)",
      "직군(구분)",
      "전출(현소속) 근무지",
      "전입(발령) 근무지",
      "비고",
      "파일",
      "시트",
      "행"
    ]];

    const outMoves = g.outMoves.slice().sort((a,b)=>a.seq-b.seq);
    const inMoves  = g.inMoves.slice().sort((a,b)=>a.seq-b.seq);

    for (const m of outMoves) {
      rows.push([
        g.name,
        "전출",
        displayName(m.name),
        m.jobName,
        m.staffType,
        m.outWorkplace,
        m.inWorkplace,
        m.note,
        m.fileName,
        m.sheetName,
        m.rowIndex
      ]);
    }
    for (const m of inMoves) {
      rows.push([
        g.name,
        "전입",
        displayName(m.name),
        m.jobName,
        m.staffType,
        m.outWorkplace,
        m.inWorkplace,
        m.note,
        m.fileName,
        m.sheetName,
        m.rowIndex
      ]);
    }
    return rows;
  }

  function buildSuspectAoa(groupKeysSetOrNull) {
    const firstCol = groupLabel();
    const rows = [["구분", firstCol, "직종(직급·과목)", "전출", "전입", "결원 의심(전출-전입)"]];

    const order = getActiveGroupOrder();
    const groups = getActiveGroupMap();

    for (const key of order) {
      if (groupKeysSetOrNull && !groupKeysSetOrNull.has(key)) continue;
      const g = groups.get(key);
      if (!g) continue;
      for (const [, j] of g.jobs) {
        const inC = j.inMoves.length;
        const outC = j.outMoves.length;
        const diff = outC - inC;
        if (diff <= 0) continue;
        rows.push([j.staffType, g.name, j.jobName, outC, inC, diff]);
      }
    }
    return rows;
  }

  function buildDedupeExamplesAoa() {
    const rows = [["시트", "연번", "성명", "직종", "전출→전입", "note(기존)", "note(신규)"]];
    for (const ex of state.dedupe.looseExamples) {
      rows.push([
        ex.sheetName,
        ex.seq,
        ex.name,
        ex.jobName,
        `${ex.outWorkplace} → ${ex.inWorkplace}`,
        ex.noteA,
        ex.noteB
      ]);
    }
    return rows;
  }

  function downloadWorkbookForKeys(groupKeys, filenameBase) {
    if (!state.analyzed) return;
    if (!window.XLSX) {
      alert("엑셀(XLSX) 라이브러리가 로드되지 않아 저장할 수 없습니다.");
      return;
    }
    const keys = Array.from(groupKeys || []).filter(Boolean);
    if (!keys.length) {
      alert("저장할 항목이 없습니다.");
      return;
    }

    const wb = XLSX.utils.book_new();
    const used = new Set();

    // 요약
    const wsSummary = XLSX.utils.aoa_to_sheet(buildSummaryAoa(keys));
    XLSX.utils.book_append_sheet(wb, wsSummary, uniqueSheetName("요약", used));

    // 결원의심(선택 범위 기준)
    const wsSus = XLSX.utils.aoa_to_sheet(buildSuspectAoa(new Set(keys)));
    XLSX.utils.book_append_sheet(wb, wsSus, uniqueSheetName("결원의심", used));

    // 중복 의심 예시(있으면)
    if (state.dedupe.looseExamples.length) {
      const wsDup = XLSX.utils.aoa_to_sheet(buildDedupeExamplesAoa());
      XLSX.utils.book_append_sheet(wb, wsDup, uniqueSheetName("중복의심예시", used));
    }

    // 그룹별 시트
    const groups = getActiveGroupMap();
    for (const key of keys) {
      const g = groups.get(key);
      if (!g) continue;
      const aoa = buildGroupDetailAoa(g);
      const ws = XLSX.utils.aoa_to_sheet(aoa);
      XLSX.utils.book_append_sheet(wb, ws, uniqueSheetName(g.name, used));
    }

    const file = sanitizeFileName(`${filenameBase}_${keys.length}개_${nowStamp()}.xlsx`);
    XLSX.writeFile(wb, file);
    log(`엑셀 다운로드: ${file}`);
  }

  function downloadXlsxAll() {
    const keys = getActiveGroupOrder();
    downloadWorkbookForKeys(keys, `인사집계_${groupLabel()}_전체`);
  }

  function downloadXlsxSelected() {
    const keys = [...getActiveSelectedSet()];
    if (!keys.length) {
      alert("선택된 항목이 없습니다. (요약 표에서 체크 후 다시 시도)");
      return;
    }
    // 정렬된 순서로 저장
    const order = getActiveGroupOrder();
    const orderSet = new Set(keys);
    const ordered = order.filter(k => orderSet.has(k));
    downloadWorkbookForKeys(ordered, `인사집계_${groupLabel()}_선택`);
  }

  function clearSelectedSchools() {
    getActiveSelectedSet().clear();
    updateSummarySelectionMeta(getActiveLastKeys());
    renderSummary();
  }

  // ---------------------------
  // CSV downloads
  // ---------------------------
  function downloadSummaryCsv() {
    if (!state.analyzed) return;

    const q = el.summarySearch.value || "";
    const mode = el.summaryFilter.value;

    const firstCol = groupLabel();
    const rows = [[firstCol, "전출", "전입", "총 인사변동", "차이(전출-전입)"]];

    const order = getActiveGroupOrder();
    const groups = getActiveGroupMap();

    const list = [];
    for (const key of order) {
      const g = groups.get(key);
      if (!g) continue;
      if (q && !includesNorm(g.name, q)) continue;

      const inC = g.inMoves.length;
      const outC = g.outMoves.length;
      const diff = outC - inC;
      const total = inC + outC;

      if (mode === "outMore" && diff <= 0) continue;
      if (mode === "inMore" && diff >= 0) continue;
      if (mode === "equal" && diff !== 0) continue;

      list.push({ name: g.name, in: inC, out: outC, diff, total });
    }

    list.sort((a,b) => a.name.localeCompare(b.name, "ko"));
    for (const r of list) rows.push([r.name, r.out, r.in, r.total, r.diff]);

    downloadCsv(`${firstCol}_요약.csv`, rows);
    log("CSV 다운로드: 현재 요약");
  }

  function downloadSuspectCsv() {
    if (!state.analyzed) return;
    const q = el.suspectSearch.value || "";
    const type = el.suspectType.value;

    const firstCol = groupLabel();
    const rows = [["구분", firstCol, "직종(직급·과목)", "결원 의심(전출-전입)", "전출", "전입"]];
    const list = [];

    const order = getActiveGroupOrder();
    const groups = getActiveGroupMap();

    for (const key of order) {
      const g = groups.get(key);
      if (!g) continue;

      for (const [, j] of g.jobs) {
        const inC = j.inMoves.length;
        const outC = j.outMoves.length;
        const diff = outC - inC;
        if (diff <= 0) continue;

        const staffType = j.staffType;
        const jobName = j.jobName;

        if (type !== "ALL" && staffType !== type) continue;
        if (q) {
          const hay = `${g.name} ${jobName} ${staffType}`;
          if (!includesNorm(hay, q)) continue;
        }

        list.push({ staffType, workplace: g.name, jobName, diff, outC, inC });
      }
    }

    list.sort((a,b)=> (b.diff-a.diff) || a.workplace.localeCompare(b.workplace,"ko"));
    for (const r of list) rows.push([r.staffType, r.workplace, r.jobName, r.diff, r.outC, r.inC]);

    downloadCsv(`결원의심_${firstCol}.csv`, rows);
    log("CSV 다운로드: 결원 의심 목록");
  }

  function downloadDetailCsv() {
    if (!state.analyzed) return;

    const groups = getActiveGroupMap();
    const g = groups.get(state.selectedWorkplaceKey);
    if (!g) return;

    const jobKey = state.selectedJobKey;

    let inMoves = [];
    let outMoves = [];
    let jobLabel = "전체";

    if (jobKey === "ALL") {
      inMoves = g.inMoves.slice();
      outMoves = g.outMoves.slice();
    } else {
      const agg = g.jobs.get(jobKey);
      if (agg) {
        inMoves = agg.inMoves.slice();
        outMoves = agg.outMoves.slice();
        jobLabel = `[${agg.staffType}] ${agg.jobName}`;
      }
    }

    inMoves.sort((a,b)=>a.seq-b.seq);
    outMoves.sort((a,b)=>a.seq-b.seq);

    const firstCol = groupLabel();
    const rows = [[firstCol, "직종(선택)", "구분", "성명", "전입(발령) 근무지", "전출(현소속) 근무지", "비고", "파일", "시트", "행"]];
    for (const m of outMoves) rows.push([g.name, jobLabel, "전출", displayName(m.name), m.inWorkplace, m.outWorkplace, m.note, m.fileName, m.sheetName, m.rowIndex]);
    for (const m of inMoves) rows.push([g.name, jobLabel, "전입", displayName(m.name), m.inWorkplace, m.outWorkplace, m.note, m.fileName, m.sheetName, m.rowIndex]);

    downloadCsv(`${g.name}_${jobLabel}_상세.csv`, rows);
    log("CSV 다운로드: 현재 상세");
  }

  // ---------------------------
  // Analysis
  // ---------------------------
  async function analyzeAllFiles() {
    clearLog();
    hideTooltip();

    if (!state.files.length) {
      log("파일이 선택되지 않았습니다.");
      return;
    }

    startProgress("집계 준비 중...");
    setProgress(1, "설정/옵션 확인 중...");
    await rafTick();

    el.btnAnalyze.disabled = true;

    try {
      // ✅ 현재 UI 설정 반영
      state.groupMode = el.groupMode?.value || "workplace";
      state.sggTokens = buildSggTokens();
      updateGroupUiText();

      state.heur = buildHeuristics();
      state.maskNames = !!el.optMaskNames.checked;
      el.optMaskNamesQuick.checked = state.maskNames;

      // selection reset (새 집계 기준)
      state.summarySelectedWorkplace.clear();
      state.summarySelectedSgg.clear();
      state.summaryLastKeysWorkplace = [];
      state.summaryLastKeysSgg = [];
      if (el.summaryCheckAll) {
        el.summaryCheckAll.checked = false;
        el.summaryCheckAll.indeterminate = false;
      }

      setProgress(3, "엑셀 파서(XLSX) 준비 중...");
      await rafTick();

      const ok = await ensureXLSX();
      setLibWarning(ok);
      if (!ok) {
        log("XLSX 라이브러리 없음 → 중단");
        setProgress(0, "엑셀 파서(XLSX) 로드 실패");
        return;
      }

      el.btnAnalyze.disabled = true;

      const seqIdxManual = colToIndex(el.colSeq.value);
      const nameIdxManual = colToIndex(el.colName.value);
      const jobIdxManual = colToIndex(el.colJob.value);
      const inIdxManual = colToIndex(el.colIn.value);
      const outIdxManual = colToIndex(el.colOut.value);
      const noteIdxManual = colToIndex(el.colNote.value);

      const badCols = [
        ["연번", seqIdxManual],
        ["성명", nameIdxManual],
        ["직종", jobIdxManual],
        ["전입", inIdxManual],
        ["전출", outIdxManual],
        ["비고", noteIdxManual],
      ].filter(([, idx]) => idx === null);

      if (badCols.length) {
        log("수동 컬럼 입력이 잘못되었습니다: " + badCols.map(([k]) => k).join(", "));
        setProgress(0, "수동 컬럼 입력 오류");
        return;
      }

      const autoOn = el.optAutoDetect.checked;
      const normalizeOn = el.optNormalize.checked;
      const prefixOn = el.optPrefixRegion.checked;
      const useSubject = el.optUseSubject.checked;

      state.moves = [];
      state.workplaces.clear();
      state.workplaceOrder = [];
      state.districts.clear();
      state.districtOrder = [];
      state.analyzed = false;
      state.selectedWorkplaceKey = "";
      state.selectedJobKey = "ALL";
      state.regionTags.clear();
      state.stats = null;
      resetDedupe();

      el.analyzeBanner.style.display = "none";

      log(`집계 시작: 파일 ${state.files.length}개`);
      setProgress(5, `파일 ${state.files.length}개 집계 시작...`);
      await rafTick();

      const totalFiles = state.files.length;

      for (let fi = 0; fi < totalFiles; fi++) {
        const file = state.files[fi];
        const regionTag = inferRegionTag(file.name);
        state.regionTags.set(file.name, regionTag);

        const fileBaseRatio = fi / Math.max(1, totalFiles);
        setProgress(5 + 85 * fileBaseRatio, `[${fi + 1}/${totalFiles}] 파일 읽는 중: ${file.name}`);
        await rafTick();

        log(`\n[파일] ${file.name}${regionTag ? ` (태그: ${regionTag})` : ""}`);

        let wb = null;
        try {
          const buf = await file.arrayBuffer();
          wb = XLSX.read(buf, { type: "array" });
        } catch (err) {
          log(`  ⚠️ 파일 읽기 실패: ${err?.message || err}`);
          continue;
        }

        const sheetNames = wb.SheetNames.slice();
        log(`  시트 ${sheetNames.length}개: ${sheetNames.join(", ")}`);

        const sheetsTotal = Math.max(1, sheetNames.length);

        for (let si = 0; si < sheetNames.length; si++) {
          const sheetName = sheetNames[si];

          const ratio = (fi + (si / sheetsTotal)) / Math.max(1, totalFiles);
          setProgress(5 + 85 * ratio, `[${fi + 1}/${totalFiles}] ${file.name} · 시트 ${si + 1}/${sheetsTotal} 처리 중: ${sheetName}`);
          await rafTick();

          const ws = wb.Sheets[sheetName];
          const rows = XLSX.utils.sheet_to_json(ws, { header: 1, defval: "" });
          if (!rows || rows.length < 3) continue;

          let layout = null;
          if (autoOn) {
            layout = detectLayoutPlus(rows, state.heur);
            if (layout) {
              log(`  - [${sheetName}] 자동감지 OK: seq=${layout.seqIdx>=0?indexToCol(layout.seqIdx):"(없음)"} name=${indexToCol(layout.nameIdx)} job=${layout.jobIdx>=0?indexToCol(layout.jobIdx):"(없음)"} in=${layout.inIdx>=0?indexToCol(layout.inIdx):"(없음)"} out=${layout.outIdx>=0?indexToCol(layout.outIdx):"(없음)"} note=${layout.noteIdx>=0?indexToCol(layout.noteIdx):"(없음)"} subj=${layout.subjectIdx>=0?indexToCol(layout.subjectIdx):"(없음)"} startRow=${layout.dataStart+1}`);
            } else {
              log(`  - [${sheetName}] 자동감지 실패 → 수동 매핑 사용`);
            }
          }

          const seqIdx = layout ? layout.seqIdx : seqIdxManual;
          const nameIdx = layout ? layout.nameIdx : nameIdxManual;
          const jobIdx = (layout && layout.jobIdx >= 0) ? layout.jobIdx : jobIdxManual;
          const inIdx = layout ? layout.inIdx : inIdxManual;
          const outIdx = layout ? layout.outIdx : outIdxManual;
          const noteIdx = (layout && layout.noteIdx >= 0) ? layout.noteIdx : noteIdxManual;
          const subjectIdx = layout ? layout.subjectIdx : -1;

          const dataStart = layout ? layout.dataStart : 0;

          const outStats = (outIdx >= 0) ? analyzeColumnStats(rows, dataStart, outIdx, state.heur, 200) : null;
          const noteStats = (noteIdx >= 0) ? analyzeColumnStats(rows, dataStart, noteIdx, state.heur, 200) : null;

          let noteHeaderKey = "";
          if (layout && layout.fieldKeys && noteIdx >= 0) noteHeaderKey = layout.fieldKeys[noteIdx] || "";
          else {
            for (let rr = 0; rr < Math.min(rows.length, 8); rr++) {
              const k = cellKey((rows[rr] || [])[noteIdx]);
              if (k) { noteHeaderKey = k; break; }
            }
          }

          const useNoteAsOut =
            !!(outStats && noteStats) &&
            noteIdx >= 0 &&
            noteHeaderSuggestsPrevAffiliation(noteHeaderKey) &&
            outStats.uniqueCount <= 3 &&
            outStats.eduOfficeLikeRatio >= 0.55 &&
            outStats.schoolLikeRatio < 0.25 &&
            noteStats.schoolLikeRatio >= 0.25;

          if (useNoteAsOut) {
            log(`    ↳ 비고(전소속) 기반 '전출 근무지' 보정 적용(현소속 컬럼이 교육지원청 위주로 판단됨)`);
          }

          let recordCount = 0;

          for (let r = dataStart; r < rows.length; r++) {
            const row = rows[r] || [];

            if (seqIdx >= 0) {
              const seq = toIntLike(row[seqIdx]);
              if (seq === null) continue;
            } else {
              if (!state.heur.looksLikeName(row[nameIdx])) continue;
            }

            const seq = (seqIdx >= 0 ? (toIntLike(row[seqIdx]) ?? 0) : (r + 1));
            const name = normalizeSpaces(row[nameIdx]);
            if (!name) continue;

            let baseJob = (jobIdx >= 0 ? normalizeSpaces(row[jobIdx]) : "");
            if (!baseJob) baseJob = sheetName;

            const subject = (useSubject && subjectIdx >= 0) ? normalizeSpaces(row[subjectIdx]) : "";
            const jobName = subject ? `${baseJob}(${subject})` : baseJob;

            const staffType = detectStaffType(file.name, sheetName, jobName);
            const jobKey = `${staffType}||${jobName}`;

            const inPlaceRaw = (inIdx >= 0 ? row[inIdx] : "");
            const outPlaceRaw = (outIdx >= 0 ? row[outIdx] : "");
            const noteRaw = (noteIdx >= 0 ? row[noteIdx] : "");

            let inWorkplace = normalizeWorkplace(inPlaceRaw, regionTag, { normalizeOn, prefixOn });
            let outWorkplace = normalizeWorkplace(outPlaceRaw, regionTag, { normalizeOn, prefixOn });

            const note = normalizeSpaces(noteRaw);

            if (useNoteAsOut && note) {
              const inferred = parsePlaceFromNote(note, state.heur);
              if (inferred) outWorkplace = normalizeWorkplace(inferred, regionTag, { normalizeOn, prefixOn });
            }

            // ✅ 시군구 추출
            const inSgg = inferSgg(inWorkplace);
            const outSgg = inferSgg(outWorkplace);

            const move = {
              fileName: file.name,
              sheetName,
              regionTag,
              staffType,
              seq,
              name,
              jobName,
              jobKey,
              inWorkplace: inWorkplace || "",
              outWorkplace: outWorkplace || "",
              inSgg: inSgg || "",
              outSgg: outSgg || "",
              note,
              rowIndex: r + 1,
            };

            if (!tryDedupe(move)) continue;

            addMove(move);
            recordCount++;

            if (recordCount % 900 === 0) await rafTick();
          }

          if (recordCount) log(`    → [${sheetName}] 반영 ${recordCount}건`);
          else log(`    → [${sheetName}] 데이터 행을 찾지 못함(서식/헤더 확인 필요)`);
        }
      }

      setProgress(93, "집계 결과 정리/렌더링 중...");
      await rafTick();

      state.workplaceOrder = [...state.workplaces.values()]
        .sort((a,b) => a.name.localeCompare(b.name, "ko"))
        .map(g => g.key);

      state.districtOrder = [...state.districts.values()]
        .sort((a,b) => a.name.localeCompare(b.name, "ko"))
        .map(g => g.key);

      const totalRecords = state.moves.length;
      const totalIn = state.moves.reduce((acc,m)=>acc + (m.inWorkplace ? 1 : 0), 0);
      const totalOut = state.moves.reduce((acc,m)=>acc + (m.outWorkplace ? 1 : 0), 0);
      const netDiff = totalOut - totalIn;
      const onlyIn = state.moves.reduce((acc,m)=>acc + (m.inWorkplace && !m.outWorkplace ? 1 : 0), 0);
      const onlyOut = state.moves.reduce((acc,m)=>acc + (m.outWorkplace && !m.inWorkplace ? 1 : 0), 0);
      const both = state.moves.reduce((acc,m)=>acc + (m.inWorkplace && m.outWorkplace ? 1 : 0), 0);

      state.stats = { totalRecords, totalIn, totalOut, netDiff, onlyIn, onlyOut, both };

      state.analyzed = true;

      log(`\n집계 완료 ✅`);
      log(`- 총 이동 레코드(중복 제거 후): ${totalRecords}건`);
      log(`- 근무지 수: ${state.workplaceOrder.length}개 · 시군구 수: ${state.districtOrder.length}개`);
      log(`- 중복(완전 동일) 제외: ${state.dedupe.strictSkipped}건`);
      if (state.dedupe.looseCollisions > 0) {
        log(`- 중복 의심(일부 값 상이): ${state.dedupe.looseCollisions}건`);
        for (const ex of state.dedupe.looseExamples) {
          log(`  · [의심] ${ex.sheetName} ${ex.seq} ${ex.name} / ${ex.jobName} / ${ex.outWorkplace}→${ex.inWorkplace} / note: "${ex.noteA}" vs "${ex.noteB}"`);
        }
      }

      // ✅ 현재 보기 모드 기준 첫 항목 선택
      state.selectedWorkplaceKey = getActiveGroupOrder()[0] || "";
      state.selectedJobKey = "ALL";

      el.detailSection.style.display = "";
      el.summarySection.style.display = "";
      el.suspectSection.style.display = "";

      renderAnalyzeBanner();
      renderWorkplaceSelect();
      renderJobSelect();
      renderWorkplaceDetail();
      renderSummary();
      renderSuspect();

      doneProgress("집계 완료 ✅");
    } catch (err) {
      console.error(err);
      log("에러: " + (err?.message || err));
      setProgress(0, "에러로 중단됨: " + (err?.message || err));
    } finally {
      const ok = !!window.XLSX;
      setLibWarning(ok);
      if (ok) el.btnAnalyze.disabled = false;
    }
  }

  // ---------------------------
  // Events: table header sorting
  // ---------------------------
  function bindSortableHeaders() {
    const summaryTable = document.getElementById("summaryTable");
    const suspectTable = document.getElementById("suspectTable");
    const jobTable = document.getElementById("jobTable");

    summaryTable.querySelectorAll("thead th.sortable").forEach(th => {
      th.addEventListener("click", () => {
        toggleSort(state.sortSummary, th.dataset.sort);
        renderSummary();
      });
    });

    suspectTable.querySelectorAll("thead th.sortable").forEach(th => {
      th.addEventListener("click", () => {
        toggleSort(state.sortSuspect, th.dataset.sort);
        renderSuspect();
      });
    });

    jobTable.querySelectorAll("thead th.sortable").forEach(th => {
      th.addEventListener("click", () => {
        toggleSort(state.sortJobs, th.dataset.sort);
        renderWorkplaceDetail();
      });
    });
  }

  // ---------------------------
  // Init / Events
  // ---------------------------
  function wire() {
    // file input
    el.fileInput.addEventListener("change", () => {
      const files = el.fileInput.files ? Array.from(el.fileInput.files) : [];
      setFiles(files);
      log(`파일 선택: ${files.length}개`);
    });

    // dropzone click -> open picker
    el.dropZone.addEventListener("click", () => el.fileInput.click());
    el.dropZone.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        el.fileInput.click();
      }
    });

    // drag & drop
    ["dragenter","dragover"].forEach(evt => {
      el.dropZone.addEventListener(evt, (e) => {
        e.preventDefault();
        e.stopPropagation();
        el.dropZone.classList.add("dragover");
      });
    });
    ["dragleave","drop"].forEach(evt => {
      el.dropZone.addEventListener(evt, (e) => {
        e.preventDefault();
        e.stopPropagation();
        el.dropZone.classList.remove("dragover");
      });
    });
    el.dropZone.addEventListener("drop", (e) => {
      const dt = e.dataTransfer;
      const files = dt && dt.files ? Array.from(dt.files) : [];
      const filtered = files.filter(f => /\.(xlsx|xls)$/i.test(f.name));
      setFiles(filtered);
      log(`드롭 업로드: ${filtered.length}개`);
    });

    // analyze
    el.btnAnalyze.addEventListener("click", () => {
      analyzeAllFiles().catch(err => {
        console.error(err);
        log("에러: " + (err?.message || err));
      });
    });

    // clear
    el.btnClear.addEventListener("click", () => {
      setFiles([]);
      state.analyzed = false;
      state.moves = [];
      state.workplaces.clear();
      state.workplaceOrder = [];
      state.districts.clear();
      state.districtOrder = [];
      state.selectedWorkplaceKey = "";
      state.selectedJobKey = "ALL";
      state.stats = null;
      resetDedupe();

      state.summarySelectedWorkplace.clear();
      state.summarySelectedSgg.clear();
      state.summaryLastKeysWorkplace = [];
      state.summaryLastKeysSgg = [];

      el.analyzeBanner.style.display = "none";
      hideProgress();

      el.detailSection.style.display = "none";
      el.summarySection.style.display = "none";
      el.suspectSection.style.display = "none";

      el.workplaceSearch.value = "";
      el.summarySearch.value = "";
      el.suspectSearch.value = "";

      if (el.summaryCheckAll) {
        el.summaryCheckAll.checked = false;
        el.summaryCheckAll.indeterminate = false;
      }

      clearLog();
      log("초기화 완료");
    });

    // ✅ group mode change: 재렌더
    el.groupMode.addEventListener("change", () => {
      state.groupMode = el.groupMode.value;
      updateGroupUiText();

      if (!state.analyzed) return;

      state.selectedWorkplaceKey = getActiveGroupOrder()[0] || "";
      state.selectedJobKey = "ALL";

      renderAnalyzeBanner();
      renderWorkplaceSelect();
      renderJobSelect();
      renderWorkplaceDetail();
      renderSummary();
      renderSuspect();
    });

    // name mask sync (advanced <-> quick)
    const syncMask = (checked) => {
      state.maskNames = !!checked;
      el.optMaskNames.checked = state.maskNames;
      el.optMaskNamesQuick.checked = state.maskNames;

      if (state.analyzed) {
        renderAnalyzeBanner();
        renderWorkplaceDetail();
      }
    };
    el.optMaskNames.addEventListener("change", () => syncMask(el.optMaskNames.checked));
    el.optMaskNamesQuick.addEventListener("change", () => syncMask(el.optMaskNamesQuick.checked));

    // filters (debounced)
    el.workplaceSearch.addEventListener("input", debounce(() => {
      if (!state.analyzed) return;
      renderWorkplaceSelect();
    }, 140));

    el.workplaceSelect.addEventListener("change", () => {
      if (!state.analyzed) return;
      state.selectedWorkplaceKey = el.workplaceSelect.value;
      state.selectedJobKey = "ALL";
      renderJobSelect();
      renderWorkplaceDetail();
    });

    el.jobSelect.addEventListener("change", () => {
      if (!state.analyzed) return;
      state.selectedJobKey = el.jobSelect.value;
      renderListsForSelectedJob();

      const trs = [...el.jobTableBody.querySelectorAll("tr")];
      trs.forEach(t => t.classList.remove("is-selected"));
      const hit = trs.find(t => t.dataset.jobKey === state.selectedJobKey);
      if (hit) hit.classList.add("is-selected");
    });

    el.summarySearch.addEventListener("input", debounce(() => {
      if (!state.analyzed) return;
      renderSummary();
    }, 150));

    el.summaryFilter.addEventListener("change", () => {
      if (!state.analyzed) return;
      renderSummary();
    });

    el.suspectSearch.addEventListener("input", debounce(() => {
      if (!state.analyzed) return;
      renderSuspect();
    }, 150));

    el.suspectType.addEventListener("change", () => {
      if (!state.analyzed) return;
      renderSuspect();
    });

    // summary check all
    el.summaryCheckAll.addEventListener("click", (e) => e.stopPropagation());
    el.summaryCheckAll.addEventListener("change", () => {
      if (!state.analyzed) return;
      const keys = getActiveLastKeys().slice();
      const set = getActiveSelectedSet();
      if (el.summaryCheckAll.checked) keys.forEach(k => set.add(k));
      else keys.forEach(k => set.delete(k));
      renderSummary();
    });

    // downloads
    el.btnDownloadSummary.addEventListener("click", downloadSummaryCsv);
    el.btnDownloadSuspect.addEventListener("click", downloadSuspectCsv);
    el.btnDownloadDetail.addEventListener("click", downloadDetailCsv);

    // xlsx exports
    el.btnDownloadXlsxAll.addEventListener("click", downloadXlsxAll);
    el.btnDownloadXlsxSelected.addEventListener("click", downloadXlsxSelected);
    el.btnClearSelected.addEventListener("click", clearSelectedSchools);

    // tooltip hide
    window.addEventListener("scroll", hideTooltip, { passive:true });
    window.addEventListener("resize", hideTooltip, { passive:true });
    window.addEventListener("click", () => {
      if (el.tooltip.style.display === "block") hideTooltip();
    });

    bindSortableHeaders();
  }

  async function init() {
    log("페이지 로드 완료");
    log("엑셀을 업로드한 뒤 '발령 정보 집계하기'를 누르세요.");
    setFiles([]);
    hideProgress();

    // ✅ 기본 groupMode 반영
    state.groupMode = el.groupMode?.value || "workplace";
    updateGroupUiText();

    const ok = await ensureXLSX();
    setLibWarning(ok);
  }

  document.addEventListener("DOMContentLoaded", () => {
    wire();
    init();
  });
})();
</script>

<script src="/static/disable-copy.js"></script>
<script src="/static/footer.js"></script>
<script src="/static/global-loader.js?v=1"></script>
</body>
</html>
