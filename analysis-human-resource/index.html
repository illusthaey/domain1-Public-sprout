<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>학교별 전입·전출 인사발령자 명단 집계기</title>

  <link id="commonStyle" rel="stylesheet" href="/static/style.css" />
  <script>
    (function () {
      const link = document.getElementById("commonStyle");
      if (!link) return;
      link.addEventListener("error", function () {
        const alt = document.createElement("link");
        alt.rel = "stylesheet";
        alt.href = "static/style.css";
        document.head.appendChild(alt);
        console.warn("[style] /static/style.css 로드 실패 → static/style.css 로 폴백");
      });
    })();
  </script>

  <style>
    :root{
      --bg:#ffffff;
      --ink:#111827;
      --muted:#6b7280;
      --line:#e5e7eb;
      --card:#ffffff;
      --soft:#f9fafb;
      --red:#b91c1c;
      --blue:#1d4ed8;
      --green:#047857;
      --amber:#b45309;
    }
    body{ margin:0; background:var(--bg); color:var(--ink); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple SD Gothic Neo","Noto Sans KR","Malgun Gothic",sans-serif; }
    .shell{ max-width: 1100px; margin:0 auto; padding: 0 16px; }
    .container{ max-width: 1100px; margin: 0 auto; padding: 0 16px 36px; }
    .site-header{ padding: 22px 0 10px; border-bottom:1px solid var(--line); background:#fff; }
    .site-header h1{ margin:0; font-size: 1.55rem; }
    .subtitle{ margin: 8px 0 0; color: var(--muted); line-height: 1.55; text-align:left; }

    .tool-card{ margin: 18px 0; padding: 14px; border:1px solid var(--line); border-radius: 14px; background: var(--card); }
    .tool-head{ display:flex; align-items:flex-start; justify-content:space-between; gap: 12px; flex-wrap: wrap; }
    .tool-title{ margin:0; font-size: 1.15rem; }
    .tool-sub{ margin: 6px 0 0; color: var(--muted); }

    hr{ border:0; border-top:1px solid var(--line); margin: 14px 0; }

    .btn-row{ display:flex; gap:10px; flex-wrap: wrap; justify-content:flex-start; align-items:center; }
    .btn{ appearance:none; border:1px solid var(--line); background: #fff; padding: 9px 12px; border-radius: 10px; cursor:pointer; font-weight: 600; }
    .btn.primary{ background:#111827; color:#fff; border-color:#111827; }
    .btn.ghost{ background: transparent; }
    .btn:disabled{ opacity: .55; cursor:not-allowed; }

    .field{ margin: 10px 0; }
    .field label{ display:block; font-weight: 700; margin-bottom: 6px; }
    .field .help{ color: var(--muted); font-size: .92rem; }

    input[type="text"], textarea, select{
      width: 100%;
      max-width: 100%;
      box-sizing: border-box;
      padding: 10px 12px;
      border:1px solid var(--line);
      border-radius: 10px;
      background:#fff;
      font-size: 1rem;
      color: var(--ink);
      min-width: 0;
    }
    select{
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    select option{
      white-space: normal;
      word-break: break-word;
      max-width: 100%;
    }
    textarea{ resize: vertical; min-height: 92px; }

    .row{ display:flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .row.stretch > *{ flex: 1 1 260px; min-width: 0; }
    .between{ justify-content: space-between; }

    .pill{
      display:inline-block;
      padding: 2px 10px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: var(--soft);
      font-size: 0.9rem;
      line-height: 1.4;
      white-space: nowrap;
    }
    .pill.red{ border-color: #fecaca; background:#fef2f2; color:#991b1b; }
    .pill.blue{ border-color: #bfdbfe; background:#eff6ff; color:#1d4ed8; }
    .pill.green{ border-color: #bbf7d0; background:#f0fdf4; color:#047857; }
    .pill.amber{ border-color: #fed7aa; background:#fff7ed; color:#9a3412; }
    .pill.gray{ border-color: #e5e7eb; background:#f9fafb; color:#6b7280; }

    .muted{ color: var(--muted); }

    .dropzone{
      border: 2px dashed #cbd5e1;
      background: #f8fafc;
      padding: 18px 14px;
      border-radius: 14px;
      text-align:left;
      cursor:pointer;
      outline: none;
    }
    .dropzone strong{ display:block; margin-bottom: 6px; }
    .dropzone.dragover{ border-color: #111827; background: #eef2ff; }

    details{ border:1px solid var(--line); border-radius: 12px; padding: 10px 12px; background:#fff; }
    summary{ cursor:pointer; font-weight: 800; }

    .table-wrap{ width:100%; overflow:auto; border-radius: 12px; border:1px solid var(--line); }
    table{ border-collapse: collapse; width: 100%; min-width: 720px; }
    th, td{ border-bottom:1px solid var(--line); padding: 10px 10px; text-align:left; vertical-align: top; }
    thead th{ position: sticky; top: 0; background: var(--soft); z-index: 2; }
    td.numeric, th.numeric{ text-align:right; }
    tr.clickable:hover{ background: #f3f4f6; cursor:pointer; }
    tr.is-selected{ outline: 2px solid rgba(0,0,0,0.18); outline-offset: -2px; }

    th.sortable{ user-select:none; cursor:pointer; }
    th.sortable:hover{ background: #eef2ff; }
    .sort-ind{ margin-left: 6px; font-size: .9rem; color: var(--muted); }

    .grid-two{ display:grid; grid-template-columns: 1fr 1fr; gap: 14px; }
    @media (max-width: 900px){
      .grid-two{ grid-template-columns: 1fr; }
      table{ min-width: 860px; }
    }

    #tooltip{
      position: fixed;
      z-index: 9999;
      max-width: min(560px, 92vw);
      background: #fff;
      color: #111;
      border: 1px solid #111;
      border-radius: 10px;
      padding: 10px 12px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.12);
      display:none;
      pointer-events:none;
      white-space: normal;
      line-height: 1.45;
      font-size: .95rem;
    }

    .clean-list{ list-style:none; margin:0; padding:0; }
    .clean-list li{ padding: 8px 0; border-bottom:1px dashed #e5e7eb; }
    .clean-list li:last-child{ border-bottom:0; }
    .who{ font-weight: 800; }
    .meta{ display:block; color: var(--muted); font-size: .95rem; margin-top: 2px; }
    .mini{ font-size: .92rem; }

    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.95rem;
      border: 1px solid #e5e7eb;
      background: #f9fafb;
      padding: 2px 6px;
      border-radius: 6px;
    }

    .banner{
      border: 1px solid var(--line);
      background: var(--soft);
      border-radius: 12px;
      padding: 10px 12px;
    }
    .banner .title{ font-weight: 900; }
    .badge-row{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin-top:6px; }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .small-note{ font-size: .9rem; color: var(--muted); line-height: 1.45; }
    .wrap-any{ overflow-wrap:anywhere; word-break: break-word; }

    /* ✅ 집계 진행 상태바 */
    .progress-track{
      width:100%;
      height: 12px;
      background: #e5e7eb;
      border: 1px solid #d1d5db;
      border-radius: 999px;
      overflow:hidden;
    }
    .progress-fill{
      height:100%;
      width:0%;
      background:#111827;
      transition: width .18s ease;
    }

    /* ✅ 요약 표 체크박스 */
    .td-check{ text-align:center; vertical-align: middle; }
    .th-check{ text-align:center; vertical-align: middle; width:48px; }
    .th-check input{ transform: translateY(1px); }
  </style>
</head>

<body>
  <div id="tooltip"></div>

  <header class="site-header">
    <div class="shell">
      <h1>학교별 전입·전출 인사발령자 명단 집계기</h1>
      <p class="muted">
        ·에듀파인 업무지원-일반게시판에서 인사발령 엑셀 첨부파일 다운받아서 한꺼번에 업로드하면 전입자, 전출자 명단 집계해주는 기능 <br/>
        ·발령 일자가 같은 모든 직군의 엑셀 파일을 한꺼번에 다 올리시면 됩니다. 교육공무원, 지방공무원, 교육공무직 한번에 집계 가능
      </p>
    </div>
  </header>

  <main class="container">

    <!-- 1) 업로드/설정 -->
    <section class="tool-card" id="uploadSection">
      <div class="tool-head">
        <div>
          <h2 class="tool-title">1. 인사발령 엑셀파일 업로드</h2>
          <p class="tool-sub">
            ·드래그해서 업로드 가능합니다.
          </p>
        </div>
      </div>

      <hr/>

      <div class="btn-row" style="margin-bottom: 10px;">
        <label class="btn" for="fileInput">파일 선택하기</label>

        <input id="fileInput" type="file" accept=".xlsx,.xls" multiple
               style="position:absolute; left:-9999px; width:1px; height:1px; opacity:0;" />

        <button id="btnAnalyze" class="btn primary">발령 정보 집계하기</button>
        <button id="btnClear" class="btn ghost">초기화하기</button>

        <span id="fileMeta" class="muted mini"></span>
      </div>

      <div id="dropZone" class="dropzone" tabindex="0" role="button" aria-label="여기에 엑셀 파일을 드래그해서 업로드">
        <strong>여기에 엑셀 파일을 드래그해서 놓기</strong>
        <div class="muted mini">지원: .xlsx, .xls · 여러 개 파일 가능</div>
      </div>

      <!-- ✅ 집계 진행 상태바 -->
      <div id="progressWrap" class="banner" style="display:none; margin-top: 12px;">
        <div class="title">집계 진행 상황</div>
        <div id="progressText" class="small-note" style="margin-top:6px;"></div>
        <div id="progressTrack" class="progress-track" style="margin-top:8px;" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
          <div id="progressBar" class="progress-fill"></div>
        </div>
        <div class="row between" style="margin-top:8px;">
          <span id="progressPct" class="pill gray">0%</span>
          <span id="progressElapsed" class="muted mini"></span>
        </div>
      </div>

      <div id="analyzeBanner" class="banner" style="display:none; margin-top: 12px;">
        <div class="title">집계 결과 요약</div>
        <div id="globalTotals" class="small-note" style="margin-top:6px;"></div>
        <div class="badge-row" id="globalBadges"></div>
      </div>

      <!-- ✅ 보기 단위 선택(근무지/시군구) -->
      <div class="field" style="margin-top: 12px;">
        <label>보기 단위(집계 기준)</label>
        <select id="viewUnitSelect" title="보기 단위 선택">
          <option value="workplace" selected>근무지(학교·기관) 기준</option>
          <option value="district">시군구 기준</option>
        </select>
        <div class="help">
          집계 완료 후에도 바꿀 수 있습니다. 시군구는 근무지명에서 자동 추출(교육지원청/지역명)하며,
          일부 학교/기관은 <span class="kbd">미분류</span>로 나올 수 있어 아래 “시군구 보정 규칙”으로 수정 가능합니다.
        </div>
      </div>

      <div class="field" style="margin-top: 14px;">
        <details id="advancedDetails">
          <summary>데이터 추출 방식 상세 설정</summary>
          <div style="margin-top: 10px;">
            <div class="row stretch">
              <label class="mini" style="display:flex; gap:8px; align-items:center; font-weight:700;">
                <input id="optAutoDetect" type="checkbox" checked />
                <span>자동 컬럼 감지(추천)</span>
              </label>

              <label class="mini" style="display:flex; gap:8px; align-items:center; font-weight:700;">
                <input id="optNormalize" type="checkbox" checked />
                <span>근무지명 공백 및 개행 정리</span>
              </label>

              <label class="mini" style="display:flex; gap:8px; align-items:center; font-weight:700;">
                <input id="optPrefixRegion" type="checkbox" checked />
                <span>관할 태그 붙이기 (여러 지역 조회할 경우)</span>
              </label>

              <label class="mini" style="display:flex; gap:8px; align-items:center; font-weight:700;">
                <input id="optUseSubject" type="checkbox" checked />
                <span>교육공무원 과목이 있으면 직종에 포함</span>
              </label>

              <!-- ✅ 기본값: OFF (본명 전체 표시) -->
              <label class="mini" style="display:flex; gap:8px; align-items:center; font-weight:700;">
                <input id="optMaskNames" type="checkbox" />
                <span>이름 마스킹하기 (선택)</span>
              </label>
            </div>

            <div class="field">
              <label class="mini">근무지 판단 키워드 </label>
              <div class="help">쉼표, 줄바꿈으로 구분. 학교급/기관 키워드 + (국/과/팀 등) 추가하면 다양한 서식에서 자동감지 정확도 올라감.</div>
              <textarea id="placeKeywords" style="width:100%;">유치원, 초등학교, 중학교, 고등학교, 특수학교, 학교, 교육지원청, 교육청, 도서관, 교육문화관, 센터, 기관, 국, 과, 팀, 담당관, 유, 초, 중, 고</textarea>
            </div>

            <!-- ✅ 시군구 보정 규칙 -->
            <div class="field">
              <label class="mini">시군구 보정 규칙 (선택)</label>
              <div class="help">
                한 줄에 하나: <span class="kbd">키워드=시군구</span> (또는 <span class="kbd">키워드,시군구</span>)<br/>
                근무지명에 키워드가 포함되면 해당 시군구로 강제 분류합니다. (예: <span class="kbd">강원애니고=춘천</span>, <span class="kbd">묵호고=동해</span>)
              </div>
              <textarea id="districtOverrides" style="width:100%;" placeholder="예) 강원애니고=춘천&#10;묵호고=동해"></textarea>
            </div>

            <div class="field">
              <label class="mini">자동 감지 실패 시 수동 집계</label>
              <div class="help">모든 시트에 동일 적용. 컬럼은 A,B,C… 형태로 입력합니다.</div>

              <div class="row stretch">
                <div>
                  <label class="mini">연번/번호</label>
                  <input id="colSeq" type="text" value="A" maxlength="3" />
                </div>
                <div>
                  <label class="mini">성명</label>
                  <input id="colName" type="text" value="B" maxlength="3" />
                </div>
                <div>
                  <label class="mini">직종/직급</label>
                  <input id="colJob" type="text" value="C" maxlength="3" />
                </div>
                <div>
                  <label class="mini">전입자 발령 근무지</label>
                  <input id="colIn" type="text" value="D" maxlength="3" />
                </div>
                <div>
                  <label class="mini">전출자 현소속 근무지</label>
                  <input id="colOut" type="text" value="F" maxlength="3" />
                </div>
                <div>
                  <label class="mini">비고</label>
                  <input id="colNote" type="text" value="H" maxlength="3" />
                </div>
              </div>

              <div class="help">
                ※ 교육공무원 서식의 비고는 자동 감지 후 전출근무지 보정으로 활용함.
              </div>
            </div>

            <p id="libWarn" class="muted" style="display:none; margin: 8px 0 0;"></p>
          </div>
        </details>
      </div>

      <div class="field">
        <details id="fileListDetails">
          <summary id="fileListSummary">선택된 파일 (0개)</summary>
          <div style="margin-top: 10px;">
            <ul id="fileList" class="clean-list"></ul>
          </div>
        </details>
      </div>
    </section>

    <!-- 2) 단위 상세 -->
    <section class="tool-card" id="detailSection" style="display:none;">
      <div class="tool-head">
        <div>
          <h2 class="tool-title">2. 상세 발령 내역</h2>
          <p class="tool-sub">
            ·보기 단위(근무지/시군구) 선택 후, 항목 선택하면 전입·전출자 명단 확인 가능.
          </p>
        </div>
        <div class="btn-row">
          <label class="mini" style="display:flex; gap:8px; align-items:center; font-weight:700;">
            <input id="optMaskNamesQuick" type="checkbox" />
            <span>이름 마스킹</span>
          </label>
          <button id="btnDownloadDetail" class="btn">현재 상세 CSV</button>
        </div>
      </div>

      <hr/>

      <div class="field">
        <label>검색</label>
        <input id="workplaceSearch" type="text" placeholder="예: 춘천, oo교육지원청, oo초 ..." />
        <div class="help">공백/괄호/대소문자 차이는 무시함. 정규화합니다.</div>
      </div>

      <div class="field">
        <label>선택</label>
        <select id="workplaceSelect" title="선택"></select>
        <div id="workplaceMeta" class="muted mini" style="margin-top:6px;"></div>
      </div>

      <div class="field">
        <label>직종(직급·과목) 선택</label>
        <select id="jobSelect" title="직종 선택"></select>
        <div id="jobMeta" class="muted mini" style="margin-top:6px;"></div>
      </div>

      <p class="muted mini" style="margin:0 0 8px;">
        ·아래 표 행에 마우스를 올리면 요약이 뜨고, 클릭하면 <b>아래 명단</b>이 해당 직종으로 전환됨.
      </p>

      <div class="table-wrap">
        <table id="jobTable">
          <thead>
            <tr>
              <th class="sortable" data-sort="staffType">구분<span class="sort-ind"></span></th>
              <th class="sortable" data-sort="jobName">직종(직급·과목)<span class="sort-ind"></span></th>
              <th class="numeric sortable" data-sort="out">전출<span class="sort-ind"></span></th>
              <th class="numeric sortable" data-sort="in">전입<span class="sort-ind"></span></th>
              <th class="numeric sortable" data-sort="diff">차이(전출-전입)<span class="sort-ind"></span></th>
              <th class="numeric sortable" data-sort="total">총변동<span class="sort-ind"></span></th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>

      <div id="detailLists" style="margin-top: 14px;"></div>
    </section>

    <!-- 3) 요약 -->
    <section class="tool-card" id="summarySection" style="display:none;">
      <div class="tool-head">
        <div>
          <h2 class="tool-title">3. 요약</h2>
          <p class="tool-sub">기본적으로 이름 오름차순 정렬. 행 클릭 시 상세로 이동.</p>
        </div>
        <div class="btn-row">
          <button id="btnDownloadXlsxAll" class="btn">전체 엑셀</button>
          <button id="btnDownloadXlsxSelected" class="btn primary">선택 엑셀</button>
          <button id="btnClearSelected" class="btn ghost">선택 해제</button>
          <button id="btnDownloadXlsxBothSummary" class="btn">두 단위 요약 엑셀</button>
          <button id="btnDownloadSummary" class="btn">현재 요약 CSV</button>
        </div>
      </div>

      <hr/>

      <div class="field">
        <label>검색</label>
        <input id="summarySearch" type="text" placeholder="예: 춘천, oo초, 교육지원청..." />
      </div>

      <div class="field">
        <label>보기</label>
        <select id="summaryFilter">
          <option value="all" selected>전체</option>
          <option value="outMore">전출자가 더 많은 항목</option>
          <option value="inMore">전입자가 더 많은 항목</option>
          <option value="equal">전입전출 일치 항목</option>
        </select>
      </div>

      <p id="summaryStats" class="muted" style="margin:0 0 10px;"></p>
      <p class="muted mini" style="margin:0 0 10px;">
        ·표 왼쪽 체크로 항목을 선택한 뒤 <b>선택 엑셀</b>을 누르면 선택한 항목만 저장됩니다.
      </p>

      <div class="table-wrap">
        <table id="summaryTable">
          <thead>
            <tr>
              <th class="th-check"><input id="summaryCheckAll" type="checkbox" title="현재 표시 목록 전체 선택" /></th>
              <th class="sortable" data-sort="name">단위<span class="sort-ind"></span></th>
              <th class="numeric sortable" data-sort="out">전출<span class="sort-ind"></span></th>
              <th class="numeric sortable" data-sort="in">전입<span class="sort-ind"></span></th>
              <th class="numeric sortable" data-sort="total">총 인사변동<span class="sort-ind"></span></th>
              <th class="numeric sortable" data-sort="diff">차이(전출-전입)<span class="sort-ind"></span></th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </section>

    <!-- 4) 결원 의심 목록 -->
    <section class="tool-card" id="suspectSection" style="display:none;">
      <div class="tool-head">
        <div>
          <h2 class="tool-title">4. 정원 감소 여부 확인 필요 (결원 의심 선별)</h2>
          <p class="tool-sub">
            ·정원 및 배치기준 등 확인 필요. 간단하게 스크리닝 용도.
          </p>
        </div>
        <div class="btn-row">
          <button id="btnDownloadSuspect" class="btn">현재 목록 CSV</button>
        </div>
      </div>

      <hr/>

      <div class="row stretch">
        <div class="field" style="margin:0;">
          <label>검색</label>
          <input id="suspectSearch" type="text" placeholder="단위/직종 검색 (예: 조리, 국어, 춘천...)" />
        </div>
        <div class="field" style="margin:0;">
          <label>구분</label>
          <select id="suspectType">
            <option value="ALL" selected>전체</option>
            <option value="교육공무직">교육공무직</option>
            <option value="교육공무원">교육공무원</option>
            <option value="지방공무원">지방공무원</option>
          </select>
        </div>
      </div>

      <p id="suspectStats" class="muted" style="margin:10px 0;"></p>

      <div class="table-wrap">
        <table id="suspectTable">
          <thead>
            <tr>
              <th class="sortable" data-sort="staffType">구분<span class="sort-ind"></span></th>
              <th class="sortable" data-sort="workplace">단위<span class="sort-ind"></span></th>
              <th class="sortable" data-sort="jobName">직종(직급·과목)<span class="sort-ind"></span></th>
              <th class="numeric sortable" data-sort="out">전출<span class="sort-ind"></span></th>
              <th class="numeric sortable" data-sort="in">전입<span class="sort-ind"></span></th>
              <th class="numeric sortable" data-sort="diff">결원 의심(전출-전입)<span class="sort-ind"></span></th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </section>

    <!-- 5) 로그 -->
    <section class="tool-card">
      <details id="logDetails">
        <summary>처리 로그</summary>
        <div style="margin-top:10px;">
          <pre id="logBox" class="muted" style="white-space: pre-wrap; margin:0;"></pre>
        </div>
      </details>
    </section>

    <p><a class="btn" href="../index.html">메인으로 돌아가기</a></p>
  </main>

<script>
(() => {
  "use strict";

  // ---------------------------
  // DOM
  // ---------------------------
  const $ = (s) => document.querySelector(s);

  const el = {
    tooltip: $("#tooltip"),

    fileInput: $("#fileInput"),
    dropZone: $("#dropZone"),
    btnAnalyze: $("#btnAnalyze"),
    btnClear: $("#btnClear"),
    fileMeta: $("#fileMeta"),

    // progress
    progressWrap: $("#progressWrap"),
    progressText: $("#progressText"),
    progressTrack: $("#progressTrack"),
    progressBar: $("#progressBar"),
    progressPct: $("#progressPct"),
    progressElapsed: $("#progressElapsed"),

    analyzeBanner: $("#analyzeBanner"),
    globalTotals: $("#globalTotals"),
    globalBadges: $("#globalBadges"),

    viewUnitSelect: $("#viewUnitSelect"),

    optAutoDetect: $("#optAutoDetect"),
    optNormalize: $("#optNormalize"),
    optPrefixRegion: $("#optPrefixRegion"),
    optUseSubject: $("#optUseSubject"),
    optMaskNames: $("#optMaskNames"),
    optMaskNamesQuick: $("#optMaskNamesQuick"),
    placeKeywords: $("#placeKeywords"),
    districtOverrides: $("#districtOverrides"),

    colSeq: $("#colSeq"),
    colName: $("#colName"),
    colJob: $("#colJob"),
    colIn: $("#colIn"),
    colOut: $("#colOut"),
    colNote: $("#colNote"),

    libWarn: $("#libWarn"),

    fileListSummary: $("#fileListSummary"),
    fileList: $("#fileList"),

    detailSection: $("#detailSection"),
    workplaceSearch: $("#workplaceSearch"),
    workplaceSelect: $("#workplaceSelect"),
    workplaceMeta: $("#workplaceMeta"),
    jobSelect: $("#jobSelect"),
    jobMeta: $("#jobMeta"),
    jobTableBody: $("#jobTable tbody"),
    detailLists: $("#detailLists"),
    btnDownloadDetail: $("#btnDownloadDetail"),

    summarySection: $("#summarySection"),
    summarySearch: $("#summarySearch"),
    summaryFilter: $("#summaryFilter"),
    summaryStats: $("#summaryStats"),
    summaryTableBody: $("#summaryTable tbody"),
    summaryCheckAll: $("#summaryCheckAll"),

    btnDownloadSummary: $("#btnDownloadSummary"),
    btnDownloadXlsxAll: $("#btnDownloadXlsxAll"),
    btnDownloadXlsxSelected: $("#btnDownloadXlsxSelected"),
    btnDownloadXlsxBothSummary: $("#btnDownloadXlsxBothSummary"),
    btnClearSelected: $("#btnClearSelected"),

    suspectSection: $("#suspectSection"),
    suspectSearch: $("#suspectSearch"),
    suspectType: $("#suspectType"),
    suspectStats: $("#suspectStats"),
    suspectTableBody: $("#suspectTable tbody"),
    btnDownloadSuspect: $("#btnDownloadSuspect"),

    logBox: $("#logBox"),
  };

  // ---------------------------
  // State
  // ---------------------------
  const state = {
    files: [],
    analyzed: false,

    // view unit: "workplace" | "district"
    viewUnit: "workplace",

    moves: [], // flat list

    // (1) workplace aggregation
    workplaces: new Map(), // key -> { key,name, inMoves,outMoves, jobs: Map(jobKey->jobAgg) }
    workplaceOrder: [],
    selectedWorkplaceKey: "",
    selectedJobKeyWorkplace: "ALL",
    summarySelectedWorkplace: new Set(),
    summaryLastWorkplaceKeys: [],
    sortSummaryWorkplace: { key: "name", dir: "asc" },
    sortJobsWorkplace: { key: "staffType", dir: "asc" },
    sortSuspectWorkplace: { key: "diff", dir: "desc" },

    // (2) district aggregation (시군구)
    districts: new Map(), // districtKey -> { ... }
    districtOrder: [],
    selectedDistrictKey: "",
    selectedJobKeyDistrict: "ALL",
    summarySelectedDistrict: new Set(),
    summaryLastDistrictKeys: [],
    sortSummaryDistrict: { key: "name", dir: "asc" },
    sortJobsDistrict: { key: "staffType", dir: "asc" },
    sortSuspectDistrict: { key: "diff", dir: "desc" },

    heur: null,
    regionTags: new Map(), // fileName -> regionTag

    // district override rules
    districtRules: [], // [{ keyNorm, label }]

    // default: unmasked
    maskNames: false,

    dedupe: {
      strictSeen: new Set(),
      strictSkipped: 0,
      looseMap: new Map(), // looseKey -> firstNote
      looseCollisions: 0,
      looseExamples: [],   // {name, jobName, inWorkplace, outWorkplace, noteA, noteB, sheetName, seq}
    },

    stats: null, // global stats
  };

  // ---------------------------
  // Active view helpers
  // ---------------------------
  function normUnit(u) { return (u === "district") ? "district" : "workplace"; }
  function getUnit() { return normUnit(state.viewUnit); }
  function unitLabel(unit = getUnit()) { return unit === "district" ? "시군구" : "근무지"; }

  function getMapByUnit(unit = getUnit()) { return unit === "district" ? state.districts : state.workplaces; }
  function getOrderByUnit(unit = getUnit()) { return unit === "district" ? state.districtOrder : state.workplaceOrder; }

  function getSelectedKeyByUnit(unit = getUnit()) {
    return unit === "district" ? state.selectedDistrictKey : state.selectedWorkplaceKey;
  }
  function setSelectedKeyByUnit(unit, key) {
    if (unit === "district") state.selectedDistrictKey = key;
    else state.selectedWorkplaceKey = key;
  }

  function getSelectedJobKeyByUnit(unit = getUnit()) {
    return unit === "district" ? state.selectedJobKeyDistrict : state.selectedJobKeyWorkplace;
  }
  function setSelectedJobKeyByUnit(unit, key) {
    if (unit === "district") state.selectedJobKeyDistrict = key;
    else state.selectedJobKeyWorkplace = key;
  }

  function getSummarySelectedByUnit(unit = getUnit()) {
    return unit === "district" ? state.summarySelectedDistrict : state.summarySelectedWorkplace;
  }
  function getSummaryLastKeysByUnit(unit = getUnit()) {
    return unit === "district" ? state.summaryLastDistrictKeys : state.summaryLastWorkplaceKeys;
  }
  function setSummaryLastKeysByUnit(unit, keys) {
    if (unit === "district") state.summaryLastDistrictKeys = keys;
    else state.summaryLastWorkplaceKeys = keys;
  }

  function getSortSummaryByUnit(unit = getUnit()) {
    return unit === "district" ? state.sortSummaryDistrict : state.sortSummaryWorkplace;
  }
  function getSortJobsByUnit(unit = getUnit()) {
    return unit === "district" ? state.sortJobsDistrict : state.sortJobsWorkplace;
  }
  function getSortSuspectByUnit(unit = getUnit()) {
    return unit === "district" ? state.sortSuspectDistrict : state.sortSuspectWorkplace;
  }

  function syncUnitUI() {
    const u = getUnit();
    // 버튼 텍스트
    if (el.btnDownloadXlsxAll) el.btnDownloadXlsxAll.textContent = `전체 ${unitLabel(u)} 엑셀`;
    if (el.btnDownloadXlsxSelected) el.btnDownloadXlsxSelected.textContent = `선택 ${unitLabel(u)} 엑셀`;

    // 검색 placeholder를 약간 다르게
    if (el.workplaceSearch) {
      el.workplaceSearch.placeholder = (u === "district")
        ? "예: 춘천, 원주, 속초양양, 미분류..."
        : "예: oo교육지원청, oo초, oo과...";
    }
    if (el.summarySearch) {
      el.summarySearch.placeholder = (u === "district")
        ? "예: 춘천, 속초양양..."
        : "예: oo초, 교육지원청...";
    }
  }

  function renderAllCurrent() {
    if (!state.analyzed) return;
    syncUnitUI();
    renderAnalyzeBanner();
    renderWorkplaceSelect();
    renderJobSelect();
    renderWorkplaceDetail();
    renderSummary();
    renderSuspect();
  }

  // ---------------------------
  // Logging
  // ---------------------------
  function log(line) {
    const ts = new Date().toLocaleTimeString();
    el.logBox.textContent += `[${ts}] ${line}\n`;
    el.logBox.scrollTop = el.logBox.scrollHeight;
  }
  function clearLog() { el.logBox.textContent = ""; }

  // ---------------------------
  // Tooltip
  // ---------------------------
  function showTooltip(html, x, y) {
    el.tooltip.innerHTML = html;
    el.tooltip.style.display = "block";

    const pad = 14;
    const rect = el.tooltip.getBoundingClientRect();
    const vw = window.innerWidth;
    const vh = window.innerHeight;

    let left = x + 12;
    let top = y + 12;
    if (left + rect.width + pad > vw) left = Math.max(pad, vw - rect.width - pad);
    if (top + rect.height + pad > vh) top = Math.max(pad, y - rect.height - 12);

    el.tooltip.style.left = left + "px";
    el.tooltip.style.top = top + "px";
  }
  function hideTooltip() {
    el.tooltip.style.display = "none";
    el.tooltip.innerHTML = "";
  }

  // ---------------------------
  // Progress helpers
  // ---------------------------
  let progressStartAt = 0;

  function formatElapsed(ms) {
    const sec = Math.max(0, Math.floor(ms / 1000));
    const m = Math.floor(sec / 60);
    const s = sec % 60;
    return `${m}:${String(s).padStart(2, "0")}`;
  }

  function showProgress() { el.progressWrap.style.display = ""; }

  function hideProgress() {
    progressStartAt = 0;
    el.progressWrap.style.display = "none";
    el.progressBar.style.width = "0%";
    el.progressTrack?.setAttribute("aria-valuenow", "0");
    el.progressPct.textContent = "0%";
    el.progressText.textContent = "";
    el.progressElapsed.textContent = "";
  }

  function startProgress(text = "준비 중...") {
    progressStartAt = Date.now();
    showProgress();
    setProgress(0, text);
  }

  function setProgress(pct, text = "") {
    const p = Math.max(0, Math.min(100, Number(pct) || 0));
    showProgress();
    el.progressBar.style.width = `${p.toFixed(1)}%`;
    el.progressTrack?.setAttribute("aria-valuenow", String(Math.round(p)));
    el.progressPct.textContent = `${Math.round(p)}%`;
    el.progressText.textContent = text;

    if (progressStartAt) {
      const ms = Date.now() - progressStartAt;
      el.progressElapsed.textContent = `경과 ${formatElapsed(ms)}`;
    } else {
      el.progressElapsed.textContent = "";
    }
  }

  function doneProgress(text = "집계 완료 ✅") { setProgress(100, text); }

  function rafTick() {
    return new Promise((resolve) => requestAnimationFrame(() => resolve(true)));
  }

  // ---------------------------
  // Utilities
  // ---------------------------
  function escapeHtml(s) {
    return String(s ?? "")
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/\"/g, "&quot;")
      .replace(/'/g, "&#039;");
  }

  function normalizeSpaces(v) {
    return String(v ?? "").replace(/\s+/g, " ").trim();
  }

  function normalizeKey(v) {
    return normalizeSpaces(v).replace(/\s+/g, "");
  }

  function normalizeSearch(v) {
    return String(v ?? "")
      .toLowerCase()
      .replace(/\s+/g, "")
      .replace(/[\[\]\(\)\{\}<>]/g, "")
      .replace(/[·ㆍ\.\-_,]/g, "");
  }
  function includesNorm(hay, needle) {
    const n = normalizeSearch(needle);
    if (!n) return true;
    return normalizeSearch(hay).includes(n);
  }

  function bytesToHuman(bytes) {
    if (!Number.isFinite(bytes)) return "-";
    const units = ["B","KB","MB","GB"];
    let v = bytes, i = 0;
    while (v >= 1024 && i < units.length - 1) { v /= 1024; i++; }
    return `${v.toFixed(i === 0 ? 0 : 1)} ${units[i]}`;
  }

  function toIntLike(v) {
    if (typeof v === "number" && Number.isFinite(v)) return Math.trunc(v);
    const s = String(v ?? "").trim();
    if (!s) return null;
    if (/^\d+$/.test(s)) return parseInt(s, 10);
    const m = s.match(/^(\d+)\s*[\.\)\-]$/);
    if (m) return parseInt(m[1], 10);
    return null;
  }

  function colToIndex(col) {
    const s = String(col ?? "").trim().toUpperCase();
    if (!s) return null;
    let n = 0;
    for (let i = 0; i < s.length; i++) {
      const code = s.charCodeAt(i);
      if (code < 65 || code > 90) return null;
      n = n * 26 + (code - 64);
    }
    return n - 1;
  }

  function indexToCol(idx) {
    if (!Number.isFinite(idx) || idx < 0) return "";
    let n = idx + 1;
    let out = "";
    while (n > 0) {
      const r = (n - 1) % 26;
      out = String.fromCharCode(65 + r) + out;
      n = Math.floor((n - 1) / 26);
    }
    return out;
  }

  function downloadCsv(filename, rows2d) {
    const bom = "\uFEFF";
    const csv = rows2d.map(row => row.map(cell => {
      const raw = String(cell ?? "");
      const escaped = raw.replace(/\"/g, '""');
      return `"${escaped}"`;
    }).join(",")).join("\n");

    const blob = new Blob([bom + csv], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename.replace(/[\\/:*?"<>|]/g, "_");
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1200);
  }

  function debounce(fn, wait = 160) {
    let t = null;
    return (...args) => {
      if (t) clearTimeout(t);
      t = setTimeout(() => fn(...args), wait);
    };
  }

  function safeShort(s, max = 36) {
    const v = String(s ?? "");
    if (v.length <= max) return v;
    return v.slice(0, max - 1) + "…";
  }

  // 이름 마스킹 (김○○ / 홍○동)
  function maskName(name) {
    const raw = normalizeSpaces(name);
    if (!raw) return "";
    const hangul = raw.replace(/[^가-힣]/g, "");
    if (hangul.length < 2) return raw;

    const first = hangul[0];
    const last = hangul[hangul.length - 1];
    const middleCount = Math.max(1, hangul.length - 2);
    const masked = first + "○".repeat(middleCount) + (hangul.length >= 3 ? last : "");
    if (hangul.length === 2) return first + "○";
    return masked;
  }

  function displayName(name) {
    const n = normalizeSpaces(name);
    return state.maskNames ? maskName(n) : n;
  }

  // ---------------------------
  // XLSX attaching
  // ---------------------------
  function loadScript(src) {
    return new Promise((resolve, reject) => {
      const s = document.createElement("script");
      s.src = src;
      s.onload = () => resolve(true);
      s.onerror = () => reject(new Error("script load fail: " + src));
      document.head.appendChild(s);
    });
  }

  async function ensureXLSX() {
    if (window.XLSX) return true;
    const sources = [
      "/static/xlsx.full.min.js",
      "static/xlsx.full.min.js",
      "https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"
    ];
    for (const src of sources) {
      try {
        log(`엑셀 파서 로드 시도: ${src}`);
        await loadScript(src);
        if (window.XLSX) {
          log("엑셀 파서 로드 완료 ✅");
          return true;
        }
      } catch {
        log(`로드 실패: ${src}`);
      }
    }
    return false;
  }

  function setLibWarning(ok) {
    if (ok) {
      el.libWarn.style.display = "none";
      el.btnAnalyze.disabled = false;
      return;
    }
    el.libWarn.style.display = "";
    el.libWarn.textContent =
      "⚠️ 엑셀 파서(XLSX)가 로드되지 않았습니다. " +
      "폐쇄망이면 /static/xlsx.full.min.js 를 프로젝트에 추가하세요. (또는 인터넷 환경에서 CDN 사용)";
    el.btnAnalyze.disabled = true;
  }

  // ---------------------------
  // Heuristics
  // ---------------------------
  function escapeRegExp(s) {
    return String(s).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }

  function cellStr(v) {
    return String(v ?? "").replace(/\s+/g, " ").trim();
  }
  function cellKey(v) {
    return normalizeKey(cellStr(v));
  }

  function buildHeuristics() {
    const raw = String(el.placeKeywords.value || "");
    const tokens = raw.split(/[\n,]/).map(s => normalizeSpaces(s)).filter(Boolean);

    const oneChar = tokens.filter(t => t.length === 1);
    const normal = tokens.filter(t => t.length >= 2);

    const strongRe = normal.length ? new RegExp(normal.map(x => escapeRegExp(x)).join("|")) : null;
    const suffixRe = oneChar.length ? new RegExp("(" + oneChar.map(x => escapeRegExp(x)).join("|") + ")$") : null;

    function isPlaceLike(s) {
      const v = normalizeSpaces(s);
      if (!v) return false;
      if (strongRe && strongRe.test(v)) return true;
      if (suffixRe && suffixRe.test(v.replace(/\s+/g,""))) return true;

      // 기본(내장) 패턴
      if (/(유치원|초등학교|중학교|고등학교|특수학교|학교|교육지원청|교육청|지원청|도서관|교육문화관|센터|기관)/.test(v)) return true;
      if (/(초|중|고|유)$/.test(v.replace(/\s+/g,""))) return true;
      // 지방공무원/본청 부서 등
      if (/(행정국|교육국|정책국|감사관|공보담당관|총무과|인사과|예산과|행정과|학교지원과|안전복지과|정책기획과|중등교육과|유초등교육과|문화체육특수교육과|과장|팀장)/.test(v)) return true;

      return false;
    }

    function isSchoolLike(s) {
      const v = normalizeSpaces(s);
      if (!v) return false;
      if (/(유치원|초등학교|중학교|고등학교|특수학교|학교)/.test(v)) return true;
      if (/(초|중|고|유)$/.test(v.replace(/\s+/g,""))) return true;
      return false;
    }

    function isEduOfficeLike(s) {
      const v = normalizeSpaces(s);
      if (!v) return false;
      return /(교육지원청|교육청|지원청|도교육청|특별자치도교육청)/.test(v);
    }

    function looksLikeName(val) {
      const raw = normalizeSpaces(val);
      if (!raw) return false;
      if (/[0-9]/.test(raw)) return false;
      if (/[A-Za-z]/.test(raw)) return false;
      if (/[\/\(\)\[\]\{\}]/.test(raw)) return false;

      const compact = raw.replace(/\s+/g, "");
      if (!compact) return false;

      if (compact.length < 2 || compact.length > 4) return false;

      const isHangulName =
        /^[가-힣]{2,4}$/.test(compact) ||
        /^[가-힣]{1,4}[·\s][가-힣]{1,4}$/.test(raw);
      if (!isHangulName) return false;

      if (/(학교|유치원|교육지원청|교육청|지원청|도서관|교육문화관|센터)/.test(raw)) return false;
      if (/(초|중|고|유)$/.test(compact)) return false;

      return true;
    }

    function looksLikeJob(val) {
      const s = cellStr(val);
      if (!s) return false;
      return /(교사|교감|원감|원로|주무관|행정|실무사|전담사|영양사|조리|사서|상담|보건|전문상담|치료|간호|운전|시설|청소|돌봄|늘봄|서기관|사무관|서기|주사)/.test(s);
    }

    return { tokens, isPlaceLike, isSchoolLike, isEduOfficeLike, looksLikeName, looksLikeJob };
  }

  // ---------------------------
  // District (시군구) inference + overrides
  // ---------------------------
  const KNOWN_DISTRICTS = [
    "속초양양",
    "춘천","원주","강릉","동해","태백","속초","삼척",
    "홍천","횡성","영월","평창","정선","철원","화천","양구","인제","고성","양양"
  ].sort((a,b) => b.length - a.length);

  const PROVINCE_RE = /(서울특별시|부산광역시|대구광역시|인천광역시|광주광역시|대전광역시|울산광역시|세종특별자치시|경기도|강원특별자치도|강원도|충청북도|충청남도|전라북도|전라남도|경상북도|경상남도|제주특별자치도)/;

  function parseDistrictOverrides() {
    const raw = String(el.districtOverrides?.value || "");
    const lines = raw.split(/\n/).map(s => s.trim()).filter(Boolean);

    const rules = [];
    for (const line of lines) {
      let key = "", label = "";
      if (line.includes("=")) {
        const parts = line.split("=");
        key = normalizeSpaces(parts[0]);
        label = normalizeSpaces(parts.slice(1).join("="));
      } else if (line.includes(",")) {
        const parts = line.split(",");
        key = normalizeSpaces(parts[0]);
        label = normalizeSpaces(parts.slice(1).join(","));
      }
      if (!key || !label) continue;
      rules.push({ keyNorm: normalizeSearch(key), label });
    }
    // 더 긴 키워드 우선
    rules.sort((a,b) => (b.keyNorm.length - a.keyNorm.length));
    return rules;
  }

  function stripBracketPrefix(s) {
    return String(s ?? "").replace(/^\s*\[[^\]]+\]\s*/, "");
  }

  function inferDistrictFromWorkplace(workplaceRaw) {
    const base = normalizeSpaces(stripBracketPrefix(workplaceRaw));
    if (!base) return "";

    const baseNorm = normalizeSearch(base);

    // 1) 사용자 보정 규칙 우선
    for (const r of state.districtRules) {
      if (r.keyNorm && baseNorm.includes(r.keyNorm)) return r.label;
    }

    // 2) 상위기관(강원도교육청) 프리픽스 제거 후 판단
    let s = base.replace(/^(강원특별자치도교육청|강원도교육청)\s*/,"").trim();
    if (!s) s = base;

    // 3) 교육지원청 기반 (예: 춘천교육지원청)
    const m = s.match(/([가-힣]+)\s*교육지원청/);
    if (m && m[1]) return m[1].replace(/\s+/g,"");

    // 4) 문자열 시작에서 시군구 매칭(공백 없이 붙는 케이스 포함)
    const compact = s.replace(/\s+/g,"");
    for (const d of KNOWN_DISTRICTS) {
      if (compact.startsWith(d)) return d;
    }

    // 5) 다른 시·도 표기(예: "경기도 수원시") → "수원시" 추출
    if (PROVINCE_RE.test(base)) {
      const mm = base.match(new RegExp(PROVINCE_RE.source + "\\s*([가-힣]{2,}(?:시|군|구))"));
      if (mm && mm[1]) return mm[1];
    }

    // 6) 본청/직속기관 등 → 도교육청으로 묶기
    if (/(행정국|교육국|정책국|감사관|공보담당관|본청|교육연수원|교육연구원|학생교육원|교육과학정보원|교육문화관|도서관|센터|교육원|수련원)/.test(base)) {
      return "도교육청";
    }

    // 7) 못 잡으면 미분류
    return "미분류";
  }

  // ---------------------------
  // Layout detection + data cross-check
  // ---------------------------
  function forwardFill(keys) {
    const out = [];
    let last = "";
    for (const k of keys) {
      if (k) { last = k; out.push(k); }
      else { out.push(last); }
    }
    return out;
  }

  function countHeaderSignals(keys, RE) {
    let c = 0;
    for (const k of keys) {
      if (!k) continue;
      if (RE.seq.test(k) || RE.name.test(k) || RE.job.test(k) || RE.note.test(k) || RE.place.test(k) || RE.subject.test(k)) c++;
    }
    return c;
  }

  function findIdxPrefer(primaryKeys, secondaryKeys, re) {
    for (let i = 0; i < primaryKeys.length; i++) {
      if (primaryKeys[i] && re.test(primaryKeys[i])) return i;
    }
    for (let i = 0; i < secondaryKeys.length; i++) {
      if (secondaryKeys[i] && re.test(secondaryKeys[i])) return i;
    }
    return -1;
  }

  function analyzeColumnStats(rows, dataStart, colIdx, heur, maxScanRows = 300) {
    let nonEmpty = 0;
    let placeLike = 0;
    let schoolLike = 0;
    let eduOfficeLike = 0;
    const uniqSet = new Set();

    const end = Math.min(rows.length, dataStart + maxScanRows);
    for (let r = dataStart; r < end; r++) {
      const row = rows[r] || [];
      const v = cellStr(row[colIdx]);
      if (!v) continue;
      nonEmpty++;
      uniqSet.add(v);
      if (heur.isPlaceLike(v)) placeLike++;
      if (heur.isSchoolLike(v)) schoolLike++;
      if (heur.isEduOfficeLike(v)) eduOfficeLike++;
    }

    return {
      nonEmpty,
      uniqueCount: uniqSet.size,
      placeLikeRatio: nonEmpty ? placeLike / nonEmpty : 0,
      schoolLikeRatio: nonEmpty ? schoolLike / nonEmpty : 0,
      eduOfficeLikeRatio: nonEmpty ? eduOfficeLike / nonEmpty : 0,
    };
  }

  function analyzeLikeRatio(rows, dataStart, colIdx, predicate, maxScanRows = 120) {
    let nonEmpty = 0;
    let hit = 0;
    const end = Math.min(rows.length, dataStart + maxScanRows);
    for (let r = dataStart; r < end; r++) {
      const row = rows[r] || [];
      const s = cellStr(row[colIdx]);
      if (!s) continue;
      nonEmpty++;
      if (predicate(row[colIdx])) hit++;
    }
    return nonEmpty ? hit / nonEmpty : 0;
  }

  function analyzeSeqRatio(rows, dataStart, colIdx, maxScanRows = 120) {
    let nonEmpty = 0;
    let hit = 0;
    const end = Math.min(rows.length, dataStart + maxScanRows);
    for (let r = dataStart; r < end; r++) {
      const row = rows[r] || [];
      const s = cellStr(row[colIdx]);
      if (!s) continue;
      nonEmpty++;
      if (toIntLike(row[colIdx]) !== null) hit++;
    }
    return nonEmpty ? hit / nonEmpty : 0;
  }

  // ✅ detectLayoutPlus() (병합 헤더 대응 + placeCols top/bot 전체 수집)
  function detectLayoutPlus(rows, heur) {
    const RE = {
      seq: /(연번|순번|일련|번호)/,
      name: /(성명|이름)/,
      job: /(직종|직종명|직명|직급|직위)/,
      note: /(비고|특이|사유|전소속)/,
      subject: /(과목|교과|담당|전공)/,
      place: /(부서|근무처|근무지|기관명|기관|학교명|학교\(기관\)명|교육지원청|소속|부서명|학교)/,

      inHint: /(발령|임용|전입|전보후|발령후|신규|임지|변경후|발령사항|임용사항)/,
      outHint: /(현소속|현직|현근무|현근무처|전출|퇴직|발령전|출발|변경전|종전|전보전|전소속)/,
    };

    const maxScan = Math.min(rows.length, 70);
    let best = null;

    for (let r = 0; r < maxScan - 1; r++) {
      const topRow = rows[r] || [];
      const botRow = rows[r + 1] || [];

      const n = Math.max(topRow.length, botRow.length);
      if (n <= 0) continue;

      const topKeys = Array.from({ length: n }, (_, i) => cellKey(topRow[i]));
      const botKeys = Array.from({ length: n }, (_, i) => cellKey(botRow[i]));
      const topFF = forwardFill(topKeys);

      const topCnt = countHeaderSignals(topKeys, RE);
      const botCnt = countHeaderSignals(botKeys, RE);

      const fieldKeys = (botCnt >= topCnt) ? botKeys : topKeys;
      const otherKeys = (fieldKeys === botKeys) ? topKeys : botKeys;

      const seqIdx = findIdxPrefer(fieldKeys, otherKeys, RE.seq);
      const nameIdx = findIdxPrefer(fieldKeys, otherKeys, RE.name);
      const jobIdx = findIdxPrefer(fieldKeys, otherKeys, RE.job);
      const noteIdx = findIdxPrefer(fieldKeys, otherKeys, RE.note);
      const subjectIdx = findIdxPrefer(fieldKeys, otherKeys, RE.subject);

      const placeSet = new Set();
      for (let i = 0; i < n; i++) {
        const kField = fieldKeys[i];
        const kOther = otherKeys[i];
        const kTop = topKeys[i];
        const kBot = botKeys[i];

        if (kField && RE.place.test(kField)) placeSet.add(i);
        if (kOther && RE.place.test(kOther)) placeSet.add(i);
        if (kTop && RE.place.test(kTop)) placeSet.add(i);
        if (kBot && RE.place.test(kBot)) placeSet.add(i);
      }

      if (noteIdx >= 0) placeSet.delete(noteIdx);
      if (seqIdx >= 0) placeSet.delete(seqIdx);
      if (nameIdx >= 0) placeSet.delete(nameIdx);
      if (jobIdx >= 0) placeSet.delete(jobIdx);
      if (subjectIdx >= 0) placeSet.delete(subjectIdx);

      let placeCols = [...placeSet].sort((a, b) => a - b);
      if (nameIdx < 0 || placeCols.length < 1) continue;

      const dataStart = r + 2;

      if (placeCols.length < 2) {
        const threshold = 0.22;
        const exclude = new Set([seqIdx, nameIdx, jobIdx, noteIdx, subjectIdx].filter(x => x >= 0));

        for (let i = 0; i < n; i++) {
          if (exclude.has(i)) continue;
          if (placeSet.has(i)) continue;

          const stats = analyzeColumnStats(rows, dataStart, i, heur, 120);
          if (stats.placeLikeRatio >= threshold) placeCols.push(i);
        }
        placeCols = [...new Set(placeCols)].sort((a, b) => a - b);
      }

      const scored = placeCols.map((i) => {
        const combined = (topFF[i] || "") + " " + (fieldKeys[i] || "");
        const inScore = RE.inHint.test(combined) ? 3 : 0;
        const outScore = RE.outHint.test(combined) ? 3 : 0;
        const stats = analyzeColumnStats(rows, dataStart, i, heur, 120);
        const dataScore = stats.placeLikeRatio;
        return { i, combined, inScore, outScore, dataScore, stats };
      });

      let inIdx = -1;
      let outIdx = -1;

      const inSorted = [...scored].sort((a, b) => (b.inScore - a.inScore) || (b.dataScore - a.dataScore) || (a.i - b.i));
      const outSorted = [...scored].sort((a, b) => (b.outScore - a.outScore) || (b.dataScore - a.dataScore) || (b.i - a.i));

      if (inSorted[0] && inSorted[0].inScore > 0) inIdx = inSorted[0].i;
      if (outSorted[0] && outSorted[0].outScore > 0) outIdx = outSorted[0].i;

      const threshold = 0.22;
      if (inIdx < 0) {
        const leftToRight = scored.slice().sort((a, b) => a.i - b.i);
        inIdx = leftToRight.find(x => x.dataScore >= threshold)?.i ?? -1;
      }
      if (outIdx < 0) {
        const rightToLeft = scored.slice().sort((a, b) => b.i - a.i);
        outIdx = rightToLeft.find(x => x.dataScore >= threshold)?.i ?? -1;
      }

      if (placeCols.length === 1) {
        const only = scored[0];
        if (only) {
          if (only.inScore > only.outScore) { inIdx = only.i; outIdx = -1; }
          else if (only.outScore > only.inScore) { outIdx = only.i; inIdx = -1; }
          else { inIdx = only.i; outIdx = -1; }
        }
      } else {
        if (inIdx < 0 && placeCols.length) inIdx = Math.min(...placeCols);
        if (outIdx < 0 && placeCols.length) outIdx = Math.max(...placeCols);
        if (inIdx === outIdx && placeCols.length >= 2) {
          inIdx = placeCols[0];
          outIdx = placeCols[1];
        }
      }

      const nameRatio = (nameIdx >= 0) ? analyzeLikeRatio(rows, dataStart, nameIdx, heur.looksLikeName, 120) : 0;
      const seqRatio = (seqIdx >= 0) ? analyzeSeqRatio(rows, dataStart, seqIdx, 120) : 0;

      const score =
        (seqIdx >= 0 ? 2 : 0) +
        (nameIdx >= 0 ? 2 : 0) +
        (placeCols.length >= 2 ? 2 : 1) +
        (jobIdx >= 0 ? 1 : 0) +
        (noteIdx >= 0 ? 1 : 0) +
        (subjectIdx >= 0 ? 0.5 : 0) +
        (nameRatio >= 0.25 ? 1 : 0) +
        (seqRatio >= 0.35 ? 1 : 0);

      if (!best || score > best.score) {
        best = {
          detected: true,
          headerRow: r,
          subRow: r + 1,
          dataStart,
          seqIdx,
          nameIdx,
          jobIdx,
          inIdx,
          outIdx,
          noteIdx,
          subjectIdx,
          placeCols,
          score,
          fieldKeys,
        };
      }
    }

    if (!best) {
      for (let r = 0; r < maxScan; r++) {
        const row = rows[r] || [];
        const n = row.length;
        if (n <= 0) continue;

        const keys = Array.from({ length: n }, (_, i) => cellKey(row[i]));
        const seqIdx = findIdxPrefer(keys, [], RE.seq);
        const nameIdx = findIdxPrefer(keys, [], RE.name);
        const jobIdx = findIdxPrefer(keys, [], RE.job);
        const noteIdx = findIdxPrefer(keys, [], RE.note);
        const subjectIdx = findIdxPrefer(keys, [], RE.subject);

        const placeCols = [];
        for (let i = 0; i < n; i++) if (keys[i] && RE.place.test(keys[i])) placeCols.push(i);
        if (nameIdx < 0 || placeCols.length < 1) continue;

        const dataStart = r + 1;

        const statsArr = placeCols.map(i => ({ i, stats: analyzeColumnStats(rows, dataStart, i, heur, 120) }));
        const threshold = 0.22;
        let inIdx = statsArr.sort((a,b)=>a.i-b.i).find(x=>x.stats.placeLikeRatio>=threshold)?.i ?? placeCols[0];
        let outIdx = statsArr.sort((a,b)=>b.i-a.i).find(x=>x.stats.placeLikeRatio>=threshold)?.i ?? placeCols[placeCols.length-1];

        if (placeCols.length === 1) {
          const combined = keys[inIdx] || "";
          const inScore = RE.inHint.test(combined) ? 1 : 0;
          const outScore = RE.outHint.test(combined) ? 1 : 0;
          if (outScore > inScore) { outIdx = inIdx; inIdx = -1; }
          else { outIdx = -1; }
        } else if (inIdx === outIdx) {
          outIdx = -1;
        }

        const nameRatio = (nameIdx >= 0) ? analyzeLikeRatio(rows, dataStart, nameIdx, heur.looksLikeName, 120) : 0;
        const seqRatio = (seqIdx >= 0) ? analyzeSeqRatio(rows, dataStart, seqIdx, 120) : 0;

        const score =
          (seqIdx >= 0 ? 2 : 0) +
          (nameIdx >= 0 ? 2 : 0) +
          (placeCols.length >= 2 ? 2 : 1) +
          (jobIdx >= 0 ? 1 : 0) +
          (noteIdx >= 0 ? 1 : 0) +
          (nameRatio >= 0.25 ? 1 : 0) +
          (seqRatio >= 0.35 ? 1 : 0);

        best = {
          detected: true,
          headerRow: r,
          subRow: r,
          dataStart,
          seqIdx,
          nameIdx,
          jobIdx,
          inIdx,
          outIdx,
          noteIdx,
          subjectIdx,
          placeCols,
          score,
          fieldKeys: keys,
        };
        break;
      }
    }

    return best;
  }

  // ---------------------------
  // Staff type inference
  // ---------------------------
  function detectStaffType(fileName, sheetName, jobName) {
    const s = `${fileName} ${sheetName} ${jobName}`.toLowerCase();

    if (/(교육공무직|공무직|조리실무사|행정실무사|교무행정사|늘봄|돌봄|시설관리|미화)/.test(s)) return "교육공무직";
    if (/(교육공무원|교사|교감|원감|원로교사|유치원|초등|중등|고등|특수)/.test(s)) return "교육공무원";
    if (/(지방공무원|주무관|서기|행정직|시설직|운전직|공업직|기능직)/.test(s)) return "지방공무원";

    if (/(교사|교감|원감|원로)/.test(jobName)) return "교육공무원";
    if (/(주무관|서기|행정직|시설직|운전직|서기관|사무관|주사)/.test(jobName)) return "지방공무원";
    return "교육공무직";
  }

  // ---------------------------
  // Workplace normalization / region tag
  // ---------------------------
  function inferRegionTag(fileName) {
    const m = String(fileName).match(/^\s*\[([^\]]+)\]/);
    if (m) return normalizeSpaces(m[1]);
    return "";
  }

  function normalizeWorkplace(raw, regionTag, opt) {
    const s0 = normalizeSpaces(raw);
    if (!s0) return "";
    let s = s0;
    if (opt.normalizeOn) s = s.replace(/\s+/g, " ").trim();

    if (opt.prefixOn && regionTag) {
      if (!/^\[[^\]]+\]/.test(s)) {
        s = `[${regionTag}] ${s}`;
      }
    }
    return s;
  }

  // ---------------------------
  // Note parsing (전소속교 → 전출 근무지 추정)
  // ---------------------------
  function noteHeaderSuggestsPrevAffiliation(headerKey) {
    return /(전소속|전소속교|전소속\/직급|전소속\/직위|전소속\/직명)/.test(headerKey);
  }

  function parsePlaceFromNote(note, heur) {
    const s = normalizeSpaces(note);
    if (!s) return "";

    if (s.includes("/")) {
      const left = s.split("/")[0].trim();
      if (heur.isPlaceLike(left)) return left;
    }

    const cleaned = s.replace(/\(.*?\)/g, " ").replace(/\s+/g, " ").trim();
    const parts = cleaned.split(/[,\s]+/).filter(Boolean);

    let best = "";
    for (let i = 0; i < parts.length; i++) {
      let acc = "";
      for (let j = i; j < Math.min(parts.length, i + 6); j++) {
        acc = (acc ? acc + " " : "") + parts[j];
        if (heur.isPlaceLike(acc) && acc.length > best.length) best = acc;
      }
    }

    if (!best && heur.isPlaceLike(cleaned)) best = cleaned;
    return best;
  }

  // ---------------------------
  // Data model: group aggregation (workplace + district)
  // ---------------------------
  function getGroup(map, key, name) {
    if (!map.has(key)) {
      map.set(key, {
        key,
        name,
        inMoves: [],
        outMoves: [],
        jobs: new Map(), // jobKey -> { staffType, jobKey, jobName, inMoves, outMoves }
      });
    }
    return map.get(key);
  }

  function getJobAgg(g, jobKey, staffType, jobName) {
    if (!g.jobs.has(jobKey)) {
      g.jobs.set(jobKey, { staffType, jobKey, jobName, inMoves: [], outMoves: [] });
    }
    return g.jobs.get(jobKey);
  }

  function addMoveToMap(map, key, dir, move) {
    if (!key) return;
    const g = getGroup(map, key, key);
    if (dir === "in") {
      g.inMoves.push(move);
      const j = getJobAgg(g, move.jobKey, move.staffType, move.jobName);
      j.inMoves.push(move);
    } else {
      g.outMoves.push(move);
      const j = getJobAgg(g, move.jobKey, move.staffType, move.jobName);
      j.outMoves.push(move);
    }
  }

  function addMove(move) {
    state.moves.push(move);

    // workplace aggregation
    if (move.inWorkplace) addMoveToMap(state.workplaces, move.inWorkplace, "in", move);
    if (move.outWorkplace) addMoveToMap(state.workplaces, move.outWorkplace, "out", move);

    // district aggregation
    if (move.inDistrict) addMoveToMap(state.districts, move.inDistrict, "in", move);
    if (move.outDistrict) addMoveToMap(state.districts, move.outDistrict, "out", move);
  }

  // ---------------------------
  // Sorting helpers
  // ---------------------------
  function toggleSort(sortState, key) {
    if (sortState.key === key) {
      sortState.dir = (sortState.dir === "asc") ? "desc" : "asc";
    } else {
      sortState.key = key;
      sortState.dir = (key === "name" || key === "workplace" || key === "jobName" || key === "staffType") ? "asc" : "desc";
    }
  }

  function compare(a, b, dir) {
    if (a === b) return 0;
    const s = (dir === "asc") ? 1 : -1;
    return (a > b ? 1 : -1) * s;
  }

  function cmpKo(a, b, dir) {
    const s = (dir === "asc") ? 1 : -1;
    return a.localeCompare(b, "ko") * s;
  }

  function renderSortIndicators(tableEl, sortState) {
    const ths = [...tableEl.querySelectorAll("thead th.sortable")];
    ths.forEach(th => {
      const span = th.querySelector(".sort-ind");
      if (!span) return;
      const key = th.dataset.sort;
      if (key === sortState.key) {
        span.textContent = sortState.dir === "asc" ? "▲" : "▼";
      } else {
        span.textContent = "";
      }
    });
  }

  // ---------------------------
  // Rendering: analysis banner
  // ---------------------------
  function renderAnalyzeBanner() {
    if (!state.stats) return;

    el.analyzeBanner.style.display = "";

    const s = state.stats;
    const netText = s.netDiff > 0 ? `+${s.netDiff}` : String(s.netDiff);

    el.globalTotals.innerHTML = `
      총 레코드 <b>${s.totalRecords}</b>건 · 전출(출발) <b>${s.totalOut}</b> · 전입(도착) <b>${s.totalIn}</b> · 총차이(전출-전입) <b class="mono">${escapeHtml(netText)}</b>
      <br/>
      (전출만 <b>${s.onlyOut}</b>, 전입만 <b>${s.onlyIn}</b>, 양쪽 모두 <b>${s.both}</b>)
    `;

    el.globalBadges.innerHTML = "";
    const frag = document.createDocumentFragment();

    const wCnt = state.workplaceOrder.length;
    const dCnt = state.districtOrder.length;

    const pillW = document.createElement("span");
    pillW.className = "pill gray";
    pillW.textContent = `근무지 ${wCnt}개`;
    frag.appendChild(pillW);

    const pillD = document.createElement("span");
    pillD.className = "pill gray";
    pillD.textContent = `시군구 ${dCnt}개`;
    frag.appendChild(pillD);

    const pillView = document.createElement("span");
    pillView.className = "pill gray";
    pillView.textContent = `현재 보기: ${unitLabel(getUnit())}`;
    frag.appendChild(pillView);

    if (state.dedupe.strictSkipped > 0) {
      const p = document.createElement("span");
      p.className = "pill red";
      p.textContent = `중복 레코드 ${state.dedupe.strictSkipped}건 제외됨`;
      frag.appendChild(p);
    } else {
      const p = document.createElement("span");
      p.className = "pill green";
      p.textContent = `중복(완전 동일) 제외: 0건`;
      frag.appendChild(p);
    }

    if (state.dedupe.looseCollisions > 0) {
      const p = document.createElement("span");
      p.className = "pill amber";
      p.textContent = `중복 의심 ${state.dedupe.looseCollisions}건(값 일부 상이)`;
      frag.appendChild(p);
    } else {
      const p = document.createElement("span");
      p.className = "pill gray";
      p.textContent = `중복 의심: 0건`;
      frag.appendChild(p);
    }

    const pMask = document.createElement("span");
    pMask.className = "pill gray";
    pMask.textContent = state.maskNames ? "이름 마스킹: ON" : "이름 마스킹: OFF(본명 표시)";
    frag.appendChild(pMask);

    // 시군구 미분류 안내(있으면)
    const mis = state.districts.get("미분류");
    if (mis && (mis.inMoves.length + mis.outMoves.length) > 0) {
      const p = document.createElement("span");
      p.className = "pill amber";
      p.textContent = `시군구 미분류: 전출 ${mis.outMoves.length} · 전입 ${mis.inMoves.length} (보정 규칙 활용 가능)`;
      frag.appendChild(p);
    }

    el.globalBadges.appendChild(frag);
  }

  // ---------------------------
  // Rendering: Group select + job select (active unit)
  // ---------------------------
  function renderWorkplaceSelect() {
    const unit = getUnit();
    const map = getMapByUnit(unit);
    const order = getOrderByUnit(unit);

    const q = (el.workplaceSearch.value || "").trim();
    const opts = [];

    for (const key of order) {
      const g = map.get(key);
      if (!g) continue;
      if (q && !includesNorm(g.name, q)) continue;
      opts.push({ key: g.key, name: g.name });
    }

    const current = getSelectedKeyByUnit(unit);
    const hasCurrent = opts.some(o => o.key === current);

    el.workplaceSelect.innerHTML = "";
    const frag = document.createDocumentFragment();
    for (const o of opts) {
      const opt = document.createElement("option");
      opt.value = o.key;
      opt.textContent = o.name;
      frag.appendChild(opt);
    }
    el.workplaceSelect.appendChild(frag);

    if (!hasCurrent) setSelectedKeyByUnit(unit, (opts[0]?.key || ""));
    el.workplaceSelect.value = getSelectedKeyByUnit(unit);

    el.workplaceMeta.textContent = `표시 중: ${opts.length}개 ${unitLabel(unit)}`;
  }

  function renderJobSelect() {
    const unit = getUnit();
    const map = getMapByUnit(unit);
    const g = map.get(getSelectedKeyByUnit(unit));
    if (!g) return;

    const list = [];
    for (const [, j] of g.jobs) {
      const inC = j.inMoves.length;
      const outC = j.outMoves.length;
      const diff = outC - inC;
      list.push({
        staffType: j.staffType,
        jobKey: j.jobKey,
        jobName: j.jobName,
        inC,
        outC,
        diff,
        total: inC + outC,
      });
    }

    list.sort((a,b) => (b.total - a.total) || cmpKo(a.jobName, b.jobName, "asc"));

    el.jobSelect.innerHTML = "";
    const frag = document.createDocumentFragment();

    const optAll = document.createElement("option");
    optAll.value = "ALL";
    optAll.textContent = `전체 직종`;
    frag.appendChild(optAll);

    for (const r of list) {
      const opt = document.createElement("option");
      opt.value = r.jobKey;
      const badge =
        r.diff > 0 ? `결원 의심 +${r.diff}` :
        r.diff < 0 ? `순증가 ${-r.diff}` :
        `균형 0`;
      opt.textContent = `[${r.staffType}] ${r.jobName} (전출 ${r.outC}/전입 ${r.inC} · ${badge})`;
      frag.appendChild(opt);
    }

    el.jobSelect.appendChild(frag);

    const selectedJobKey = getSelectedJobKeyByUnit(unit);
    if (selectedJobKey !== "ALL" && !list.some(x => x.jobKey === selectedJobKey)) {
      setSelectedJobKeyByUnit(unit, "ALL");
    }
    el.jobSelect.value = getSelectedJobKeyByUnit(unit);

    el.jobMeta.textContent = `직종(직급·과목) ${list.length}개`;
  }

  // ---------------------------
  // Rendering: Group detail (active unit)
  // ---------------------------
  function renderWorkplaceDetail() {
    const unit = getUnit();
    const map = getMapByUnit(unit);
    const sortState = getSortJobsByUnit(unit);

    const g = map.get(getSelectedKeyByUnit(unit));
    if (!g) return;

    const rows = [];
    for (const [, j] of g.jobs) {
      const inC = j.inMoves.length;
      const outC = j.outMoves.length;
      rows.push({
        staffType: j.staffType,
        jobKey: j.jobKey,
        jobName: j.jobName,
        in: inC,
        out: outC,
        diff: outC - inC,
        total: inC + outC,
        agg: j,
      });
    }

    rows.sort((a,b) => {
      const k = sortState.key;
      const dir = sortState.dir;
      if (k === "staffType") return cmpKo(a.staffType, b.staffType, dir) || cmpKo(a.jobName, b.jobName, "asc");
      if (k === "jobName") return cmpKo(a.jobName, b.jobName, dir);
      if (k === "in") return compare(a.in, b.in, dir) || cmpKo(a.jobName, b.jobName, "asc");
      if (k === "out") return compare(a.out, b.out, dir) || cmpKo(a.jobName, b.jobName, "asc");
      if (k === "diff") return compare(a.diff, b.diff, dir) || cmpKo(a.jobName, b.jobName, "asc");
      if (k === "total") return compare(a.total, b.total, dir) || cmpKo(a.jobName, b.jobName, "asc");
      return cmpKo(a.jobName, b.jobName, "asc");
    });

    const inTotal = g.inMoves.length;
    const outTotal = g.outMoves.length;
    const diffTotal = outTotal - inTotal;

    const badge =
      diffTotal > 0 ? `<span class="pill red">결원 의심 +${diffTotal}</span>` :
      diffTotal < 0 ? `<span class="pill blue">순증가 ${-diffTotal}</span>` :
      `<span class="pill gray">균형 0</span>`;

    el.workplaceMeta.innerHTML = `${unitLabel(unit)}: <b>${escapeHtml(g.name)}</b> · 전출 ${outTotal} · 전입 ${inTotal} · 총변동 ${inTotal + outTotal} · ${badge}`;

    el.jobTableBody.innerHTML = "";
    const frag = document.createDocumentFragment();

    for (const r of rows) {
      const tr = document.createElement("tr");
      tr.className = "clickable";
      tr.dataset.jobKey = r.jobKey;

      const diffPill =
        r.diff > 0 ? `<span class="pill red">+${r.diff}</span>` :
        r.diff < 0 ? `<span class="pill blue">${r.diff}</span>` :
        `<span class="pill gray">0</span>`;

      tr.innerHTML = `
        <td>${escapeHtml(r.staffType)}</td>
        <td><b>${escapeHtml(r.jobName)}</b></td>
        <td class="numeric">${r.out}</td>
        <td class="numeric">${r.in}</td>
        <td class="numeric">${diffPill}</td>
        <td class="numeric">${r.total}</td>
      `;

      tr.addEventListener("mouseenter", (e) => {
        const html = `
          <div><b>${escapeHtml(g.name)}</b></div>
          <div class="mini">[${escapeHtml(r.staffType)}] ${escapeHtml(r.jobName)}</div>
          <div class="mini" style="margin-top:6px;">
            전출 <b>${r.out}</b> · 전입 <b>${r.in}</b> · 차이 <b>${escapeHtml(r.diff>0?`+${r.diff}`:String(r.diff))}</b>
          </div>
          <div class="mini muted" style="margin-top:6px;">클릭하면 아래 명단이 이 직종으로 전환됩니다.</div>
        `;
        showTooltip(html, e.clientX, e.clientY);
      });
      tr.addEventListener("mousemove", (e) => {
        if (el.tooltip.style.display === "block") showTooltip(el.tooltip.innerHTML, e.clientX, e.clientY);
      });
      tr.addEventListener("mouseleave", hideTooltip);

      tr.addEventListener("click", () => {
        setSelectedJobKeyByUnit(unit, r.jobKey);
        el.jobSelect.value = r.jobKey;
        renderListsForSelectedJob();

        [...el.jobTableBody.querySelectorAll("tr")].forEach(x => x.classList.remove("is-selected"));
        tr.classList.add("is-selected");
      });

      frag.appendChild(tr);
    }

    el.jobTableBody.appendChild(frag);
    renderSortIndicators(document.getElementById("jobTable"), sortState);

    setTimeout(() => {
      const trs = [...el.jobTableBody.querySelectorAll("tr")];
      trs.forEach(t => t.classList.remove("is-selected"));
      const sj = getSelectedJobKeyByUnit(unit);
      if (sj !== "ALL") {
        const hit = trs.find(t => t.dataset.jobKey === sj);
        if (hit) hit.classList.add("is-selected");
      }
    }, 0);

    renderListsForSelectedJob();
  }

  function renderListsForSelectedJob() {
    const unit = getUnit();
    const map = getMapByUnit(unit);

    const g = map.get(getSelectedKeyByUnit(unit));
    if (!g) return;

    const jobKey = getSelectedJobKeyByUnit(unit);
    let inMoves = [];
    let outMoves = [];
    let title = "";

    if (jobKey === "ALL") {
      inMoves = g.inMoves.slice();
      outMoves = g.outMoves.slice();
      title = `전체 직종`;
    } else {
      const agg = g.jobs.get(jobKey);
      if (agg) {
        inMoves = agg.inMoves.slice();
        outMoves = agg.outMoves.slice();
        title = `[${agg.staffType}] ${agg.jobName}`;
      }
    }

    inMoves.sort((a,b) => a.seq - b.seq);
    outMoves.sort((a,b) => a.seq - b.seq);

    const makeEvidence = (m) => {
      const fileShort = safeShort(m.fileName, 34);
      const sheetShort = safeShort(m.sheetName, 24);
      const full = `${m.fileName} / ${m.sheetName} / ${m.rowIndex}행`;
      return `<span class="mono muted mini wrap-any" title="${escapeHtml(full)}">(${escapeHtml(fileShort)} / ${escapeHtml(sheetShort)} / ${m.rowIndex}행)</span>`;
    };

    const unitSideBadge = (m, side) => {
      if (unit !== "district") return "";
      const label = side === "in" ? (m.inDistrict || "-") : (m.outDistrict || "-");
      return ` <span class="pill gray">${escapeHtml(label)}</span>`;
    };

    const inList = inMoves.map(m => `
      <li>
        <span class="who">${escapeHtml(displayName(m.name) || "(이름없음)")}</span>
        <span class="meta">
          ← ${escapeHtml(m.outWorkplace || "-")}
          ${unitSideBadge(m, "out")}
          ${m.note ? ` <span class="pill gray">${escapeHtml(m.note)}</span>` : ""}
          ${m.staffType ? ` <span class="pill gray">${escapeHtml(m.staffType)}</span>` : ""}
          ${makeEvidence(m)}
        </span>
      </li>
    `).join("");

    const outList = outMoves.map(m => `
      <li>
        <span class="who">${escapeHtml(displayName(m.name) || "(이름없음)")}</span>
        <span class="meta">
          → ${escapeHtml(m.inWorkplace || "-")}
          ${unitSideBadge(m, "in")}
          ${m.note ? ` <span class="pill gray">${escapeHtml(m.note)}</span>` : ""}
          ${m.staffType ? ` <span class="pill gray">${escapeHtml(m.staffType)}</span>` : ""}
          ${makeEvidence(m)}
        </span>
      </li>
    `).join("");

    const diff = outMoves.length - inMoves.length;
    const badge =
      diff > 0 ? `<span class="pill red">결원 의심 +${diff}</span>` :
      diff < 0 ? `<span class="pill blue">순증가 ${-diff}</span>` :
      `<span class="pill gray">균형 0</span>`;

    el.detailLists.innerHTML = `
      <div class="tool-card" style="margin:0; border-color: var(--line);">
        <div class="row between" style="flex-wrap:wrap; margin-bottom:8px;">
          <div>
            <div class="mini muted">선택 ${escapeHtml(unitLabel(unit))}</div>
            <div style="font-weight:900; font-size:1.05rem;">${escapeHtml(g.name)}</div>
            <div class="mini muted" style="margin-top:4px;">직종: <b>${escapeHtml(title)}</b></div>
            <div class="mini muted" style="margin-top:4px;">※ 원본 근거(파일/시트/행)는 명단 항목 오른쪽 괄호에 표시됩니다.</div>
          </div>
          <div style="display:flex; flex-direction:column; align-items:flex-end; gap:6px;">
            ${badge}
            <span class="pill gray">전출 ${outMoves.length} · 전입 ${inMoves.length}</span>
          </div>
        </div>

        <hr/>

        <div class="grid-two">
          <div class="tool-card" style="margin:0; background:#fff;">
            <h3 class="tool-title" style="margin:0; font-size:1.05rem;">전출/퇴직 명단</h3>
            <p class="muted mini" style="margin:6px 0 0;">(이 ${escapeHtml(unitLabel(unit))}를 떠나는 사람들)</p>
            <ul class="clean-list" style="margin-top:8px;">${outList || `<li class="muted">없음</li>`}</ul>
          </div>
          <div class="tool-card" style="margin:0; background:#fff;">
            <h3 class="tool-title" style="margin:0; font-size:1.05rem;">전입 명단</h3>
            <p class="muted mini" style="margin:6px 0 0;">(이 ${escapeHtml(unitLabel(unit))}로 오는 사람들)</p>
            <ul class="clean-list" style="margin-top:8px;">${inList || `<li class="muted">없음</li>`}</ul>
          </div>
        </div>
      </div>
    `;
  }

  // ---------------------------
  // Summary selection meta (active unit)
  // ---------------------------
  function updateSummarySelectionMeta(displayKeys, unit = getUnit()) {
    const selectedSet = getSummarySelectedByUnit(unit);
    const totalSelected = selectedSet.size;
    const displaySelected = displayKeys.reduce((acc, k) => acc + (selectedSet.has(k) ? 1 : 0), 0);

    el.summaryStats.textContent = `(${unitLabel(unit)} 기준) 표시 중: ${displayKeys.length}개 · 선택: ${totalSelected}개 (현재 표시 중 ${displaySelected}개)`;

    if (el.summaryCheckAll) {
      el.summaryCheckAll.checked = displayKeys.length > 0 && displaySelected === displayKeys.length;
      el.summaryCheckAll.indeterminate = displaySelected > 0 && displaySelected < displayKeys.length;
    }
  }

  // ---------------------------
  // Rendering: Summary table (active unit)
  // ---------------------------
  function renderSummary() {
    const unit = getUnit();
    const map = getMapByUnit(unit);
    const order = getOrderByUnit(unit);
    const sortState = getSortSummaryByUnit(unit);
    const selectedSet = getSummarySelectedByUnit(unit);

    const q = el.summarySearch.value || "";
    const mode = el.summaryFilter.value;

    const list = [];
    for (const key of order) {
      const g = map.get(key);
      if (!g) continue;
      if (q && !includesNorm(g.name, q)) continue;

      const inC = g.inMoves.length;
      const outC = g.outMoves.length;
      const diff = outC - inC;
      const total = inC + outC;

      if (mode === "outMore" && diff <= 0) continue;
      if (mode === "inMore" && diff >= 0) continue;
      if (mode === "equal" && diff !== 0) continue;

      list.push({ key, name: g.name, in: inC, out: outC, diff, total });
    }

    list.sort((a,b) => {
      const k = sortState.key;
      const dir = sortState.dir;
      if (k === "name") return cmpKo(a.name, b.name, dir);
      if (k === "in") return compare(a.in, b.in, dir) || cmpKo(a.name, b.name, "asc");
      if (k === "out") return compare(a.out, b.out, dir) || cmpKo(a.name, b.name, "asc");
      if (k === "diff") return compare(a.diff, b.diff, dir) || cmpKo(a.name, b.name, "asc");
      if (k === "total") return compare(a.total, b.total, dir) || cmpKo(a.name, b.name, "asc");
      return cmpKo(a.name, b.name, "asc");
    });

    const displayKeys = list.map(x => x.key);
    setSummaryLastKeysByUnit(unit, displayKeys.slice());
    updateSummarySelectionMeta(displayKeys, unit);

    el.summaryTableBody.innerHTML = "";
    const frag = document.createDocumentFragment();

    for (const r of list) {
      const tr = document.createElement("tr");
      tr.className = "clickable";
      tr.dataset.key = r.key;

      const checked = selectedSet.has(r.key);

      const diffPill =
        r.diff > 0 ? `<span class="pill red">+${r.diff}</span>` :
        r.diff < 0 ? `<span class="pill blue">${r.diff}</span>` :
        `<span class="pill gray">0</span>`;

      tr.innerHTML = `
        <td class="td-check">
          <input type="checkbox" class="summaryRowCheck" ${checked ? "checked" : ""} aria-label="선택" />
        </td>
        <td><b>${escapeHtml(r.name)}</b></td>
        <td class="numeric">${r.out}</td>
        <td class="numeric">${r.in}</td>
        <td class="numeric">${r.total}</td>
        <td class="numeric">${diffPill}</td>
      `;

      const cb = tr.querySelector(".summaryRowCheck");
      cb.addEventListener("click", (e) => e.stopPropagation());
      cb.addEventListener("change", (e) => {
        e.stopPropagation();
        if (cb.checked) selectedSet.add(r.key);
        else selectedSet.delete(r.key);
        updateSummarySelectionMeta(getSummaryLastKeysByUnit(unit), unit);
      });

      tr.addEventListener("mouseenter", (e) => {
        const html = `
          <div><b>${escapeHtml(r.name)}</b></div>
          <div class="mini" style="margin-top:6px;">
            전출 <b>${r.out}</b> · 전입 <b>${r.in}</b> · 총변동 <b>${r.total}</b> · 차이 <b>${escapeHtml(r.diff>0?`+${r.diff}`:String(r.diff))}</b>
          </div>
          <div class="mini muted" style="margin-top:6px;">행 클릭: 2) 상세 이동 · 체크: 선택 엑셀 저장 대상</div>
        `;
        showTooltip(html, e.clientX, e.clientY);
      });
      tr.addEventListener("mousemove", (e) => {
        if (el.tooltip.style.display === "block") showTooltip(el.tooltip.innerHTML, e.clientX, e.clientY);
      });
      tr.addEventListener("mouseleave", hideTooltip);

      tr.addEventListener("click", () => {
        setSelectedKeyByUnit(unit, r.key);
        setSelectedJobKeyByUnit(unit, "ALL");
        renderWorkplaceSelect();
        renderJobSelect();
        renderWorkplaceDetail();
        document.getElementById("detailSection")?.scrollIntoView({ behavior:"smooth", block:"start" });
      });

      frag.appendChild(tr);
    }

    el.summaryTableBody.appendChild(frag);
    renderSortIndicators(document.getElementById("summaryTable"), sortState);
  }

  // ---------------------------
  // Rendering: Suspect list (active unit)
  // ---------------------------
  function renderSuspect() {
    const unit = getUnit();
    const map = getMapByUnit(unit);
    const order = getOrderByUnit(unit);
    const sortState = getSortSuspectByUnit(unit);

    const q = el.suspectSearch.value || "";
    const type = el.suspectType.value;

    const rows = [];
    for (const key of order) {
      const g = map.get(key);
      if (!g) continue;

      for (const [, j] of g.jobs) {
        const inC = j.inMoves.length;
        const outC = j.outMoves.length;
        const diff = outC - inC;
        if (diff <= 0) continue;

        const jobName = j.jobName;
        const staffType = j.staffType;

        if (type !== "ALL" && staffType !== type) continue;

        if (q) {
          const hay = `${g.name} ${jobName} ${staffType}`;
          if (!includesNorm(hay, q)) continue;
        }

        rows.push({
          groupKey: g.key,
          groupName: g.name,
          staffType,
          jobKey: j.jobKey,
          jobName,
          in: inC,
          out: outC,
          diff,
        });
      }
    }

    rows.sort((a,b) => {
      const k = sortState.key;
      const dir = sortState.dir;
      if (k === "staffType") return cmpKo(a.staffType, b.staffType, dir) || cmpKo(a.groupName, b.groupName, "asc");
      if (k === "workplace") return cmpKo(a.groupName, b.groupName, dir) || cmpKo(a.jobName, b.jobName, "asc");
      if (k === "jobName") return cmpKo(a.jobName, b.jobName, dir);
      if (k === "in") return compare(a.in, b.in, dir) || compare(a.diff, b.diff, "desc");
      if (k === "out") return compare(a.out, b.out, dir) || compare(a.diff, b.diff, "desc");
      if (k === "diff") return compare(a.diff, b.diff, dir) || cmpKo(a.groupName, b.groupName, "asc");
      return compare(a.diff, b.diff, "desc");
    });

    el.suspectStats.textContent = `(${unitLabel(unit)} 기준) 결원 의심 ${rows.length}건`;

    el.suspectTableBody.innerHTML = "";
    const frag = document.createDocumentFragment();

    for (const r of rows) {
      const tr = document.createElement("tr");
      tr.className = "clickable";
      tr.dataset.groupKey = r.groupKey;
      tr.dataset.jobKey = r.jobKey;

      tr.innerHTML = `
        <td>${escapeHtml(r.staffType)}</td>
        <td><b>${escapeHtml(r.groupName)}</b></td>
        <td>${escapeHtml(r.jobName)}</td>
        <td class="numeric">${r.out}</td>
        <td class="numeric">${r.in}</td>
        <td class="numeric"><span class="pill red">+${r.diff}</span></td>
      `;

      tr.addEventListener("mouseenter", (e) => {
        const html = `
          <div><b>${escapeHtml(r.groupName)}</b></div>
          <div class="mini">[${escapeHtml(r.staffType)}] ${escapeHtml(r.jobName)}</div>
          <div class="mini" style="margin-top:6px;">
            전출 <b>${r.out}</b> · 전입 <b>${r.in}</b> · 결원 의심 <b>+${r.diff}</b>
          </div>
          <div class="mini muted" style="margin-top:6px;">클릭하면 2) 상세내역에서 명단 확인 가능.</div>
        `;
        showTooltip(html, e.clientX, e.clientY);
      });
      tr.addEventListener("mousemove", (e) => {
        if (el.tooltip.style.display === "block") showTooltip(el.tooltip.innerHTML, e.clientX, e.clientY);
      });
      tr.addEventListener("mouseleave", hideTooltip);

      tr.addEventListener("click", () => {
        setSelectedKeyByUnit(unit, r.groupKey);
        setSelectedJobKeyByUnit(unit, r.jobKey);

        renderWorkplaceSelect();
        renderJobSelect();
        renderWorkplaceDetail();

        el.jobSelect.value = r.jobKey;
        renderListsForSelectedJob();

        setTimeout(() => {
          const trs = [...el.jobTableBody.querySelectorAll("tr")];
          trs.forEach(t => t.classList.remove("is-selected"));
          const hit = trs.find(t => t.dataset.jobKey === r.jobKey);
          if (hit) hit.classList.add("is-selected");
        }, 0);

        document.getElementById("detailSection")?.scrollIntoView({ behavior:"smooth", block:"start" });
      });

      frag.appendChild(tr);
    }

    el.suspectTableBody.appendChild(frag);
    renderSortIndicators(document.getElementById("suspectTable"), sortState);
  }

  // ---------------------------
  // File selection / drag & drop
  // ---------------------------
  function updateFileMeta() {
    const n = state.files.length;
    el.fileMeta.textContent = n ? `선택됨: ${n}개 · 총 ${bytesToHuman(state.files.reduce((a,f)=>a+f.size,0))}` : "";
    el.fileListSummary.textContent = `선택된 파일 (${n}개)`;
  }

  function renderFileList() {
    el.fileList.innerHTML = "";
    const frag = document.createDocumentFragment();
    for (const f of state.files) {
      const li = document.createElement("li");
      li.innerHTML = `
        <div class="wrap-any"><b>${escapeHtml(f.name)}</b></div>
        <div class="mini muted">${bytesToHuman(f.size)} · 수정 ${escapeHtml(new Date(f.lastModified).toLocaleString())}</div>
      `;
      frag.appendChild(li);
    }
    el.fileList.appendChild(frag);
  }

  function setFiles(files) {
    state.files = Array.from(files || []);
    updateFileMeta();
    renderFileList();
  }

  // ---------------------------
  // Dedupe helpers
  // ---------------------------
  function resetDedupe() {
    state.dedupe.strictSeen = new Set();
    state.dedupe.strictSkipped = 0;
    state.dedupe.looseMap = new Map();
    state.dedupe.looseCollisions = 0;
    state.dedupe.looseExamples = [];
  }

  function makeStrictKey(m) {
    return [
      m.sheetName,
      m.seq,
      m.staffType,
      m.jobName,
      m.name,
      m.inWorkplace,
      m.outWorkplace,
      m.note
    ].join("||");
  }

  function makeLooseKey(m) {
    return [
      m.sheetName,
      m.seq,
      m.staffType,
      m.jobName,
      m.name,
      m.inWorkplace,
      m.outWorkplace
    ].join("||");
  }

  function tryDedupe(m) {
    const strictKey = makeStrictKey(m);
    if (state.dedupe.strictSeen.has(strictKey)) {
      state.dedupe.strictSkipped++;
      return false;
    }
    state.dedupe.strictSeen.add(strictKey);

    const looseKey = makeLooseKey(m);
    const prev = state.dedupe.looseMap.get(looseKey);
    if (prev !== undefined && prev !== m.note) {
      state.dedupe.looseCollisions++;
      if (state.dedupe.looseExamples.length < 12) {
        state.dedupe.looseExamples.push({
          name: m.name,
          jobName: m.jobName,
          inWorkplace: m.inWorkplace,
          outWorkplace: m.outWorkplace,
          noteA: prev,
          noteB: m.note,
          sheetName: m.sheetName,
          seq: m.seq,
        });
      }
    } else if (prev === undefined) {
      state.dedupe.looseMap.set(looseKey, m.note);
    }

    return true;
  }

  // ---------------------------
  // ✅ XLSX export helpers
  // ---------------------------
  function pad2(n){ return String(n).padStart(2,"0"); }
  function nowStamp() {
    const d = new Date();
    return `${d.getFullYear()}${pad2(d.getMonth()+1)}${pad2(d.getDate())}_${pad2(d.getHours())}${pad2(d.getMinutes())}`;
  }

  function sanitizeFileName(name) {
    return String(name || "인사집계").replace(/[\\/:*?"<>|]/g, "_");
  }

  function sanitizeSheetName(name) {
    let s = String(name || "시트");
    s = s.replace(/[\\\/\?\*\[\]\:]/g, "_").trim();
    if (!s) s = "시트";
    if (s.length > 31) s = s.slice(0, 31);
    return s;
  }

  function uniqueSheetName(base, used) {
    let name = sanitizeSheetName(base);
    if (!used.has(name)) { used.add(name); return name; }

    let i = 2;
    while (i < 1000) {
      const suffix = `_${i}`;
      const cut = Math.max(1, 31 - suffix.length);
      const candidate = sanitizeSheetName(name.slice(0, cut) + suffix);
      if (!used.has(candidate)) { used.add(candidate); return candidate; }
      i++;
    }
    const fallback = `시트_${used.size+1}`;
    used.add(fallback);
    return fallback;
  }

  function buildSummaryAoa(unit, groupKeys) {
    const rows = [[`${unitLabel(unit)}`, "전출", "전입", "총 인사변동", "차이(전출-전입)"]];
    const map = getMapByUnit(unit);
    for (const key of groupKeys) {
      const g = map.get(key);
      if (!g) continue;
      const inC = g.inMoves.length;
      const outC = g.outMoves.length;
      const diff = outC - inC;
      const total = inC + outC;
      rows.push([g.name, outC, inC, total, diff]);
    }
    return rows;
  }

  function buildGroupDetailAoa(unit, g) {
    const rows = [[
      `${unitLabel(unit)}(기준)`,
      "구분",
      "성명",
      "직종(직급·과목)",
      "직군(구분)",
      "전출(현소속) 근무지",
      "전입(발령) 근무지",
      "전출 시군구",
      "전입 시군구",
      "비고",
      "파일",
      "시트",
      "행"
    ]];

    const outMoves = g.outMoves.slice().sort((a,b)=>a.seq-b.seq);
    const inMoves  = g.inMoves.slice().sort((a,b)=>a.seq-b.seq);

    for (const m of outMoves) {
      rows.push([
        g.name,
        "전출",
        displayName(m.name),
        m.jobName,
        m.staffType,
        m.outWorkplace,
        m.inWorkplace,
        m.outDistrict,
        m.inDistrict,
        m.note,
        m.fileName,
        m.sheetName,
        m.rowIndex
      ]);
    }
    for (const m of inMoves) {
      rows.push([
        g.name,
        "전입",
        displayName(m.name),
        m.jobName,
        m.staffType,
        m.outWorkplace,
        m.inWorkplace,
        m.outDistrict,
        m.inDistrict,
        m.note,
        m.fileName,
        m.sheetName,
        m.rowIndex
      ]);
    }
    return rows;
  }

  function buildSuspectAoa(unit, groupKeysSetOrNull) {
    const rows = [["구분", `${unitLabel(unit)}`, "직종(직급·과목)", "전출", "전입", "결원 의심(전출-전입)"]];
    const map = getMapByUnit(unit);
    const order = getOrderByUnit(unit);

    for (const key of order) {
      if (groupKeysSetOrNull && !groupKeysSetOrNull.has(key)) continue;
      const g = map.get(key);
      if (!g) continue;
      for (const [, j] of g.jobs) {
        const inC = j.inMoves.length;
        const outC = j.outMoves.length;
        const diff = outC - inC;
        if (diff <= 0) continue;
        rows.push([j.staffType, g.name, j.jobName, outC, inC, diff]);
      }
    }
    return rows;
  }

  function buildDedupeExamplesAoa() {
    const rows = [["시트", "연번", "성명", "직종", "전출→전입", "note(기존)", "note(신규)"]];
    for (const ex of state.dedupe.looseExamples) {
      rows.push([
        ex.sheetName,
        ex.seq,
        ex.name,
        ex.jobName,
        `${ex.outWorkplace} → ${ex.inWorkplace}`,
        ex.noteA,
        ex.noteB
      ]);
    }
    return rows;
  }

  function downloadWorkbookForKeys(unit, groupKeys, filenameBase) {
    if (!state.analyzed) return;
    if (!window.XLSX) {
      alert("엑셀(XLSX) 라이브러리가 로드되지 않아 저장할 수 없습니다.");
      return;
    }
    const keys = Array.from(groupKeys || []).filter(Boolean);
    if (!keys.length) {
      alert("저장할 항목이 없습니다.");
      return;
    }

    const wb = XLSX.utils.book_new();
    const used = new Set();

    // 요약
    const wsSummary = XLSX.utils.aoa_to_sheet(buildSummaryAoa(unit, keys));
    XLSX.utils.book_append_sheet(wb, wsSummary, uniqueSheetName("요약", used));

    // 결원의심(선택 범위 기준)
    const wsSus = XLSX.utils.aoa_to_sheet(buildSuspectAoa(unit, new Set(keys)));
    XLSX.utils.book_append_sheet(wb, wsSus, uniqueSheetName("결원의심", used));

    // 중복 의심 예시(있으면)
    if (state.dedupe.looseExamples.length) {
      const wsDup = XLSX.utils.aoa_to_sheet(buildDedupeExamplesAoa());
      XLSX.utils.book_append_sheet(wb, wsDup, uniqueSheetName("중복의심예시", used));
    }

    // 항목별 시트
    const map = getMapByUnit(unit);
    for (const key of keys) {
      const g = map.get(key);
      if (!g) continue;
      const aoa = buildGroupDetailAoa(unit, g);
      const ws = XLSX.utils.aoa_to_sheet(aoa);
      XLSX.utils.book_append_sheet(wb, ws, uniqueSheetName(g.name, used));
    }

    const file = sanitizeFileName(`${filenameBase}_${keys.length}개_${nowStamp()}.xlsx`);
    XLSX.writeFile(wb, file);
    log(`엑셀 다운로드: ${file}`);
  }

  function downloadXlsxAll() {
    const unit = getUnit();
    const order = getOrderByUnit(unit);
    downloadWorkbookForKeys(unit, order, `인사집계_전체${unitLabel(unit)}`);
  }

  function downloadXlsxSelected() {
    const unit = getUnit();
    const selectedSet = getSummarySelectedByUnit(unit);
    const keys = [...selectedSet];
    if (!keys.length) {
      alert("선택된 항목이 없습니다. (요약 표에서 체크 후 다시 시도)");
      return;
    }
    const orderSet = new Set(keys);
    const ordered = getOrderByUnit(unit).filter(k => orderSet.has(k));
    downloadWorkbookForKeys(unit, ordered, `인사집계_선택${unitLabel(unit)}`);
  }

  function clearSelectedItems() {
    const unit = getUnit();
    getSummarySelectedByUnit(unit).clear();
    updateSummarySelectionMeta(getSummaryLastKeysByUnit(unit), unit);
    renderSummary();
  }

  function downloadXlsxBothSummary() {
    if (!state.analyzed) return;
    if (!window.XLSX) {
      alert("엑셀(XLSX) 라이브러리가 로드되지 않아 저장할 수 없습니다.");
      return;
    }

    const wb = XLSX.utils.book_new();
    const used = new Set();

    // 근무지
    XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(buildSummaryAoa("workplace", state.workplaceOrder)), uniqueSheetName("근무지_요약", used));
    XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(buildSuspectAoa("workplace", null)), uniqueSheetName("근무지_결원의심", used));

    // 시군구
    XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(buildSummaryAoa("district", state.districtOrder)), uniqueSheetName("시군구_요약", used));
    XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(buildSuspectAoa("district", null)), uniqueSheetName("시군구_결원의심", used));

    // 중복 의심 예시(있으면)
    if (state.dedupe.looseExamples.length) {
      XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(buildDedupeExamplesAoa()), uniqueSheetName("중복의심예시", used));
    }

    const file = sanitizeFileName(`인사집계_요약_두단위_${nowStamp()}.xlsx`);
    XLSX.writeFile(wb, file);
    log(`엑셀 다운로드: ${file}`);
  }

  // ---------------------------
  // CSV downloads
  // ---------------------------
  function downloadSummaryCsv() {
    if (!state.analyzed) return;
    const unit = getUnit();
    const map = getMapByUnit(unit);
    const order = getOrderByUnit(unit);

    const q = el.summarySearch.value || "";
    const mode = el.summaryFilter.value;

    const rows = [[`${unitLabel(unit)}`, "전출", "전입", "총 인사변동", "차이(전출-전입)"]];

    const list = [];
    for (const key of order) {
      const g = map.get(key);
      if (!g) continue;
      if (q && !includesNorm(g.name, q)) continue;

      const inC = g.inMoves.length;
      const outC = g.outMoves.length;
      const diff = outC - inC;
      const total = inC + outC;

      if (mode === "outMore" && diff <= 0) continue;
      if (mode === "inMore" && diff >= 0) continue;
      if (mode === "equal" && diff !== 0) continue;

      list.push({ name: g.name, in: inC, out: outC, diff, total });
    }

    list.sort((a,b) => a.name.localeCompare(b.name, "ko"));
    for (const r of list) rows.push([r.name, r.out, r.in, r.total, r.diff]);

    downloadCsv(`${unitLabel(unit)}별_요약.csv`, rows);
    log(`CSV 다운로드: 현재 요약 (${unitLabel(unit)} 기준)`);
  }

  function downloadSuspectCsv() {
    if (!state.analyzed) return;
    const unit = getUnit();
    const map = getMapByUnit(unit);
    const order = getOrderByUnit(unit);

    const q = el.suspectSearch.value || "";
    const type = el.suspectType.value;

    const rows = [["구분", `${unitLabel(unit)}`, "직종(직급·과목)", "결원 의심(전출-전입)", "전출", "전입"]];
    const list = [];

    for (const key of order) {
      const g = map.get(key);
      if (!g) continue;

      for (const [, j] of g.jobs) {
        const inC = j.inMoves.length;
        const outC = j.outMoves.length;
        const diff = outC - inC;
        if (diff <= 0) continue;

        const staffType = j.staffType;
        const jobName = j.jobName;

        if (type !== "ALL" && staffType !== type) continue;
        if (q) {
          const hay = `${g.name} ${jobName} ${staffType}`;
          if (!includesNorm(hay, q)) continue;
        }

        list.push({ staffType, groupName: g.name, jobName, diff, outC, inC });
      }
    }

    list.sort((a,b)=> (b.diff-a.diff) || a.groupName.localeCompare(b.groupName,"ko"));
    for (const r of list) rows.push([r.staffType, r.groupName, r.jobName, r.diff, r.outC, r.inC]);

    downloadCsv(`결원의심_${unitLabel(unit)}.csv`, rows);
    log(`CSV 다운로드: 결원 의심 목록 (${unitLabel(unit)} 기준)`);
  }

  function downloadDetailCsv() {
    if (!state.analyzed) return;

    const unit = getUnit();
    const map = getMapByUnit(unit);
    const g = map.get(getSelectedKeyByUnit(unit));
    if (!g) return;

    const jobKey = getSelectedJobKeyByUnit(unit);

    let inMoves = [];
    let outMoves = [];
    let jobLabel = "전체";

    if (jobKey === "ALL") {
      inMoves = g.inMoves.slice();
      outMoves = g.outMoves.slice();
    } else {
      const agg = g.jobs.get(jobKey);
      if (agg) {
        inMoves = agg.inMoves.slice();
        outMoves = agg.outMoves.slice();
        jobLabel = `[${agg.staffType}] ${agg.jobName}`;
      }
    }

    inMoves.sort((a,b)=>a.seq-b.seq);
    outMoves.sort((a,b)=>a.seq-b.seq);

    const rows = [[
      `${unitLabel(unit)}`,
      "직종(선택)",
      "구분",
      "성명",
      "전입(발령) 근무지",
      "전출(현소속) 근무지",
      "전입 시군구",
      "전출 시군구",
      "비고",
      "파일",
      "시트",
      "행"
    ]];

    for (const m of outMoves) rows.push([g.name, jobLabel, "전출", displayName(m.name), m.inWorkplace, m.outWorkplace, m.inDistrict, m.outDistrict, m.note, m.fileName, m.sheetName, m.rowIndex]);
    for (const m of inMoves) rows.push([g.name, jobLabel, "전입", displayName(m.name), m.inWorkplace, m.outWorkplace, m.inDistrict, m.outDistrict, m.note, m.fileName, m.sheetName, m.rowIndex]);

    downloadCsv(`${sanitizeFileName(g.name)}_${sanitizeFileName(jobLabel)}_상세.csv`, rows);
    log(`CSV 다운로드: 현재 상세 (${unitLabel(unit)} 기준)`);
  }

  // ---------------------------
  // Analysis
  // ---------------------------
  async function analyzeAllFiles() {
    clearLog();
    hideTooltip();

    if (!state.files.length) {
      log("파일이 선택되지 않았습니다.");
      return;
    }

    startProgress("집계 준비 중...");
    setProgress(1, "설정/옵션 확인 중...");
    await rafTick();

    el.btnAnalyze.disabled = true;

    try {
      state.viewUnit = normUnit(el.viewUnitSelect?.value || "workplace");
      syncUnitUI();

      state.heur = buildHeuristics();
      state.maskNames = !!el.optMaskNames.checked;
      el.optMaskNamesQuick.checked = state.maskNames;

      state.districtRules = parseDistrictOverrides();

      // selection reset (새 집계 기준) - 근무지/시군구 둘 다
      state.summarySelectedWorkplace.clear();
      state.summaryLastWorkplaceKeys = [];
      state.summarySelectedDistrict.clear();
      state.summaryLastDistrictKeys = [];
      if (el.summaryCheckAll) {
        el.summaryCheckAll.checked = false;
        el.summaryCheckAll.indeterminate = false;
      }

      setProgress(3, "엑셀 파서(XLSX) 준비 중...");
      await rafTick();

      const ok = await ensureXLSX();
      setLibWarning(ok);
      if (!ok) {
        log("XLSX 라이브러리 없음 → 중단");
        setProgress(0, "엑셀 파서(XLSX) 로드 실패");
        return;
      }

      el.btnAnalyze.disabled = true;

      const seqIdxManual = colToIndex(el.colSeq.value);
      const nameIdxManual = colToIndex(el.colName.value);
      const jobIdxManual = colToIndex(el.colJob.value);
      const inIdxManual = colToIndex(el.colIn.value);
      const outIdxManual = colToIndex(el.colOut.value);
      const noteIdxManual = colToIndex(el.colNote.value);

      const badCols = [
        ["연번", seqIdxManual],
        ["성명", nameIdxManual],
        ["직종", jobIdxManual],
        ["전입", inIdxManual],
        ["전출", outIdxManual],
        ["비고", noteIdxManual],
      ].filter(([, idx]) => idx === null);

      if (badCols.length) {
        log("수동 컬럼 입력이 잘못되었습니다: " + badCols.map(([k]) => k).join(", "));
        setProgress(0, "수동 컬럼 입력 오류");
        return;
      }

      const autoOn = el.optAutoDetect.checked;
      const normalizeOn = el.optNormalize.checked;
      const prefixOn = el.optPrefixRegion.checked;
      const useSubject = el.optUseSubject.checked;

      state.moves = [];
      state.workplaces.clear();
      state.workplaceOrder = [];
      state.districts.clear();
      state.districtOrder = [];

      state.analyzed = false;

      state.selectedWorkplaceKey = "";
      state.selectedDistrictKey = "";
      state.selectedJobKeyWorkplace = "ALL";
      state.selectedJobKeyDistrict = "ALL";

      state.regionTags.clear();
      state.stats = null;
      resetDedupe();

      el.analyzeBanner.style.display = "none";

      log(`집계 시작: 파일 ${state.files.length}개`);
      if (state.districtRules.length) {
        log(`- 시군구 보정 규칙 ${state.districtRules.length}개 적용`);
      }
      setProgress(5, `파일 ${state.files.length}개 집계 시작...`);
      await rafTick();

      const totalFiles = state.files.length;

      for (let fi = 0; fi < totalFiles; fi++) {
        const file = state.files[fi];
        const regionTag = inferRegionTag(file.name);
        state.regionTags.set(file.name, regionTag);

        const fileBaseRatio = fi / Math.max(1, totalFiles);
        setProgress(5 + 85 * fileBaseRatio, `[${fi + 1}/${totalFiles}] 파일 읽는 중: ${file.name}`);
        await rafTick();

        log(`\n[파일] ${file.name}${regionTag ? ` (태그: ${regionTag})` : ""}`);

        let wb = null;
        try {
          const buf = await file.arrayBuffer();
          wb = XLSX.read(buf, { type: "array" });
        } catch (err) {
          log(`  ⚠️ 파일 읽기 실패: ${err?.message || err}`);
          continue;
        }

        const sheetNames = wb.SheetNames.slice();
        log(`  시트 ${sheetNames.length}개: ${sheetNames.join(", ")}`);

        const sheetsTotal = Math.max(1, sheetNames.length);

        for (let si = 0; si < sheetNames.length; si++) {
          const sheetName = sheetNames[si];

          const ratio = (fi + (si / sheetsTotal)) / Math.max(1, totalFiles);
          setProgress(5 + 85 * ratio, `[${fi + 1}/${totalFiles}] ${file.name} · 시트 ${si + 1}/${sheetsTotal} 처리 중: ${sheetName}`);
          await rafTick();

          const ws = wb.Sheets[sheetName];
          const rows = XLSX.utils.sheet_to_json(ws, { header: 1, defval: "" });
          if (!rows || rows.length < 3) continue;

          let layout = null;
          if (autoOn) {
            layout = detectLayoutPlus(rows, state.heur);
            if (layout) {
              log(`  - [${sheetName}] 자동감지 OK: seq=${layout.seqIdx>=0?indexToCol(layout.seqIdx):"(없음)"} name=${indexToCol(layout.nameIdx)} job=${layout.jobIdx>=0?indexToCol(layout.jobIdx):"(없음)"} in=${layout.inIdx>=0?indexToCol(layout.inIdx):"(없음)"} out=${layout.outIdx>=0?indexToCol(layout.outIdx):"(없음)"} note=${layout.noteIdx>=0?indexToCol(layout.noteIdx):"(없음)"} subj=${layout.subjectIdx>=0?indexToCol(layout.subjectIdx):"(없음)"} startRow=${layout.dataStart+1}`);
            } else {
              log(`  - [${sheetName}] 자동감지 실패 → 수동 매핑 사용`);
            }
          }

          const seqIdx = layout ? layout.seqIdx : seqIdxManual;
          const nameIdx = layout ? layout.nameIdx : nameIdxManual;
          const jobIdx = (layout && layout.jobIdx >= 0) ? layout.jobIdx : jobIdxManual;
          const inIdx = layout ? layout.inIdx : inIdxManual;
          const outIdx = layout ? layout.outIdx : outIdxManual;
          const noteIdx = (layout && layout.noteIdx >= 0) ? layout.noteIdx : noteIdxManual;
          const subjectIdx = layout ? layout.subjectIdx : -1;

          const dataStart = layout ? layout.dataStart : 0;

          const outStats = (outIdx >= 0) ? analyzeColumnStats(rows, dataStart, outIdx, state.heur, 200) : null;
          const noteStats = (noteIdx >= 0) ? analyzeColumnStats(rows, dataStart, noteIdx, state.heur, 200) : null;

          let noteHeaderKey = "";
          if (layout && layout.fieldKeys && noteIdx >= 0) noteHeaderKey = layout.fieldKeys[noteIdx] || "";
          else {
            for (let rr = 0; rr < Math.min(rows.length, 8); rr++) {
              const k = cellKey((rows[rr] || [])[noteIdx]);
              if (k) { noteHeaderKey = k; break; }
            }
          }

          const useNoteAsOut =
            !!(outStats && noteStats) &&
            noteIdx >= 0 &&
            noteHeaderSuggestsPrevAffiliation(noteHeaderKey) &&
            outStats.uniqueCount <= 3 &&
            outStats.eduOfficeLikeRatio >= 0.55 &&
            outStats.schoolLikeRatio < 0.25 &&
            noteStats.schoolLikeRatio >= 0.25;

          if (useNoteAsOut) {
            log(`    ↳ 비고(전소속) 기반 '전출 근무지' 보정 적용(현소속 컬럼이 교육지원청 위주로 판단됨)`);
          }

          let recordCount = 0;

          for (let r = dataStart; r < rows.length; r++) {
            const row = rows[r] || [];

            if (seqIdx >= 0) {
              const seq = toIntLike(row[seqIdx]);
              if (seq === null) continue;
            } else {
              if (!state.heur.looksLikeName(row[nameIdx])) continue;
            }

            const seq = (seqIdx >= 0 ? (toIntLike(row[seqIdx]) ?? 0) : (r + 1));
            const name = normalizeSpaces(row[nameIdx]);
            if (!name) continue;

            let baseJob = (jobIdx >= 0 ? normalizeSpaces(row[jobIdx]) : "");
            if (!baseJob) baseJob = sheetName;

            const subject = (useSubject && subjectIdx >= 0) ? normalizeSpaces(row[subjectIdx]) : "";
            const jobName = subject ? `${baseJob}(${subject})` : baseJob;

            const staffType = detectStaffType(file.name, sheetName, jobName);
            const jobKey = `${staffType}||${jobName}`;

            const inPlaceRaw = (inIdx >= 0 ? row[inIdx] : "");
            const outPlaceRaw = (outIdx >= 0 ? row[outIdx] : "");
            const noteRaw = (noteIdx >= 0 ? row[noteIdx] : "");

            let inWorkplace = normalizeWorkplace(inPlaceRaw, regionTag, { normalizeOn, prefixOn });
            let outWorkplace = normalizeWorkplace(outPlaceRaw, regionTag, { normalizeOn, prefixOn });

            const note = normalizeSpaces(noteRaw);

            if (useNoteAsOut && note) {
              const inferred = parsePlaceFromNote(note, state.heur);
              if (inferred) outWorkplace = normalizeWorkplace(inferred, regionTag, { normalizeOn, prefixOn });
            }

            const inDistrict = inWorkplace ? inferDistrictFromWorkplace(inWorkplace) : "";
            const outDistrict = outWorkplace ? inferDistrictFromWorkplace(outWorkplace) : "";

            const move = {
              fileName: file.name,
              sheetName,
              regionTag,
              staffType,
              seq,
              name,
              jobName,
              jobKey,
              inWorkplace: inWorkplace || "",
              outWorkplace: outWorkplace || "",
              inDistrict: inDistrict || "",
              outDistrict: outDistrict || "",
              note,
              rowIndex: r + 1,
            };

            if (!tryDedupe(move)) continue;

            addMove(move);
            recordCount++;

            if (recordCount % 900 === 0) await rafTick();
          }

          if (recordCount) log(`    → [${sheetName}] 반영 ${recordCount}건`);
          else log(`    → [${sheetName}] 데이터 행을 찾지 못함(서식/헤더 확인 필요)`);
        }
      }

      setProgress(93, "집계 결과 정리/렌더링 중...");
      await rafTick();

      state.workplaceOrder = [...state.workplaces.values()]
        .sort((a,b) => a.name.localeCompare(b.name, "ko"))
        .map(w => w.key);

      // district order: 미분류/도교육청은 뒤로 보내기
      const specialRank = (name) => (name === "미분류" ? 2 : name === "도교육청" ? 1 : 0);
      state.districtOrder = [...state.districts.values()]
        .sort((a,b) => (specialRank(a.name) - specialRank(b.name)) || a.name.localeCompare(b.name, "ko"))
        .map(d => d.key);

      const totalRecords = state.moves.length;
      const totalIn = state.moves.reduce((acc,m)=>acc + (m.inWorkplace ? 1 : 0), 0);
      const totalOut = state.moves.reduce((acc,m)=>acc + (m.outWorkplace ? 1 : 0), 0);
      const netDiff = totalOut - totalIn;
      const onlyIn = state.moves.reduce((acc,m)=>acc + (m.inWorkplace && !m.outWorkplace ? 1 : 0), 0);
      const onlyOut = state.moves.reduce((acc,m)=>acc + (m.outWorkplace && !m.inWorkplace ? 1 : 0), 0);
      const both = state.moves.reduce((acc,m)=>acc + (m.inWorkplace && m.outWorkplace ? 1 : 0), 0);

      state.stats = { totalRecords, totalIn, totalOut, netDiff, onlyIn, onlyOut, both };

      state.analyzed = true;

      log(`\n집계 완료 ✅`);
      log(`- 총 이동 레코드(중복 제거 후): ${totalRecords}건`);
      log(`- 근무지(학교/기관) 수: ${state.workplaceOrder.length}개`);
      log(`- 시군구 수: ${state.districtOrder.length}개`);
      const mis = state.districts.get("미분류");
      if (mis) {
        log(`- 시군구 미분류: 전출 ${mis.outMoves.length}, 전입 ${mis.inMoves.length} (필요 시 보정 규칙 사용)`);
      }

      log(`- 중복(완전 동일) 제외: ${state.dedupe.strictSkipped}건`);
      if (state.dedupe.looseCollisions > 0) {
        log(`- 중복 의심(일부 값 상이): ${state.dedupe.looseCollisions}건`);
        for (const ex of state.dedupe.looseExamples) {
          log(`  · [의심] ${ex.sheetName} ${ex.seq} ${ex.name} / ${ex.jobName} / ${ex.outWorkplace}→${ex.inWorkplace} / note: "${ex.noteA}" vs "${ex.noteB}"`);
        }
      }

      // 기본 선택값 세팅(근무지/시군구 각각)
      state.selectedWorkplaceKey = state.workplaceOrder[0] || "";
      state.selectedDistrictKey = state.districtOrder[0] || "";
      state.selectedJobKeyWorkplace = "ALL";
      state.selectedJobKeyDistrict = "ALL";

      el.detailSection.style.display = "";
      el.summarySection.style.display = "";
      el.suspectSection.style.display = "";

      renderAllCurrent();

      doneProgress("집계 완료 ✅");
    } catch (err) {
      console.error(err);
      log("에러: " + (err?.message || err));
      setProgress(0, "에러로 중단됨: " + (err?.message || err));
    } finally {
      const ok = !!window.XLSX;
      setLibWarning(ok);
      if (ok) el.btnAnalyze.disabled = false;
    }
  }

  // ---------------------------
  // Events: table header sorting
  // ---------------------------
  function bindSortableHeaders() {
    const summaryTable = document.getElementById("summaryTable");
    const suspectTable = document.getElementById("suspectTable");
    const jobTable = document.getElementById("jobTable");

    summaryTable.querySelectorAll("thead th.sortable").forEach(th => {
      th.addEventListener("click", () => {
        toggleSort(getSortSummaryByUnit(getUnit()), th.dataset.sort);
        renderSummary();
      });
    });

    suspectTable.querySelectorAll("thead th.sortable").forEach(th => {
      th.addEventListener("click", () => {
        toggleSort(getSortSuspectByUnit(getUnit()), th.dataset.sort);
        renderSuspect();
      });
    });

    jobTable.querySelectorAll("thead th.sortable").forEach(th => {
      th.addEventListener("click", () => {
        toggleSort(getSortJobsByUnit(getUnit()), th.dataset.sort);
        renderWorkplaceDetail();
      });
    });
  }

  // ---------------------------
  // Init / Events
  // ---------------------------
  function wire() {
    // file input
    el.fileInput.addEventListener("change", () => {
      const files = el.fileInput.files ? Array.from(el.fileInput.files) : [];
      setFiles(files);
      log(`파일 선택: ${files.length}개`);
    });

    // dropzone click -> open picker
    el.dropZone.addEventListener("click", () => el.fileInput.click());
    el.dropZone.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        el.fileInput.click();
      }
    });

    // drag & drop
    ["dragenter","dragover"].forEach(evt => {
      el.dropZone.addEventListener(evt, (e) => {
        e.preventDefault();
        e.stopPropagation();
        el.dropZone.classList.add("dragover");
      });
    });
    ["dragleave","drop"].forEach(evt => {
      el.dropZone.addEventListener(evt, (e) => {
        e.preventDefault();
        e.stopPropagation();
        el.dropZone.classList.remove("dragover");
      });
    });
    el.dropZone.addEventListener("drop", (e) => {
      const dt = e.dataTransfer;
      const files = dt && dt.files ? Array.from(dt.files) : [];
      const filtered = files.filter(f => /\.(xlsx|xls)$/i.test(f.name));
      setFiles(filtered);
      log(`드롭 업로드: ${filtered.length}개`);
    });

    // 보기 단위 변경
    el.viewUnitSelect.addEventListener("change", () => {
      state.viewUnit = normUnit(el.viewUnitSelect.value);
      syncUnitUI();
      if (state.analyzed) {
        // 선택값이 비어 있으면 첫 항목으로
        const unit = getUnit();
        const order = getOrderByUnit(unit);
        if (!getSelectedKeyByUnit(unit) && order.length) setSelectedKeyByUnit(unit, order[0]);
        renderAllCurrent();
      }
    });

    // analyze
    el.btnAnalyze.addEventListener("click", () => {
      analyzeAllFiles().catch(err => {
        console.error(err);
        log("에러: " + (err?.message || err));
      });
    });

    // clear
    el.btnClear.addEventListener("click", () => {
      setFiles([]);
      state.analyzed = false;
      state.moves = [];

      state.workplaces.clear();
      state.workplaceOrder = [];
      state.districts.clear();
      state.districtOrder = [];

      state.selectedWorkplaceKey = "";
      state.selectedDistrictKey = "";
      state.selectedJobKeyWorkplace = "ALL";
      state.selectedJobKeyDistrict = "ALL";

      state.stats = null;
      resetDedupe();

      state.summarySelectedWorkplace.clear();
      state.summaryLastWorkplaceKeys = [];
      state.summarySelectedDistrict.clear();
      state.summaryLastDistrictKeys = [];

      el.analyzeBanner.style.display = "none";
      hideProgress();

      el.detailSection.style.display = "none";
      el.summarySection.style.display = "none";
      el.suspectSection.style.display = "none";

      el.workplaceSearch.value = "";
      el.summarySearch.value = "";
      el.suspectSearch.value = "";

      if (el.summaryCheckAll) {
        el.summaryCheckAll.checked = false;
        el.summaryCheckAll.indeterminate = false;
      }

      clearLog();
      log("초기화 완료");
    });

    // name mask sync (advanced <-> quick)
    const syncMask = (checked) => {
      state.maskNames = !!checked;
      el.optMaskNames.checked = state.maskNames;
      el.optMaskNamesQuick.checked = state.maskNames;

      if (state.analyzed) {
        renderAnalyzeBanner();
        renderWorkplaceDetail();
      }
    };
    el.optMaskNames.addEventListener("change", () => syncMask(el.optMaskNames.checked));
    el.optMaskNamesQuick.addEventListener("change", () => syncMask(el.optMaskNamesQuick.checked));

    // filters (debounced)
    el.workplaceSearch.addEventListener("input", debounce(() => {
      if (!state.analyzed) return;
      renderWorkplaceSelect();
    }, 140));

    el.workplaceSelect.addEventListener("change", () => {
      if (!state.analyzed) return;
      const unit = getUnit();
      setSelectedKeyByUnit(unit, el.workplaceSelect.value);
      setSelectedJobKeyByUnit(unit, "ALL");
      renderJobSelect();
      renderWorkplaceDetail();
    });

    el.jobSelect.addEventListener("change", () => {
      if (!state.analyzed) return;
      const unit = getUnit();
      setSelectedJobKeyByUnit(unit, el.jobSelect.value);
      renderListsForSelectedJob();

      const trs = [...el.jobTableBody.querySelectorAll("tr")];
      trs.forEach(t => t.classList.remove("is-selected"));
      const hit = trs.find(t => t.dataset.jobKey === getSelectedJobKeyByUnit(unit));
      if (hit) hit.classList.add("is-selected");
    });

    el.summarySearch.addEventListener("input", debounce(() => {
      if (!state.analyzed) return;
      renderSummary();
    }, 150));

    el.summaryFilter.addEventListener("change", () => {
      if (!state.analyzed) return;
      renderSummary();
    });

    el.suspectSearch.addEventListener("input", debounce(() => {
      if (!state.analyzed) return;
      renderSuspect();
    }, 150));

    el.suspectType.addEventListener("change", () => {
      if (!state.analyzed) return;
      renderSuspect();
    });

    // summary check all
    el.summaryCheckAll.addEventListener("click", (e) => e.stopPropagation());
    el.summaryCheckAll.addEventListener("change", () => {
      if (!state.analyzed) return;
      const unit = getUnit();
      const keys = getSummaryLastKeysByUnit(unit).slice();
      const set = getSummarySelectedByUnit(unit);
      if (el.summaryCheckAll.checked) keys.forEach(k => set.add(k));
      else keys.forEach(k => set.delete(k));
      renderSummary();
    });

    // downloads
    el.btnDownloadSummary.addEventListener("click", downloadSummaryCsv);
    el.btnDownloadSuspect.addEventListener("click", downloadSuspectCsv);
    el.btnDownloadDetail.addEventListener("click", downloadDetailCsv);

    // xlsx exports
    el.btnDownloadXlsxAll.addEventListener("click", downloadXlsxAll);
    el.btnDownloadXlsxSelected.addEventListener("click", downloadXlsxSelected);
    el.btnDownloadXlsxBothSummary.addEventListener("click", downloadXlsxBothSummary);
    el.btnClearSelected.addEventListener("click", clearSelectedItems);

    // tooltip hide
    window.addEventListener("scroll", hideTooltip, { passive:true });
    window.addEventListener("resize", hideTooltip, { passive:true });
    window.addEventListener("click", () => {
      if (el.tooltip.style.display === "block") hideTooltip();
    });

    bindSortableHeaders();
  }

  async function init() {
    log("페이지 로드 완료");
    log("엑셀을 업로드한 뒤 '발령 정보 집계하기'를 누르세요.");
    setFiles([]);
    hideProgress();

    state.viewUnit = normUnit(el.viewUnitSelect?.value || "workplace");
    syncUnitUI();

    const ok = await ensureXLSX();
    setLibWarning(ok);
  }

  document.addEventListener("DOMContentLoaded", () => {
    wire();
    init();
  });
})();
</script>

<script src="/static/disable-copy.js"></script>
<script src="/static/footer.js"></script>
<script src="/static/global-loader.js?v=1"></script>

</body>
</html>