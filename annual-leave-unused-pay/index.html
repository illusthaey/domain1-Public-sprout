<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>2025회계 연차 미사용 수당 계산기</title>

  <link rel="stylesheet" href="/static/style.css" />
  <script src="https://cdn.sheetjs.com/xlsx-0.20.3/package/dist/xlsx.full.min.js"></script>

  <style>
    .msg { border:1px solid #e5e5e5; border-radius:12px; padding:10px 12px; background:#fafafa; }
    .msg.ok { border-color:#b7eb8f; background:#f6ffed; }
    .msg.warn { border-color:#ffd666; background:#fffbe6; }
    .msg.err { border-color:#ffccc7; background:#fff2f0; }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; font-size:0.92rem; border:1px solid #ddd; background:#fff; }
    .pill.ok { border-color:#b7eb8f; }
    .pill.warn { border-color:#ffd666; }
    .pill.err { border-color:#ffccc7; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size:0.95rem; background:#f3f4f6; border:1px solid #e5e7eb; padding:1px 6px; border-radius:6px; }

    details > summary { cursor:pointer; font-weight:700; color:#111; }
    details > summary:hover { text-decoration: underline; }
    .hidden { display:none !important; }

    .table-compact th, .table-compact td { padding: 6px 8px; }
    .right { text-align:right; }
    .center { text-align:center; }
    .nowrap { white-space: nowrap; }

    .stack { display:flex; flex-direction:column; gap:10px; }
    .mini { font-size:0.95rem; color:#555; }

    .danger-line { border-left: 4px solid #ff4d4f; padding-left: 10px; }
    .warn-line { border-left: 4px solid #faad14; padding-left: 10px; }

    table input[type="number"] { min-width: 90px; }
    table input[type="text"] { min-width: 120px; }
    table select { min-width: 140px; }

    .site-header .shell,
    .site-header h1,
    .site-header .subtitle { text-align:left !important; }

    /* Drag & Drop */
    .dropzone {
      border: 2px dashed #d4d4d8;
      border-radius: 14px;
      padding: 14px 16px;
      background: #fafafa;
      cursor: pointer;
      transition: all 0.15s ease;
    }
    .dropzone:hover { background:#f3f4f6; }
    .dropzone.dragover {
      border-color: #111;
      background: #eef2ff;
    }
    .dz-title { font-weight: 700; color:#111; margin:0 0 4px; }
    .dz-desc { margin:0; color:#555; font-size:0.95rem; }

    .help { font-size: 0.95rem; color:#555; }
  </style>
</head>

<body>
  <header class="site-header">
    <div class="shell">
      <h1>2025회계 교육공무직 연차 미사용 수당 계산기</h1>
      <p class="subtitle">
        ·2024회계 근무 실적을 바탕으로 2025회계 사용 연차를 부여합니다. (부여 기준일자: <b>2025-03-01</b>)<br/>
        ·2025회계에 부여된 연차 중 미사용분에 대해 수당을 산정합니다. (지급 기준일자: <b>2026-03-01</b>)<br/>
        ·연차 사용 집계 기간: <b>2025-03-01 ~ 2026-02-28</b><br/>
        ※ 업로드한 파일은 저장되지 않습니다. 서버/DB 없습니다.
      </p>
    </div>
  </header>

  <main class="container">

    <section class="section">
      <h2>0. 계산 기준 요약</h2>
      <div class="grid two">
        <div class="msg">
          <div><b>연차 사용 집계(2025회계)</b></div>
          <ul>
            <li>집계 대상 유형: <b>지각 · 조퇴 · 외출 · 반일연차 · 연차</b></li>
            <li><b>병가/병지각/병조퇴</b> 등은 연차로 집계하지 않습니다.</li>
          </ul>
        </div>
        <div class="msg">
          <div><b>미사용 수당 산정</b></div>
          <ul>
            <li>미사용분 = 부여연차(입력) − 사용연차(자동 집계)</li>
            <li>수당 = 미사용(분) × (시간당 통상임금 ÷ 60)</li>
            <li>금액은 <b>10원 단위 절삭</b> (예: 1111원 → 1110원)</li>
          </ul>
        </div>
      </div>
      <div class="msg warn" style="margin-top:10px;">
        <div><b>주의</b></div>
        <div class="help">
          통상임금(기본급/수당/상여 포함 여부)은 지역·시기·공문에 따라 바뀔 수 있습니다.
          아래 <span class="kbd">통상임금 옵션</span>에서 <b>정기상여금(1/12)</b> 포함 여부를 선택할 수 있도록 해두었습니다.
        </div>
      </div>
    </section>

    <section class="section">
      <h2>1. 인사기록카드(나이스 원자료) 업로드</h2>
      <p class="muted">·인사기록카드(조회내역) 엑셀 원본을 그대로 업로드하세요. (드래그&드롭 지원)</p>

      <div class="card">
        <div class="grid two">
          <div>
            <div class="dropzone" id="hrDrop">
              <p class="dz-title">인사기록카드 엑셀 드롭</p>
              <p class="dz-desc">여기에 파일을 끌어다 놓거나 클릭해서 선택하세요. (1개)</p>
            </div>
            <input type="file" id="hrFile" accept=".xlsx,.xls" class="hidden" />

            <div class="row gap" style="margin-top:10px;">
              <button class="btn primary" id="btnLoadHr">인사정보 추출</button>
              <button class="btn" id="btnClearAll">전체 초기화</button>
            </div>
            <div id="hrMsg" class="msg" style="margin-top:12px;"></div>
          </div>

          <div class="msg">
            <div><b>입력 필요</b></div>
            <ul>
              <li>각 근로자별 <b>2025회계 부여 연차일수</b>를 표에서 직접 입력하세요.</li>
              <li>통상임금 자동 계산이 애매한 직종/케이스는 <b>시간당 통상임금(수기)</b> 칸에 직접 입력하면 그 값을 우선 사용합니다.</li>
            </ul>
          </div>
        </div>

        <div class="table-wrap">
          <table class="sheetlike table-compact" id="workersTable">
            <thead>
              <tr>
                <th class="nowrap">나이스 개인번호</th>
                <th class="nowrap">성명</th>
                <th class="nowrap">직종</th>
                <th class="nowrap">최초임용일</th>
                <th class="nowrap right">1일시간</th>
                <th class="nowrap right">주시간</th>
                <th class="nowrap right">근속(지급기준일)</th>
                <th class="nowrap right">부여연차(일)</th>
                <th class="nowrap right">기타수당(월)</th>
                <th class="nowrap right">시간당통상임금(수기)</th>
                <th class="nowrap center">삭제</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>

        <div class="msg" style="margin-top:10px;">
          <div><b>지급 기준일자</b>: 2026-03-01 (고정)</div>
          <div class="muted">※ 근속연수/근속수당 등 통상임금 계산에 사용됩니다.</div>
        </div>
      </div>
    </section>

    <section class="section">
      <h2>2. 근무사항(나이스 근무상황) 업로드</h2>
      <p class="muted">·나이스에서 개인별 근무상황(복무) 조회내역 엑셀/CSV 원본을 그대로 업로드하세요. (여러 개 가능, 드래그&드롭 지원)</p>

      <div class="card">
        <div class="grid two">
          <div>
            <div class="dropzone" id="workDrop">
              <p class="dz-title">근무상황 엑셀/CSV 드롭</p>
              <p class="dz-desc">여러 파일을 한 번에 끌어다 놓을 수 있습니다.</p>
            </div>
            <input type="file" id="workFiles" accept=".xlsx,.xls,.csv" multiple class="hidden" />

            <div class="row gap" style="margin-top:10px;">
              <button class="btn primary" id="btnLoadWork">연차 사용 집계</button>
              <button class="btn" id="btnClearWork">근무사항만 초기화</button>
            </div>
            <div id="workMsg" class="msg" style="margin-top:12px;"></div>
          </div>

          <div class="msg warn">
            <div><b>집계 규칙</b></div>
            <ul>
              <li>집계 대상: <b>지각, 조퇴, 외출, 반일연차, 연차</b></li>
              <li><b>병</b>이 붙은 근태(병가/병지각/병조퇴/병외출 등)는 제외</li>
              <li>시간 정보가 비어있는 항목은 <b>검토 필요</b>로 따로 표시합니다.</li>
            </ul>
          </div>
        </div>

        <details id="reviewBox" class="card hidden" style="margin-top:12px;">
          <summary>검토 필요(시간/분 판독 실패) 목록</summary>
          <div class="muted" style="margin-top:8px;">·아래 항목은 시간(분)을 자동으로 해석하지 못했습니다. 필요한 경우 수기로 분(또는 시간/일)을 입력하고 <b>반영</b>을 눌러주세요.</div>
          <div class="table-wrap">
            <table class="sheetlike table-compact" id="reviewTable">
              <thead>
                <tr>
                  <th class="nowrap">성명</th>
                  <th class="nowrap">개인번호</th>
                  <th class="nowrap">유형</th>
                  <th class="nowrap">기간</th>
                  <th class="nowrap">원본값(시간/일수)</th>
                  <th class="nowrap right">수기입력(분)</th>
                  <th class="nowrap center">반영</th>
                  <th class="nowrap">파일</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </details>
      </div>
    </section>

    <section class="section">
      <h2>3. 통상임금 옵션</h2>

      <div class="card">
        <div class="row gap">
          <label class="row"><input type="checkbox" id="optIncludeBonus" /> 정기상여금(월 환산 1/12) 통상임금에 포함</label>
        </div>

        <div class="row gap" style="margin-top:8px;">
          <label class="row"><input type="checkbox" id="optIncludeHoliday" /> 명절휴가비(월 환산 1/12) 통상임금에 포함 <span class="muted">(선택)</span></label>
        </div>

        <div class="msg" style="margin-top:10px;">
          <div><b>기본값(2025 보수표 기반)</b></div>
          <ul>
            <li>기본급(40h): 1유형 2,266,000원 / 2유형 2,066,000원</li>
            <li>정액급식비: 150,000원</li>
            <li>근속수당: 1년당 40,000원 (상한 23년)</li>
            <li>정기상여금(연): 기본 1,000,000원 / 특수운영1유형 500,000원</li>
            <li>명절휴가비(연): 1,850,000원</li>
          </ul>
          <div class="muted">※ 보수표가 바뀌면 아래 고급설정에서 숫자만 바꿔주면 됩니다.</div>
        </div>

        <details style="margin-top:10px;">
          <summary>고급설정(보수표/수당 상수 수정)</summary>
          <div class="grid three" style="margin-top:10px;">
            <label class="stack">
              <span class="mini">1유형 기본급(40h)</span>
              <input type="number" id="cType1" class="numeric" />
            </label>
            <label class="stack">
              <span class="mini">2유형 기본급(40h)</span>
              <input type="number" id="cType2" class="numeric" />
            </label>
            <label class="stack">
              <span class="mini">1유형 미만 기본급(40h)</span>
              <input type="number" id="cType1Under" class="numeric" />
            </label>

            <label class="stack">
              <span class="mini">교육복지사(기관) 기본급</span>
              <input type="number" id="cWelfareInst" class="numeric" />
            </label>
            <label class="stack">
              <span class="mini">임상심리사/대안교육전문가 기본급</span>
              <input type="number" id="cClinical" class="numeric" />
            </label>
            <label class="stack">
              <span class="mini">학습클리닉/학부모지원 기본급</span>
              <input type="number" id="cClinic" class="numeric" />
            </label>

            <label class="stack">
              <span class="mini">진학전문지원관 기본급</span>
              <input type="number" id="cJinhak" class="numeric" />
            </label>
            <label class="stack">
              <span class="mini">학교운동부지도자 기본급</span>
              <input type="number" id="cSports" class="numeric" />
            </label>
            <label class="stack">
              <span class="mini">정액급식비(월)</span>
              <input type="number" id="cMeal" class="numeric" />
            </label>

            <label class="stack">
              <span class="mini">근속수당(1년당)</span>
              <input type="number" id="cServiceStep" class="numeric" />
            </label>
            <label class="stack">
              <span class="mini">근속수당 상한(년)</span>
              <input type="number" id="cServiceCap" class="numeric" />
            </label>
            <label class="stack">
              <span class="mini">정기상여금(연, 기본)</span>
              <input type="number" id="cBonusDefault" class="numeric" />
            </label>

            <label class="stack">
              <span class="mini">정기상여금(연, 특수운영 1유형)</span>
              <input type="number" id="cBonusSpecial1" class="numeric" />
            </label>
            <label class="stack">
              <span class="mini">명절휴가비(연)</span>
              <input type="number" id="cHoliday" class="numeric" />
            </label>
            <label class="stack">
              <span class="mini">특수운영 시급(주15시간 미만용)</span>
              <input type="number" id="cSpecialHourly" class="numeric" />
            </label>
          </div>

          <div class="row gap" style="margin-top:10px;">
            <button class="btn" id="btnResetConstants">기본값으로 되돌리기</button>
            <button class="btn primary" id="btnApplyConstants">고급설정 반영</button>
          </div>

          <div id="constMsg" class="msg" style="margin-top:10px;"></div>
        </details>
      </div>
    </section>

    <section class="section">
      <h2>4. 계산 실행 & 결과</h2>

      <div class="card">
        <div class="row gap">
          <button class="btn primary" id="btnRun">미사용 수당 계산</button>
          <button class="btn" id="btnDownload">결과 엑셀 다운로드</button>
        </div>
        <div id="runMsg" class="msg" style="margin-top:12px;"></div>
      </div>

      <div id="resultSummary" class="msg">아직 계산하지 않았습니다.</div>

      <div class="table-wrap">
        <table class="sheetlike table-compact" id="resultTable">
          <thead>
            <tr>
              <th class="nowrap">나이스 개인번호</th>
              <th class="nowrap">성명</th>
              <th class="nowrap">직종</th>
              <th class="nowrap right">부여(일)</th>
              <th class="nowrap right">사용(일/시/분)</th>
              <th class="nowrap right">미사용(일/시/분)</th>
              <th class="nowrap right">시간당 통상임금</th>
              <th class="nowrap right">미사용 수당(절삭)</th>
              <th class="nowrap">비고</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>

      <details class="card" style="margin-top:12px;">
        <summary>개인별 상세(연차 사용 내역 합계)</summary>
        <div id="detailBox" class="stack" style="margin-top:10px;"></div>
      </details>
    </section>

  </main>

  <div class="home-link-wrap">
    <a class="btn" href="/">메인으로 돌아가기</a>
  </div>

<script>
(() => {
  "use strict";

  // =============================
  // 기간(고정): 2025회계(학년도 기준)
  // =============================
  const PERIOD_START = ymdToUTC("2025-03-01");
  const PERIOD_END   = ymdToUTC("2026-02-28"); // inclusive
  const GRANT_DATE   = ymdToUTC("2025-03-01");
  const PAY_DATE     = ymdToUTC("2026-03-01");

  const DEFAULT_DAILY_HOURS = 8;

  // =============================
  // 통상임금 계산용 기본 상수(2025 보수표 기반)
  // =============================
  const DEFAULT_CONST = {
    basePay40: {
      type1: 2266000,
      type2: 2066000,
      type1Under: 2167610,
      // type1Over는 직종별로 다름
      welfareInst: 2667280,
      clinical: 2725350,
      clinic: 2569280,
      jinhak: 3566500,
      sports: 2287390,
    },
    mealAllowance: 150000,
    serviceStep: 40000,
    serviceCapYears: 23,
    annualBonusDefault: 1000000,
    annualBonusSpecial1: 500000,
    annualHoliday: 1850000,
    specialHourly: 11200,
    // 직무관련수당(대표적인 것만)
    hazardAllowance: 50000,      // 조리사/조리실무사
    mealOpsAllowance: 50000,     // 영양사 급식운영수당
    techInfoAllowance: 20000,    // 영양사 기술정보수당(면허가산 미수령 시)
    specialDutyLibrarian: 20000, // 학교도서관사서(면허)
    specialDutyWelfare: 20000,   // 교육복지사(학교)
    specialDutyOld: 50000,       // 구육성회직원
  };

  // =============================
  // 직종 분류(기본급 유형 판별)
  // =============================
  const JOB_KEYWORDS = {
    type1: [
      "치료사","장애영아지도사","장애유아지도사","직업지도사","유치원방과후교육사",
      "학교도서관사서","기숙사생활지도원","전문상담사","영양사","평생교육사","사회복지사","진로교육사",
      // 교육복지사는 (학교) / (기관) 구분 필요
      "교육복지사"
    ],
    type2: [
      "학교도서관실무사","특수교육지도사","건강실무사","조리실무사","조리사",
      "초등돌봄전담사","방과후전담사","교무행정사","발명실무원",
      "통학차량운전원","통학지도원","늘봄학교전담사"
    ],
    type1Under: ["교육지도사","방과후학교지원가"],
    type1Over: [
      "임상심리사","대안교육전문가","교육복지사(기관)","학습클리닉전문가","학부모지원전문가",
      "진학전문지원관","학교운동부지도자"
    ],
    special1: ["학교보안관","청소원","당직전담원","출입문개폐전담원","열람실관리원"],
    special2: ["객실청소원","청사안내원","시설관리원","콜센터상담원"],
  };

  const state = {
    workers: new Map(),
    leaveRecords: [],
    reviewRecords: [],
    lastRunAt: null,
    options: {
      includeBonus: false,
      includeHoliday: false,
    },
    constants: structuredClone(DEFAULT_CONST),
  };

  const $ = (sel) => document.querySelector(sel);
  const $$ = (sel) => Array.from(document.querySelectorAll(sel));

  function setMsg(el, cls, html) {
    el.className = `msg ${cls || ""}`.trim();
    el.innerHTML = html;
  }

  function escapeHtml(s) {
    return String(s ?? "")
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  function ymdToUTC(ymd) {
    const [y, m, d] = ymd.split("-").map(Number);
    return new Date(Date.UTC(y, m - 1, d));
  }

  function utcToYmd(date) {
    const y = date.getUTCFullYear();
    const m = String(date.getUTCMonth() + 1).padStart(2, "0");
    const d = String(date.getUTCDate()).padStart(2, "0");
    return `${y}-${m}-${d}`;
  }

  function addDaysUTC(date, days) {
    return new Date(date.getTime() + days * 86400000);
  }

  function isWeekendUTC(date) {
    const wd = date.getUTCDay();
    return wd === 0 || wd === 6; // 일/토
  }

  function clampToPeriod(date) {
    if (date < PERIOD_START) return PERIOD_START;
    if (date > PERIOD_END) return PERIOD_END;
    return date;
  }

  function normalizeRange(start, end) {
    if (!start || !end) return null;
    if (end < start) [start, end] = [end, start];

    // 기간 겹치는 부분만
    const s = clampToPeriod(start);
    const e = clampToPeriod(end);
    if (e < PERIOD_START || s > PERIOD_END) return null;
    return { start: s, end: e };
  }

  function computeServiceYearsAt(baseUTC, hireUTC) {
    if (!baseUTC || !hireUTC) return 0;
    const y = baseUTC.getUTCFullYear() - hireUTC.getUTCFullYear();
    const m = baseUTC.getUTCMonth() - hireUTC.getUTCMonth();
    const d = baseUTC.getUTCDate() - hireUTC.getUTCDate();
    let years = y;
    if (m < 0 || (m === 0 && d < 0)) years -= 1;
    return Math.max(0, years);
  }

  function formatMoney(n) {
    const v = Number(n || 0);
    return v.toLocaleString("ko-KR");
  }

  function safeNum(v, fallback = 0) {
    const n = Number(String(v ?? "").replace(/[^0-9.\-]/g, ""));
    return Number.isFinite(n) ? n : fallback;
  }

  function workerKeyOf(name, pid) {
    const p = String(pid || "").trim();
    if (p) return p;
    return String(name || "").trim();
  }

  function ensureXLSX() {
    if (typeof XLSX === "undefined") {
      throw new Error("XLSX 라이브러리를 찾을 수 없습니다. (CDN 차단 여부 확인 필요)");
    }
  }

  function readFileAsArrayBuffer(file) {
    return new Promise((resolve, reject) => {
      const fr = new FileReader();
      fr.onload = () => resolve(fr.result);
      fr.onerror = () => reject(new Error("파일 읽기 실패"));
      fr.readAsArrayBuffer(file);
    });
  }

  function sheetToJson(workbook) {
    const sheetName = workbook.SheetNames[0];
    const ws = workbook.Sheets[sheetName];
    return XLSX.utils.sheet_to_json(ws, { header: 1, raw: false, defval: "" });
  }

  function normalizeHeader(s) {
    return String(s || "").replace(/\s+/g, "").replace(/[()]/g, "").toLowerCase();
  }

  function findHeaderRow(rows, mustHaveAny) {
    let bestIdx = -1;
    let bestScore = -1;

    for (let i = 0; i < Math.min(rows.length, 30); i++) {
      const row = rows[i];
      if (!Array.isArray(row)) continue;

      const nh = row.map(normalizeHeader);
      const joined = nh.join("|");
      const hit = mustHaveAny.some(k => joined.includes(normalizeHeader(k)));
      if (!hit) continue;

      const score = nh.filter(x => x && x.length >= 2).length;
      if (score > bestScore) {
        bestScore = score;
        bestIdx = i;
      }
    }
    return bestIdx;
  }

  function findColumnIndex(headers, candidates) {
    const nh = headers.map(normalizeHeader);

    for (const c of candidates) {
      const nc = normalizeHeader(c);
      const idx = nh.findIndex(h => h === nc);
      if (idx >= 0) return idx;
    }

    for (const c of candidates) {
      const nc = normalizeHeader(c);
      const idx = nh.findIndex(h => h.includes(nc) || nc.includes(h));
      if (idx >= 0) return idx;
    }

    return -1;
  }

  function parseDateLoose(v) {
    const s = String(v || "").trim();
    if (!s) return null;

    // 2025.3.1 / 2025-03-01 / 2025/03/01
    const m = s.match(/(\d{4})[.\-/](\d{1,2})[.\-/](\d{1,2})/);
    if (m) {
      const y = Number(m[1]);
      const mo = Number(m[2]);
      const d = Number(m[3]);
      return new Date(Date.UTC(y, mo - 1, d));
    }

    // 엑셀 날짜가 문자열로 들어오는 경우 외는 일단 포기
    return null;
  }

  function parseRangeLoose(s) {
    const str = String(s||"").trim();
    if (!str) return null;
    const parts = str.split(/~|〜/).map(x => x.trim()).filter(Boolean);
    if (parts.length === 2) {
      const a = parseDateLoose(parts[0]);
      const b = parseDateLoose(parts[1]);
      if (a && b) return { start: a, end: b };
    }
    const d = parseDateLoose(str);
    if (d) return { start: d, end: d };
    return null;
  }

  function normalizeText(s) {
    return String(s || "").replace(/\s+/g, "").trim();
  }

  function classifyLeaveType(typeRaw) {
    const t = normalizeText(typeRaw);
    if (!t) return null;

    // 병가/병지각/병조퇴/병외출 등 배제
    if (/(병가|병지각|병조퇴|병외출|유급병가|무급병가|질병)/.test(t) || t.startsWith("병")) {
      return null;
    }

    if (t.includes("반일연차")) return "HALF";
    if (t.includes("연차")) return "FULL";
    if (t.includes("지각")) return "LATE";
    if (t.includes("조퇴")) return "EARLY";
    if (t.includes("외출")) return "OUT";

    return null;
  }

  function parseTimeToMinutes(str) {
    const s = String(str||"").trim();
    const m = s.match(/(\d{1,2}):(\d{2})/);
    if (!m) return null;
    const hh = Number(m[1]);
    const mm = Number(m[2]);
    if (!Number.isFinite(hh) || !Number.isFinite(mm)) return null;
    return hh * 60 + mm;
  }

  function parseDurationToMinutes(cell, dailyMinutes) {
    const s = String(cell || "").trim();
    if (!s) return null;

    // 0.5일, 1일, 2.0일 등
    let days = null;
    const md = s.match(/(-?\d+(?:\.\d+)?)\s*일/);
    if (md) days = Number(md[1]);

    let hours = null;
    const mh = s.match(/(-?\d+(?:\.\d+)?)\s*시간/);
    if (mh) hours = Number(mh[1]);

    let mins = null;
    const mm = s.match(/(-?\d+(?:\.\d+)?)\s*분/);
    if (mm) mins = Number(mm[1]);

    if (md || mh || mm) {
      let total = 0;
      if (days != null && Number.isFinite(days)) total += days * dailyMinutes;
      if (hours != null && Number.isFinite(hours)) total += hours * 60;
      if (mins != null && Number.isFinite(mins)) total += mins;
      return Math.round(total);
    }

    // 단순 숫자만 있으면 null (컬럼 맥락에 따라 해석)
    return null;
  }

  function countWorkdaysInRange(startUTC, endUTC) {
    let count = 0;
    for (let d = startUTC; d <= endUTC; d = addDaysUTC(d, 1)) {
      if (isWeekendUTC(d)) continue;
      count += 1;
    }
    return count;
  }

  function computeMonthlyHours(weeklyHours, dailyHours) {
    const wh = Number(weeklyHours || 0);
    const dh = Number(dailyHours || 0);
    if (!(wh > 0) || !(dh > 0)) return 209;
    const weeklyTotal = wh + dh; // 주휴일 1일분
    const approx = (weeklyTotal / 7) * (365 / 12);
    return Math.round(approx);
  }

  // =============================
  // 인사정보 로딩
  // =============================
  async function loadHrFile(file) {
    ensureXLSX();
    const buf = await readFileAsArrayBuffer(file);
    const wb = XLSX.read(buf, { type: "array" });
    const rows = sheetToJson(wb);

    const headerIdx = findHeaderRow(rows, ["성명", "직종", "최초임용일", "개인번호"]);
    if (headerIdx < 0) throw new Error("인사기록 파일에서 헤더 행을 찾지 못했습니다. (양식 확인 필요)");

    const headers = rows[headerIdx].map(x => String(x || "").trim());
    const dataRows = rows.slice(headerIdx + 1).filter(r => Array.isArray(r) && r.some(x => String(x||"").trim() !== ""));

    const colName = findColumnIndex(headers, ["성명","이름"]);
    const colPid  = findColumnIndex(headers, ["나이스개인번호","개인번호","사번","인적번호","개인번호(아이디)"]);
    const colHire = findColumnIndex(headers, ["최초임용일","근무시작일","임용일","최초계약일","계약시작일"]);
    const colJob  = findColumnIndex(headers, ["직종","직종명","직무","직무명"]);
    const colDailyH = findColumnIndex(headers, ["1일근로시간","일근로시간","1일소정근로시간"]);
    const colWeeklyH = findColumnIndex(headers, ["주소정근로시간","주당근로시간","주근무시간","주소정근로시간(시간)"]);

    if (colName < 0) throw new Error("인사기록 파일에서 [성명] 컬럼을 찾지 못했습니다.");

    let loaded = 0;
    let skipped = 0;

    for (const row of dataRows) {
      const name = String(row[colName] || "").trim();
      if (!name) { skipped++; continue; }

      const pid = (colPid >= 0) ? String(row[colPid] || "").trim() : "";
      const key = workerKeyOf(name, pid);

      const hire = (colHire >= 0) ? parseDateLoose(row[colHire]) : null;
      const job = (colJob >= 0) ? String(row[colJob] || "").trim() : "";

      let weeklyHours = null;
      if (colWeeklyH >= 0) {
        const v = safeNum(row[colWeeklyH], NaN);
        if (Number.isFinite(v) && v > 0) weeklyHours = v;
      }

      let dailyHours = DEFAULT_DAILY_HOURS;
      if (colDailyH >= 0) {
        const v = safeNum(row[colDailyH], NaN);
        if (Number.isFinite(v) && v > 0) dailyHours = v;
      } else if (weeklyHours != null) {
        dailyHours = Math.round((weeklyHours / 5) * 10) / 10;
      }

      if (weeklyHours == null) {
        weeklyHours = Math.round((dailyHours * 5) * 10) / 10;
      }

      const prev = state.workers.get(key);
      const merged = prev ? { ...prev } : {
        key,
        pid,
        name,
        job,
        hireDateUTC: hire,
        dailyHours,
        weeklyHours,
        grantedDays: null,
        customMonthlyAllowance: 0,
        hourlyOverride: null,
        flags: {},
      };

      merged.pid = pid || merged.pid;
      merged.name = name || merged.name;
      merged.job = job || merged.job;
      merged.hireDateUTC = hire || merged.hireDateUTC;
      merged.dailyHours = dailyHours || merged.dailyHours;
      merged.weeklyHours = weeklyHours || merged.weeklyHours;

      // 영양사 기본: 면허가산수당 받는다고 가정
      if ((merged.job || "").includes("영양사")) {
        if (merged.flags.nutritionLicense == null) merged.flags.nutritionLicense = true;
      }

      state.workers.set(key, merged);
      loaded++;
    }

    renderWorkersTable();
    return { loaded, skipped, headers };
  }

  function renderWorkersTable() {
    const tbody = $("#workersTable tbody");
    tbody.innerHTML = "";

    const arr = Array.from(state.workers.values())
      .sort((a,b) => (a.name||"").localeCompare(b.name||"", "ko"));

    for (const w of arr) {
      const tr = document.createElement("tr");
      const serviceYears = computeServiceYearsAt(PAY_DATE, w.hireDateUTC);

      tr.innerHTML = `
        <td class="nowrap">${escapeHtml(w.key)}</td>
        <td class="nowrap">${escapeHtml(w.name||"")}</td>
        <td class="nowrap">${escapeHtml(w.job||"")}</td>
        <td class="nowrap">${w.hireDateUTC ? utcToYmd(w.hireDateUTC) : ""}</td>
        <td class="right nowrap">${escapeHtml(String(w.dailyHours ?? DEFAULT_DAILY_HOURS))}</td>
        <td class="right nowrap">${escapeHtml(String(w.weeklyHours ?? (Number(w.dailyHours||DEFAULT_DAILY_HOURS)*5)))}</td>
        <td class="right nowrap">${serviceYears}년</td>
        <td class="right nowrap">
          <input type="number" step="0.1" min="0" class="numeric" data-wk="${escapeHtml(w.key)}" data-field="grantedDays" value="${w.grantedDays ?? ""}" placeholder="예: 15" />
        </td>
        <td class="right nowrap">
          <input type="number" step="10" min="0" class="numeric" data-wk="${escapeHtml(w.key)}" data-field="customMonthlyAllowance" value="${Number(w.customMonthlyAllowance||0) ? String(w.customMonthlyAllowance) : ""}" placeholder="0" />
        </td>
        <td class="right nowrap">
          <input type="number" step="1" min="0" class="numeric" data-wk="${escapeHtml(w.key)}" data-field="hourlyOverride" value="${w.hourlyOverride ?? ""}" placeholder="자동" />
        </td>
        <td class="center nowrap"><button class="btn btn-lightgrey" data-del="${escapeHtml(w.key)}">삭제</button></td>
      `;

      tbody.appendChild(tr);
    }

    tbody.querySelectorAll("input[data-wk]").forEach(inp => {
      inp.addEventListener("change", () => {
        const key = inp.getAttribute("data-wk");
        const field = inp.getAttribute("data-field");
        const w = state.workers.get(key);
        if (!w) return;

        if (field === "grantedDays") {
          const v = inp.value.trim();
          w.grantedDays = v === "" ? null : safeNum(v, null);
        }
        if (field === "customMonthlyAllowance") {
          const v = inp.value.trim();
          w.customMonthlyAllowance = v === "" ? 0 : safeNum(v, 0);
        }
        if (field === "hourlyOverride") {
          const v = inp.value.trim();
          w.hourlyOverride = v === "" ? null : safeNum(v, null);
        }

        state.workers.set(key, w);
        // 결과가 있으면 즉시 재계산
        if (state.lastRunAt) runCalculation(false);
      });
    });

    tbody.querySelectorAll("button[data-del]").forEach(btn => {
      btn.addEventListener("click", () => {
        const key = btn.getAttribute("data-del");
        state.workers.delete(key);
        // 해당 인원의 근무기록도 제거
        state.leaveRecords = state.leaveRecords.filter(r => r.workerKey !== key);
        state.reviewRecords = state.reviewRecords.filter(r => r.workerKey !== key);
        renderWorkersTable();
        renderReviewRecords();
        if (state.lastRunAt) runCalculation(false);
      });
    });

    setMsg($("#hrMsg"), arr.length ? "ok" : "warn", `
      <div><b>대상자 수</b>: ${arr.length}명</div>
      <div class="muted">※ 인사정보를 먼저 불러오면 근무상황 매칭 정확도가 올라갑니다.</div>
    `);
  }

  // =============================
  // 근무상황 로딩(연차 사용 집계)
  // =============================
  async function loadWorkFiles(files) {
    ensureXLSX();
    if (!files || files.length === 0) throw new Error("근무상황 파일이 선택되지 않았습니다.");

    // 초기화 후 다시 집계
    state.leaveRecords = [];
    state.reviewRecords = [];

    let totalRows = 0;
    let usedRows = 0;
    let reviewRows = 0;
    let createdWorkers = 0;

    for (const file of files) {
      const ext = (file.name.split(".").pop() || "").toLowerCase();

      if (ext === "csv") {
        const text = await file.text();
        const rows = csvToRows(text);
        const out = parseWorkRows(rows, file.name);
        totalRows += out.totalRows;
        usedRows += out.usedRows;
        reviewRows += out.reviewRows;
        createdWorkers += out.createdWorkers;
        continue;
      }

      const buf = await readFileAsArrayBuffer(file);
      const wb = XLSX.read(buf, { type: "array" });
      const rows = sheetToJson(wb);
      const out = parseWorkRows(rows, file.name);
      totalRows += out.totalRows;
      usedRows += out.usedRows;
      reviewRows += out.reviewRows;
      createdWorkers += out.createdWorkers;
    }

    renderReviewRecords();

    setMsg($("#workMsg"), "ok", `
      <div><b>근무상황 집계 완료</b></div>
      <ul>
        <li>전체 행(대략): ${totalRows.toLocaleString("ko-KR")}행</li>
        <li>연차 사용으로 집계된 건수: ${usedRows.toLocaleString("ko-KR")}건</li>
        <li>검토 필요: ${reviewRows.toLocaleString("ko-KR")}건</li>
        <li>인사정보에 없어서 임시 생성: ${createdWorkers.toLocaleString("ko-KR")}명</li>
      </ul>
      <div class="muted">※ 임시 생성자는 직종/최초임용일이 비어있을 수 있으니 인사파일로 다시 불러오거나 수기로 채워주세요.</div>
    `);

    // 자동 재계산
    if (state.lastRunAt) runCalculation(false);
  }

  function csvToRows(text) {
    const lines = text.split(/\r?\n/).filter(x => x.trim() !== "");
    return lines.map(line => parseCsvLine(line));
  }

  function parseCsvLine(line) {
    const res = [];
    let cur = "";
    let inQ = false;

    for (let i = 0; i < line.length; i++) {
      const ch = line[i];
      if (ch === '"') {
        if (inQ && line[i+1] === '"') { cur += '"'; i++; continue; }
        inQ = !inQ; continue;
      }
      if (ch === "," && !inQ) { res.push(cur); cur = ""; continue; }
      cur += ch;
    }
    res.push(cur);
    return res;
  }

  function parseWorkRows(rows, filename) {
    const headerIdx = findHeaderRow(rows, ["성명", "종별", "근태", "기간", "일시"]);
    if (headerIdx < 0) throw new Error(`[${filename}] 헤더 행을 찾지 못했습니다.`);

    const headers = rows[headerIdx].map(x => String(x||"").trim());
    const dataRows = rows.slice(headerIdx + 1).filter(r => Array.isArray(r) && r.some(x => String(x||"").trim() !== ""));

    const colName = findColumnIndex(headers, ["성명","이름"]);
    const colPid  = findColumnIndex(headers, ["나이스개인번호","개인번호","사번","인적번호"]);
    const colType = findColumnIndex(headers, ["종별","복무종별","근무상황","근태종류","근태유형","복무구분"]);
    const colReason = findColumnIndex(headers, ["사유","상세사유","용무","비고"]);

    const colStart = findColumnIndex(headers, ["시작일","시작","from","시작일자"]);
    const colEnd   = findColumnIndex(headers, ["종료일","종료","to","종료일자"]);
    const colRange = findColumnIndex(headers, ["기간","일시","기간(일시)","기간(일자)","기간일시"]);

    const colDays = findColumnIndex(headers, ["일수","기간(일수)","사용일수","일수(사용)"]);
    const colHours = findColumnIndex(headers, ["시간","사용시간","근무시간","사용시간(시간)"]);
    const colMins = findColumnIndex(headers, ["분","사용분","사용시간(분)"]);
    const colTime = findColumnIndex(headers, ["시간(분)","사용시간(분)"]);

    const colStartTime = findColumnIndex(headers, ["시작시각","시작시간"]);
    const colEndTime   = findColumnIndex(headers, ["종료시각","종료시간"]);

    if (colName < 0) throw new Error(`[${filename}] 성명 열을 찾지 못했습니다.`);
    if (colType < 0) throw new Error(`[${filename}] 종별/근태 종류 열을 찾지 못했습니다.`);

    let totalRows = dataRows.length;
    let usedRows = 0;
    let reviewRows = 0;
    let createdWorkers = 0;

    for (const row of dataRows) {
      const nameRaw = String(row[colName] || "").trim();
      if (!nameRaw) continue;

      // "홍길동(K12345)" 같은 경우 대비
      let name = nameRaw;
      let pidFromName = "";
      const m = nameRaw.match(/\((K[0-9A-Za-z]+)\)/);
      if (m) pidFromName = m[1];
      name = nameRaw.replace(/\(.*?\)/g, "").trim();

      const pid = (colPid >= 0 ? String(row[colPid]||"").trim() : "") || pidFromName;
      const key = workerKeyOf(name, pid);

      if (!state.workers.has(key)) {
        // 인사정보 없으면 임시 생성
        state.workers.set(key, {
          key,
          pid,
          name,
          job: "",
          hireDateUTC: null,
          dailyHours: DEFAULT_DAILY_HOURS,
          weeklyHours: DEFAULT_DAILY_HOURS * 5,
          grantedDays: null,
          customMonthlyAllowance: 0,
          hourlyOverride: null,
          flags: {},
        });
        createdWorkers++;
      }

      const w = state.workers.get(key);
      const dailyMinutes = Math.round(Number(w.dailyHours || DEFAULT_DAILY_HOURS) * 60);

      const typeRaw = String(row[colType] || "").trim();
      const leaveKind = classifyLeaveType(typeRaw);
      if (!leaveKind) continue;

      // 날짜/기간 파싱
      let start = null, end = null;

      if (colRange >= 0) {
        const rangeStr = String(row[colRange] || "").trim();
        const parsed = parseRangeLoose(rangeStr);
        if (parsed) { start = parsed.start; end = parsed.end; }
      }

      if ((!start || !end) && colStart >= 0 && colEnd >= 0) {
        const s = parseDateLoose(row[colStart]);
        const e = parseDateLoose(row[colEnd]);
        if (s && e) { start = s; end = e; }
      }

      if (!start && colStart >= 0) start = parseDateLoose(row[colStart]);
      if (!end && colEnd >= 0) end = parseDateLoose(row[colEnd]);
      if (start && !end) end = start;
      if (end && !start) start = end;

      if (!start || !end) {
        // 날짜 없으면 집계 불가
        continue;
      }

      const overlap = normalizeRange(start, end);
      if (!overlap) continue;

      const reason = (colReason >= 0) ? String(row[colReason] || "").trim() : "";

      // 시간/일수 파싱
      let minutes = null;
      let rawDur = "";
      let method = "";

      // 1) 일수 컬럼 우선
      if (colDays >= 0) {
        const cell = row[colDays];
        rawDur = String(cell||"").trim();
        const d = safeNum(cell, NaN);
        if (Number.isFinite(d)) {
          minutes = Math.round(d * dailyMinutes);
          method = "일수";
        } else {
          const p = parseDurationToMinutes(cell, dailyMinutes);
          if (p != null) { minutes = p; method = "일수(문자)"; }
        }
      }

      // 2) 시간/분 컬럼
      if (minutes == null) {
        const h = (colHours >= 0) ? safeNum(row[colHours], NaN) : NaN;
        const m2 = (colMins >= 0) ? safeNum(row[colMins], NaN) : NaN;
        const tmin = (colTime >= 0) ? safeNum(row[colTime], NaN) : NaN;

        if (Number.isFinite(tmin)) {
          rawDur = String(row[colTime]||"");
          minutes = Math.round(tmin);
          method = "분";
        } else if (Number.isFinite(h) || Number.isFinite(m2)) {
          rawDur = `${Number.isFinite(h) ? h : 0}시간 ${Number.isFinite(m2) ? m2 : 0}분`;
          minutes = Math.round((Number.isFinite(h) ? h : 0) * 60 + (Number.isFinite(m2) ? m2 : 0));
          method = "시/분";
        }
      }

      // 3) 셀에 "1일 2시간" 같이 들어간 경우
      if (minutes == null && colHours >= 0) {
        const p = parseDurationToMinutes(row[colHours], dailyMinutes);
        if (p != null) {
          rawDur = String(row[colHours]||"");
          minutes = p;
          method = "문자(시간)";
        }
      }

      // 4) 시작/종료 시각이 있으면 차이 계산
      if (minutes == null && colStartTime >= 0 && colEndTime >= 0) {
        const st = parseTimeToMinutes(row[colStartTime]);
        const et = parseTimeToMinutes(row[colEndTime]);
        if (st != null && et != null) {
          rawDur = `${row[colStartTime]}~${row[colEndTime]}`;
          minutes = Math.max(0, et - st);
          method = "시각차";
        }
      }

      // 5) 기간(일시)에 시각이 들어있는 경우
      if (minutes == null && colRange >= 0) {
        const s = String(row[colRange]||"");
        const mt = s.match(/(\d{1,2}:\d{2})\s*(?:~|〜|-)\s*(\d{1,2}:\d{2})/);
        if (mt) {
          const st = parseTimeToMinutes(mt[1]);
          const et = parseTimeToMinutes(mt[2]);
          if (st != null && et != null) {
            rawDur = `${mt[1]}~${mt[2]}`;
            minutes = Math.max(0, et - st);
            method = "기간시각";
          }
        }
      }

      // 6) 그래도 없으면 유형에 따라 추정
      if (minutes == null) {
        const wd = countWorkdaysInRange(overlap.start, overlap.end);
        if (leaveKind === "FULL") {
          minutes = wd * dailyMinutes;
          method = "추정(연차)";
        } else if (leaveKind === "HALF") {
          minutes = Math.round(wd * dailyMinutes * 0.5);
          method = "추정(반일)";
        } else {
          // 지각/조퇴/외출인데 시간이 없으면 검토 필요
          minutes = 0;
          method = "검토필요";
        }
      }

      // sanity cap: 기간 내 최대치 초과 방지
      const maxMins = countWorkdaysInRange(overlap.start, overlap.end) * dailyMinutes;
      if (leaveKind === "HALF") {
        // 반일연차가 여러 날이면 최대치는 maxMins (애매하지만 cap만 적용)
        minutes = Math.min(minutes, maxMins);
      } else if (leaveKind === "FULL") {
        minutes = Math.min(minutes, maxMins);
      } else {
        // 부분연차는 1일을 넘기기 어렵지만 혹시 몰라 cap
        minutes = Math.min(minutes, maxMins);
      }

      const rec = {
        id: nextRecordId(),
        workerKey: key,
        name,
        pid,
        type: typeRaw,
        kind: leaveKind,
        startUTC: overlap.start,
        endUTC: overlap.end,
        minutes,
        rawDur,
        reason,
        method,
        filename,
      };

      state.leaveRecords.push(rec);
      usedRows++;

      if (method === "검토필요") {
        state.reviewRecords.push({
          id: rec.id,
          workerKey: key,
          name,
          pid,
          type: typeRaw,
          startUTC: overlap.start,
          endUTC: overlap.end,
          rawDur: rawDur || "(없음)",
          minutes: null,
          filename,
        });
        reviewRows++;
      }
    }

    // 테이블 갱신(임시 생성 포함)
    renderWorkersTable();

    return { totalRows, usedRows, reviewRows, createdWorkers };
  }

  function nextRecordId() {
    return "R" + Math.random().toString(36).slice(2, 10) + Date.now().toString(36);
  }

  function renderReviewRecords() {
    const box = $("#reviewBox");
    const tbody = $("#reviewTable tbody");

    if (!state.reviewRecords.length) {
      box.classList.add("hidden");
      tbody.innerHTML = "";
      return;
    }

    box.classList.remove("hidden");
    tbody.innerHTML = "";

    for (const r of state.reviewRecords) {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td class="nowrap">${escapeHtml(r.name)}</td>
        <td class="nowrap">${escapeHtml(r.workerKey)}</td>
        <td class="nowrap">${escapeHtml(r.type)}</td>
        <td class="nowrap">${utcToYmd(r.startUTC)} ~ ${utcToYmd(r.endUTC)}</td>
        <td class="nowrap">${escapeHtml(r.rawDur||"")}</td>
        <td class="right nowrap">
          <input type="number" class="numeric" min="0" step="1" data-rev="${escapeHtml(r.id)}" placeholder="분" />
        </td>
        <td class="center nowrap"><button class="btn btn-lightgrey" data-apply="${escapeHtml(r.id)}">반영</button></td>
        <td class="nowrap">${escapeHtml(r.filename)}</td>
      `;
      tbody.appendChild(tr);
    }

    tbody.querySelectorAll("button[data-apply]").forEach(btn => {
      btn.addEventListener("click", () => {
        const id = btn.getAttribute("data-apply");
        const inp = tbody.querySelector(`input[data-rev='${CSS.escape(id)}']`);
        const mins = inp ? safeNum(inp.value, NaN) : NaN;
        if (!Number.isFinite(mins) || mins < 0) {
          alert("분 단위 숫자를 입력하세요.");
          return;
        }

        // leaveRecords에 반영
        const rec = state.leaveRecords.find(x => x.id === id);
        if (rec) {
          rec.minutes = Math.round(mins);
          rec.method = "수기(분)";
        }

        // reviewRecords에서 제거
        state.reviewRecords = state.reviewRecords.filter(x => x.id !== id);
        renderReviewRecords();

        if (state.lastRunAt) runCalculation(false);
      });
    });
  }

  // =============================
  // 통상임금 계산
  // =============================
  function detectPayCategory(job) {
    const j = String(job||"").trim();
    const jn = normalizeText(j);

    // 특수운영직군
    if (JOB_KEYWORDS.special1.some(k => jn.includes(normalizeText(k)))) {
      return { cat: "special1", base40: state.constants.basePay40.type2, note: "특수운영1유형" };
    }
    if (JOB_KEYWORDS.special2.some(k => jn.includes(normalizeText(k)))) {
      return { cat: "special2", base40: state.constants.basePay40.type2, note: "특수운영2유형" };
    }

    // 1유형 초과(직종별)
    if (jn.includes("교육복지사") && jn.includes("기관")) {
      return { cat: "type1Over", base40: state.constants.basePay40.welfareInst, note: "교육복지사(기관)" };
    }
    if (jn.includes("임상심리사") || jn.includes("대안교육전문가")) {
      return { cat: "type1Over", base40: state.constants.basePay40.clinical, note: "임상/대안" };
    }
    if (jn.includes("학습클리닉") || jn.includes("학부모지원")) {
      return { cat: "type1Over", base40: state.constants.basePay40.clinic, note: "학습/학부모" };
    }
    if (jn.includes("진학전문지원관")) {
      return { cat: "type1Over", base40: state.constants.basePay40.jinhak, note: "진학전문지원관" };
    }
    if (jn.includes("학교운동부지도자")) {
      return { cat: "type1Over", base40: state.constants.basePay40.sports, note: "학교운동부" };
    }

    // 1유형 미만
    if (JOB_KEYWORDS.type1Under.some(k => jn.includes(normalizeText(k)))) {
      return { cat: "type1Under", base40: state.constants.basePay40.type1Under, note: "1유형 미만" };
    }

    // 1유형
    if (JOB_KEYWORDS.type1.some(k => jn.includes(normalizeText(k)))) {
      // 교육복지사(기관)은 위에서 이미 처리, 남은 교육복지사는 (학교)로 간주
      return { cat: "type1", base40: state.constants.basePay40.type1, note: "1유형" };
    }

    // 2유형
    if (JOB_KEYWORDS.type2.some(k => jn.includes(normalizeText(k)))) {
      return { cat: "type2", base40: state.constants.basePay40.type2, note: "2유형" };
    }

    // 모르면 2유형으로 가정
    return { cat: "unknown", base40: state.constants.basePay40.type2, note: "직종판독실패(2유형 가정)" };
  }

  function annualBonusFor(job) {
    const jn = normalizeText(job);
    if (JOB_KEYWORDS.special1.some(k => jn.includes(normalizeText(k)))) return state.constants.annualBonusSpecial1;
    if (JOB_KEYWORDS.special2.some(k => jn.includes(normalizeText(k)))) return state.constants.annualBonusDefault;
    return state.constants.annualBonusDefault;
  }

  function isSpecialHourlyCase(w) {
    const weekly = Number(w.weeklyHours || (Number(w.dailyHours||DEFAULT_DAILY_HOURS)*5));
    if (!(weekly > 0)) return false;
    const jn = normalizeText(w.job);
    const isSpecial = JOB_KEYWORDS.special1.concat(JOB_KEYWORDS.special2).some(k => jn.includes(normalizeText(k)));
    return isSpecial && weekly < 15;
  }

  function computeOrdinaryWage(w) {
    const dailyHours = Number(w.dailyHours || DEFAULT_DAILY_HOURS);
    const weeklyHours = Number(w.weeklyHours || dailyHours * 5);
    const monthlyHours = computeMonthlyHours(weeklyHours, dailyHours);

    // 수기 입력 우선
    if (w.hourlyOverride != null && Number.isFinite(Number(w.hourlyOverride)) && Number(w.hourlyOverride) > 0) {
      return {
        hourly: Math.round(Number(w.hourlyOverride)),
        monthly: null,
        monthlyHours,
        breakdown: { note: "수기입력" }
      };
    }

    // 특수운영(주15시간 미만): 시급제(단, 실제는 연차 자체가 없을 수 있음)
    if (isSpecialHourlyCase(w)) {
      const hourly = Number(state.constants.specialHourly || 0);
      const monthly = Math.round(hourly * (weeklyHours / 7) * (365 / 12));
      return {
        hourly: Math.round(hourly),
        monthly,
        monthlyHours: Math.round((weeklyHours / 7) * (365 / 12)),
        breakdown: { note: "특수운영(주15시간미만) 시급제 가정" }
      };
    }

    const serviceYears = computeServiceYearsAt(PAY_DATE, w.hireDateUTC);
    const serviceStep = Number(state.constants.serviceStep || 0);
    const serviceCap = Number(state.constants.serviceCapYears || 0);
    const serviceAllowance = serviceStep * Math.min(serviceCap, Math.max(0, serviceYears));

    const mealAllowance = Number(state.constants.mealAllowance || 0);

    const cat = detectPayCategory(w.job);

    // 기본급(근로시간 비례)
    const ratio = (weeklyHours > 0) ? (weeklyHours / 40) : 1;
    let basePay = Math.round(cat.base40 * ratio);

    // 조리사는 기본급에 5% 가산(보수표상 별도 표기) → 직종명에 조리사 포함이면 반영
    const jn = normalizeText(w.job);
    if (jn.includes("조리사") && !jn.includes("조리실무사")) {
      basePay = Math.round(Math.round(state.constants.basePay40.type2 * ratio) * 1.05);
    }

    // 직무관련수당(대표)
    let hazard = 0;
    if (jn.includes("조리실무사") || (jn.includes("조리사") && !jn.includes("조리실무사"))) {
      hazard = Number(state.constants.hazardAllowance || 0);
    }

    let mealOps = 0;
    if (jn.includes("영양사")) mealOps = Number(state.constants.mealOpsAllowance || 0);

    let license = 0;
    let techInfo = 0;
    if (jn.includes("영양사")) {
      const hasLicense = (w.flags && w.flags.nutritionLicense != null)
        ? !!w.flags.nutritionLicense
        : true;
      if (hasLicense) {
        license = Math.round(basePay * 0.05);
      } else {
        techInfo = Number(state.constants.techInfoAllowance || 0);
      }
    }

    let specialDuty = 0;
    if (jn.includes("학교도서관사서")) specialDuty = Number(state.constants.specialDutyLibrarian || 0);
    if (jn.includes("교육복지사") && !jn.includes("기관")) specialDuty = Math.max(specialDuty, Number(state.constants.specialDutyWelfare || 0));
    if (jn.includes("구육성회")) specialDuty = Math.max(specialDuty, Number(state.constants.specialDutyOld || 0));

    const custom = Number(w.customMonthlyAllowance || 0);

    const bonusMonthly = state.options.includeBonus ? (annualBonusFor(w.job) / 12) : 0;
    const holidayMonthly = state.options.includeHoliday ? (Number(state.constants.annualHoliday || 0) / 12) : 0;

    const monthly = basePay + serviceAllowance + mealAllowance + hazard + mealOps + license + techInfo + specialDuty + custom + bonusMonthly + holidayMonthly;

    const hourlyRaw = monthlyHours > 0 ? (monthly / monthlyHours) : 0;
    const hourly = Math.round(hourlyRaw);

    return {
      hourly,
      monthly,
      monthlyHours,
      breakdown: {
        cat: cat.note,
        basePay,
        serviceYears,
        serviceAllowance,
        mealAllowance,
        hazard,
        mealOps,
        license,
        techInfo,
        specialDuty,
        custom,
        bonusMonthly,
        holidayMonthly
      }
    };
  }

  // =============================
  // 연차 사용/미사용 계산
  // =============================
  function summarizeLeaveByWorker() {
    const map = new Map();

    for (const r of state.leaveRecords) {
      const w = state.workers.get(r.workerKey);
      const dailyMinutes = Math.round(Number(w?.dailyHours || DEFAULT_DAILY_HOURS) * 60);

      if (!map.has(r.workerKey)) {
        map.set(r.workerKey, {
          total: 0,
          byKind: { FULL:0, HALF:0, LATE:0, EARLY:0, OUT:0 },
          dailyMinutes,
          reviewCount: 0,
        });
      }
      const s = map.get(r.workerKey);

      const mins = Math.max(0, Number(r.minutes||0));
      s.total += mins;
      if (s.byKind[r.kind] != null) s.byKind[r.kind] += mins;

      if (r.method === "검토필요") s.reviewCount += 1;
    }

    // reviewRecords도 반영(아직 미반영된 것은 reviewCount만)
    for (const rr of state.reviewRecords) {
      if (!map.has(rr.workerKey)) {
        const w = state.workers.get(rr.workerKey);
        const dailyMinutes = Math.round(Number(w?.dailyHours || DEFAULT_DAILY_HOURS) * 60);
        map.set(rr.workerKey, { total: 0, byKind:{ FULL:0, HALF:0, LATE:0, EARLY:0, OUT:0 }, dailyMinutes, reviewCount: 1 });
      } else {
        map.get(rr.workerKey).reviewCount += 1;
      }
    }

    return map;
  }

  function minutesToDHM(mins, dailyMinutes) {
    const m = Math.max(0, Math.round(mins || 0));
    const dm = Math.max(1, Math.round(dailyMinutes || 480));

    const days = Math.floor(m / dm);
    const rem = m - days * dm;
    const hours = Math.floor(rem / 60);
    const minutes = rem - hours * 60;

    return { days, hours, minutes };
  }

  function fmtDHM(x) {
    if (!x) return "0일";
    const parts = [];
    parts.push(`${x.days}일`);
    if (x.hours) parts.push(`${x.hours}시간`);
    if (x.minutes) parts.push(`${x.minutes}분`);
    return parts.join(" ");
  }

  function floorTo10Won(amount) {
    const n = Math.floor(Number(amount || 0));
    return Math.floor(n / 10) * 10;
  }

  function runCalculation(showMsg = true) {
    const workers = Array.from(state.workers.values());
    if (workers.length === 0) {
      if (showMsg) setMsg($("#runMsg"), "err", "대상자가 없습니다. 인사기록 파일을 먼저 불러오세요.");
      renderResults([]);
      return;
    }

    const usage = summarizeLeaveByWorker();

    const results = [];

    for (const w of workers) {
      const dailyMinutes = Math.round(Number(w.dailyHours || DEFAULT_DAILY_HOURS) * 60);

      const grantedDays = (w.grantedDays == null || !Number.isFinite(Number(w.grantedDays))) ? null : Number(w.grantedDays);
      const grantedMinutes = (grantedDays == null) ? null : Math.round(grantedDays * dailyMinutes);

      const usedMinutes = usage.get(w.key)?.total || 0;
      const unusedMinutes = (grantedMinutes == null) ? null : Math.max(0, grantedMinutes - usedMinutes);

      const usedDhm = minutesToDHM(usedMinutes, dailyMinutes);
      const unusedDhm = (unusedMinutes == null) ? null : minutesToDHM(unusedMinutes, dailyMinutes);

      const wage = computeOrdinaryWage(w);

      let pay = null;
      if (unusedMinutes != null) {
        const raw = (unusedMinutes * (wage.hourly / 60));
        pay = floorTo10Won(raw);
      }

      const reviewCount = usage.get(w.key)?.reviewCount || 0;

      const notes = [];
      if (grantedDays == null) notes.push("부여연차 미입력");
      if (!w.job) notes.push("직종 없음");
      if (!w.hireDateUTC) notes.push("최초임용일 없음");
      if (reviewCount > 0) notes.push(`검토필요 ${reviewCount}건`);
      if (w.hourlyOverride != null) notes.push("통상임금 수기");

      results.push({
        workerKey: w.key,
        name: w.name || "",
        job: w.job || "",
        dailyMinutes,
        grantedDays,
        usedMinutes,
        unusedMinutes,
        usedDhm,
        unusedDhm,
        wage,
        pay,
        notes: notes.join(" · "),
        breakdown: usage.get(w.key)?.byKind || { FULL:0, HALF:0, LATE:0, EARLY:0, OUT:0 }
      });
    }

    state.lastRunAt = Date.now();

    if (showMsg) {
      const warn = results.some(r => r.notes.includes("미입력") || r.notes.includes("검토필요"));
      setMsg($("#runMsg"), warn ? "warn" : "ok", `
        <div><b>계산 완료</b> · ${results.length}명</div>
        <div class="muted">실행시각: ${new Date(state.lastRunAt).toLocaleString()}</div>
      `);
    }

    renderResults(results);
  }

  function renderResults(results) {
    const tbody = $("#resultTable tbody");
    tbody.innerHTML = "";

    if (!results || results.length === 0) {
      setMsg($("#resultSummary"), "warn", "결과가 없습니다. 계산을 실행해주세요.");
      $("#detailBox").innerHTML = "";
      return;
    }

    const sorted = results.slice().sort((a,b) => (a.name||"").localeCompare(b.name||"", "ko"));

    const sumPay = sorted.reduce((acc, r) => acc + (Number(r.pay||0)), 0);

    setMsg($("#resultSummary"), "ok", `
      <div><b>결과 요약</b></div>
      <ul>
        <li>대상: ${sorted.length}명</li>
        <li>총 미사용수당(10원 절삭 후 합계): <b>${formatMoney(sumPay)}</b>원</li>
        <li>정기상여금 포함: <b>${state.options.includeBonus ? "예" : "아니오"}</b></li>
        <li>명절휴가비 포함: <b>${state.options.includeHoliday ? "예" : "아니오"}</b></li>
      </ul>
      <div class="muted">※ 표의 ‘비고’에 <b>미입력/검토필요</b>가 있으면 해당 인원 확인 필요</div>
    `);

    for (const r of sorted) {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td class="nowrap">${escapeHtml(r.workerKey)}</td>
        <td class="nowrap">${escapeHtml(r.name)}</td>
        <td class="nowrap">${escapeHtml(r.job)}</td>
        <td class="right nowrap">${r.grantedDays == null ? "" : r.grantedDays.toFixed(1)}</td>
        <td class="right nowrap">${fmtDHM(r.usedDhm)}</td>
        <td class="right nowrap">${r.unusedDhm ? `<b>${fmtDHM(r.unusedDhm)}</b>` : ""}</td>
        <td class="right nowrap">${formatMoney(r.wage.hourly)}</td>
        <td class="right nowrap">${r.pay == null ? "" : `<b>${formatMoney(r.pay)}</b>`}</td>
        <td class="nowrap">${escapeHtml(r.notes||"")}</td>
      `;
      tbody.appendChild(tr);
    }

    renderDetail(sorted);
  }

  function renderDetail(sortedResults) {
    const box = $("#detailBox");
    box.innerHTML = "";

    for (const r of sortedResults) {
      const w = state.workers.get(r.workerKey);
      const by = r.breakdown || { FULL:0, HALF:0, LATE:0, EARLY:0, OUT:0 };
      const dailyMinutes = r.dailyMinutes;

      const card = document.createElement("div");
      card.className = "msg";

      const wage = r.wage;
      const b = wage.breakdown || {};

      const line = (label, mins) => {
        const dhm = minutesToDHM(mins, dailyMinutes);
        return `<li>${label}: ${fmtDHM(dhm)} <span class='muted'>(${mins}분)</span></li>`;
      };

      card.innerHTML = `
        <div><b>${escapeHtml(r.name)}</b> (${escapeHtml(r.workerKey)}) · ${escapeHtml(r.job||"")}</div>
        <div class="muted">부여 ${r.grantedDays == null ? "(미입력)" : r.grantedDays.toFixed(1)+"일"} / 사용 ${fmtDHM(r.usedDhm)} / 미사용 ${r.unusedDhm ? fmtDHM(r.unusedDhm) : "(미입력)"}</div>
        <hr />
        <div><b>연차 사용(유형별)</b></div>
        <ul>
          ${line("연차", by.FULL)}
          ${line("반일연차", by.HALF)}
          ${line("지각", by.LATE)}
          ${line("조퇴", by.EARLY)}
          ${line("외출", by.OUT)}
        </ul>
        <div><b>통상임금(자동/수기)</b></div>
        <ul>
          <li>시간당: <b>${formatMoney(wage.hourly)}</b>원</li>
          ${wage.monthly == null ? "" : `<li>월 통상임금(추정): ${formatMoney(wage.monthly)}원 / 월 소정시간: ${formatMoney(wage.monthlyHours)}시간</li>`}
          ${b.note ? `<li class='muted'>※ ${escapeHtml(b.note)}</li>` : ""}
          ${b.basePay != null ? `<li class='muted'>구성(참고): 기본급 ${formatMoney(b.basePay)}, 근속 ${formatMoney(b.serviceAllowance)}, 급식비 ${formatMoney(b.mealAllowance)}, 직무수당합 ${formatMoney((b.hazard||0)+(b.mealOps||0)+(b.license||0)+(b.techInfo||0)+(b.specialDuty||0)+(b.custom||0))}, 상여(월) ${formatMoney(b.bonusMonthly||0)}, 명절(월) ${formatMoney(b.holidayMonthly||0)}</li>` : ""}
        </ul>
      `;

      box.appendChild(card);
    }
  }

  // =============================
  // 엑셀 다운로드
  // =============================
  function downloadXlsx() {
    ensureXLSX();

    const rows = [];
    const usage = summarizeLeaveByWorker();

    rows.push([
      "나이스개인번호","성명","직종","최초임용일","1일시간","주시간",
      "부여연차(일)","사용(분)","사용(표시)","미사용(분)","미사용(표시)",
      "시간당통상임금","미사용수당(절삭)","비고"
    ]);

    const sorted = Array.from(state.workers.values()).sort((a,b) => (a.name||"").localeCompare(b.name||"", "ko"));

    for (const w of sorted) {
      const dailyMinutes = Math.round(Number(w.dailyHours || DEFAULT_DAILY_HOURS) * 60);
      const grantedDays = (w.grantedDays == null || !Number.isFinite(Number(w.grantedDays))) ? null : Number(w.grantedDays);
      const grantedMinutes = (grantedDays == null) ? null : Math.round(grantedDays * dailyMinutes);
      const usedMinutes = usage.get(w.key)?.total || 0;
      const unusedMinutes = (grantedMinutes == null) ? null : Math.max(0, grantedMinutes - usedMinutes);

      const usedDhm = minutesToDHM(usedMinutes, dailyMinutes);
      const unusedDhm = (unusedMinutes == null) ? null : minutesToDHM(unusedMinutes, dailyMinutes);

      const wage = computeOrdinaryWage(w);
      let pay = null;
      if (unusedMinutes != null) {
        pay = floorTo10Won(unusedMinutes * (wage.hourly / 60));
      }

      const serviceYears = computeServiceYearsAt(PAY_DATE, w.hireDateUTC);

      const notes = [];
      if (grantedDays == null) notes.push("부여연차 미입력");
      if (!w.job) notes.push("직종 없음");
      if (!w.hireDateUTC) notes.push("최초임용일 없음");
      const reviewCount = usage.get(w.key)?.reviewCount || 0;
      if (reviewCount > 0) notes.push(`검토필요 ${reviewCount}건`);
      if (w.hourlyOverride != null) notes.push("통상임금 수기");

      rows.push([
        w.key,
        w.name || "",
        w.job || "",
        w.hireDateUTC ? utcToYmd(w.hireDateUTC) : "",
        w.dailyHours ?? DEFAULT_DAILY_HOURS,
        w.weeklyHours ?? (Number(w.dailyHours||DEFAULT_DAILY_HOURS)*5),
        grantedDays == null ? "" : grantedDays,
        usedMinutes,
        fmtDHM(usedDhm),
        unusedMinutes == null ? "" : unusedMinutes,
        unusedDhm ? fmtDHM(unusedDhm) : "",
        wage.hourly,
        pay == null ? "" : pay,
        notes.join(" · ")
      ]);
    }

    const wb = XLSX.utils.book_new();
    const ws = XLSX.utils.aoa_to_sheet(rows);
    XLSX.utils.book_append_sheet(wb, ws, "미사용연차수당");

    // 원본 연차 기록도 하나 더
    const recRows = [];
    recRows.push(["개인번호","성명","유형","기간시작","기간종료","사용분","판독방법","원본값","파일"]);
    for (const r of state.leaveRecords) {
      recRows.push([
        r.workerKey,
        r.name,
        r.type,
        utcToYmd(r.startUTC),
        utcToYmd(r.endUTC),
        r.minutes,
        r.method,
        r.rawDur || "",
        r.filename
      ]);
    }
    const ws2 = XLSX.utils.aoa_to_sheet(recRows);
    XLSX.utils.book_append_sheet(wb, ws2, "연차사용_원본");

    const out = XLSX.write(wb, { bookType: "xlsx", type: "array" });
    const blob = new Blob([out], { type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" });

    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "2025회계_연차미사용수당_계산결과.xlsx";
    document.body.appendChild(a);
    a.click();
    a.remove();
  }

  // =============================
  // Drag & Drop 바인딩
  // =============================
  function bindDropZone(zoneEl, inputEl, onFiles) {
    zoneEl.addEventListener("click", () => inputEl.click());

    ["dragenter","dragover"].forEach(evt => {
      zoneEl.addEventListener(evt, (e) => {
        e.preventDefault();
        e.stopPropagation();
        zoneEl.classList.add("dragover");
      });
    });

    ["dragleave","drop"].forEach(evt => {
      zoneEl.addEventListener(evt, (e) => {
        e.preventDefault();
        e.stopPropagation();
        zoneEl.classList.remove("dragover");
      });
    });

    zoneEl.addEventListener("drop", (e) => {
      const files = Array.from(e.dataTransfer.files || []);
      if (!files.length) return;
      onFiles(files);
    });

    inputEl.addEventListener("change", () => {
      const files = Array.from(inputEl.files || []);
      if (!files.length) return;
      onFiles(files);
    });
  }

  // =============================
  // 고급설정 반영
  // =============================
  function fillConstInputs() {
    const c = state.constants;

    $("#cType1").value = c.basePay40.type1;
    $("#cType2").value = c.basePay40.type2;
    $("#cType1Under").value = c.basePay40.type1Under;

    $("#cWelfareInst").value = c.basePay40.welfareInst;
    $("#cClinical").value = c.basePay40.clinical;
    $("#cClinic").value = c.basePay40.clinic;
    $("#cJinhak").value = c.basePay40.jinhak;
    $("#cSports").value = c.basePay40.sports;

    $("#cMeal").value = c.mealAllowance;
    $("#cServiceStep").value = c.serviceStep;
    $("#cServiceCap").value = c.serviceCapYears;

    $("#cBonusDefault").value = c.annualBonusDefault;
    $("#cBonusSpecial1").value = c.annualBonusSpecial1;
    $("#cHoliday").value = c.annualHoliday;

    $("#cSpecialHourly").value = c.specialHourly;

    setMsg($("#constMsg"), "", "상수를 수정하고 <b>고급설정 반영</b>을 누르세요.");
  }

  function applyConstInputs() {
    const c = state.constants;

    c.basePay40.type1 = safeNum($("#cType1").value, c.basePay40.type1);
    c.basePay40.type2 = safeNum($("#cType2").value, c.basePay40.type2);
    c.basePay40.type1Under = safeNum($("#cType1Under").value, c.basePay40.type1Under);

    c.basePay40.welfareInst = safeNum($("#cWelfareInst").value, c.basePay40.welfareInst);
    c.basePay40.clinical = safeNum($("#cClinical").value, c.basePay40.clinical);
    c.basePay40.clinic = safeNum($("#cClinic").value, c.basePay40.clinic);
    c.basePay40.jinhak = safeNum($("#cJinhak").value, c.basePay40.jinhak);
    c.basePay40.sports = safeNum($("#cSports").value, c.basePay40.sports);

    c.mealAllowance = safeNum($("#cMeal").value, c.mealAllowance);
    c.serviceStep = safeNum($("#cServiceStep").value, c.serviceStep);
    c.serviceCapYears = safeNum($("#cServiceCap").value, c.serviceCapYears);

    c.annualBonusDefault = safeNum($("#cBonusDefault").value, c.annualBonusDefault);
    c.annualBonusSpecial1 = safeNum($("#cBonusSpecial1").value, c.annualBonusSpecial1);
    c.annualHoliday = safeNum($("#cHoliday").value, c.annualHoliday);

    c.specialHourly = safeNum($("#cSpecialHourly").value, c.specialHourly);

    setMsg($("#constMsg"), "ok", "고급설정이 반영되었습니다.");

    if (state.lastRunAt) runCalculation(false);
  }

  function resetConstants() {
    state.constants = structuredClone(DEFAULT_CONST);
    fillConstInputs();
    setMsg($("#constMsg"), "warn", "기본값으로 되돌렸습니다.");
    if (state.lastRunAt) runCalculation(false);
  }

  // =============================
  // 이벤트 바인딩
  // =============================
  function bindEvents() {
    // Drop zones
    bindDropZone($("#hrDrop"), $("#hrFile"), (files) => {
      const f = files[0];
      $("#hrFile").value = ""; // reset file input
      handleLoadHr(f);
    });

    bindDropZone($("#workDrop"), $("#workFiles"), (files) => {
      $("#workFiles").value = "";
      handleLoadWork(files);
    });

    // Buttons
    $("#btnLoadHr").addEventListener("click", async () => {
      const f = $("#hrFile").files?.[0];
      if (!f) { setMsg($("#hrMsg"), "err", "인사기록 파일을 선택하거나 드롭하세요."); return; }
      handleLoadHr(f);
    });

    $("#btnLoadWork").addEventListener("click", async () => {
      const files = Array.from($("#workFiles").files || []);
      if (!files.length) { setMsg($("#workMsg"), "err", "근무상황 파일을 선택하거나 드롭하세요."); return; }
      handleLoadWork(files);
    });

    $("#btnClearWork").addEventListener("click", () => {
      state.leaveRecords = [];
      state.reviewRecords = [];
      renderReviewRecords();
      setMsg($("#workMsg"), "warn", "근무사항(연차 사용 집계)을 초기화했습니다.");
      if (state.lastRunAt) runCalculation(false);
    });

    $("#btnClearAll").addEventListener("click", () => {
      state.workers.clear();
      state.leaveRecords = [];
      state.reviewRecords = [];
      state.lastRunAt = null;
      renderWorkersTable();
      renderReviewRecords();
      renderResults([]);
      setMsg($("#hrMsg"), "warn", "전체 초기화했습니다.");
      setMsg($("#workMsg"), "", "근무상황을 업로드해주세요.");
      setMsg($("#runMsg"), "", "계산 실행 버튼을 눌러주세요.");
    });

    $("#optIncludeBonus").addEventListener("change", () => {
      state.options.includeBonus = $("#optIncludeBonus").checked;
      if (state.lastRunAt) runCalculation(false);
    });

    $("#optIncludeHoliday").addEventListener("change", () => {
      state.options.includeHoliday = $("#optIncludeHoliday").checked;
      if (state.lastRunAt) runCalculation(false);
    });

    $("#btnRun").addEventListener("click", () => runCalculation(true));
    $("#btnDownload").addEventListener("click", () => {
      try { downloadXlsx(); } catch (e) { alert(e.message); }
    });

    // Advanced constants
    $("#btnResetConstants").addEventListener("click", resetConstants);
    $("#btnApplyConstants").addEventListener("click", applyConstInputs);
  }

  async function handleLoadHr(file) {
    try {
      const out = await loadHrFile(file);
      setMsg($("#hrMsg"), "ok", `
        <div><b>인사정보 추출 완료</b></div>
        <ul>
          <li>로드: ${out.loaded}명</li>
          <li>스킵: ${out.skipped}명</li>
        </ul>
        <div class="muted">※ 표에서 <b>부여연차(일)</b>는 반드시 입력하세요.</div>
      `);
    } catch (e) {
      setMsg($("#hrMsg"), "err", `<b>오류</b>: $