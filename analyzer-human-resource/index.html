<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>학교별 전입·전출 인사발령자 명단 집계기</title>

  <link id="commonStyle" rel="stylesheet" href="/static/style.css" />
  <script>
    (function () {
      const link = document.getElementById("commonStyle");
      if (!link) return;
      link.addEventListener("error", function () {
        const alt = document.createElement("link");
        alt.rel = "stylesheet";
        alt.href = "static/style.css";
        document.head.appendChild(alt);
        console.warn("[style] /static/style.css 로드 실패 → static/style.css 로 폴백");
      });
    })();
  </script>

  <style>
    :root{
      --bg:#ffffff;
      --ink:#111827;
      --muted:#6b7280;
      --line:#e5e7eb;
      --card:#ffffff;
      --soft:#f9fafb;
      --red:#b91c1c;
      --blue:#1d4ed8;
      --green:#047857;
      --amber:#b45309;
    }
    body{ margin:0; background:var(--bg); color:var(--ink); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple SD Gothic Neo","Noto Sans KR","Malgun Gothic",sans-serif; }
    .shell{ max-width: 1100px; margin:0 auto; padding: 0 16px; }
    .container{ max-width: 1100px; margin: 0 auto; padding: 0 16px 36px; }
    .site-header{ padding: 22px 0 10px; border-bottom:1px solid var(--line); background:#fff; }
    .site-header h1{ margin:0; font-size: 1.55rem; }
    .subtitle{ margin: 8px 0 0; color: var(--muted); line-height: 1.55; text-align:left; }

    .tool-card{ margin: 18px 0; padding: 14px; border:1px solid var(--line); border-radius: 14px; background: var(--card); }
    .tool-head{ display:flex; align-items:flex-start; justify-content:space-between; gap: 12px; flex-wrap: wrap; }
    .tool-title{ margin:0; font-size: 1.15rem; }
    .tool-sub{ margin: 6px 0 0; color: var(--muted); }

    hr{ border:0; border-top:1px solid var(--line); margin: 14px 0; }

    .btn-row{ display:flex; gap:10px; flex-wrap: wrap; justify-content:flex-start; align-items:center; }
    .btn{ appearance:none; border:1px solid var(--line); background: #fff; padding: 9px 12px; border-radius: 10px; cursor:pointer; font-weight: 600; }
    .btn.primary{ background:#111827; color:#fff; border-color:#111827; }
    .btn.ghost{ background: transparent; }
    .btn:disabled{ opacity: .55; cursor:not-allowed; }

    .field{ margin: 10px 0; }
    .field label{ display:block; font-weight: 700; margin-bottom: 6px; }
    .field .help{ color: var(--muted); font-size: .92rem; }

    input[type="text"], textarea, select{
      width: 100%;
      max-width: 100%;
      box-sizing: border-box;
      padding: 10px 12px;
      border:1px solid var(--line);
      border-radius: 10px;
      background:#fff;
      font-size: 1rem;
      color: var(--ink);
      min-width: 0;
    }
    select{
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    /* option 줄바꿈은 브라우저별 제약이 있어도, 최소한 폭이 레이아웃을 넘어가지 않게 유지 */
    select option{
      white-space: normal;
      word-break: break-word;
      max-width: 100%;
    }
    textarea{ resize: vertical; min-height: 92px; }

    .row{ display:flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .row.stretch > *{ flex: 1 1 260px; min-width: 0; }
    .between{ justify-content: space-between; }

    .pill{
      display:inline-block;
      padding: 2px 10px;
      border-radius: 999px;
      border: 1px solid var(--line);
      background: var(--soft);
      font-size: 0.9rem;
      line-height: 1.4;
      white-space: nowrap;
    }
    .pill.red{ border-color: #fecaca; background:#fef2f2; color:#991b1b; }
    .pill.blue{ border-color: #bfdbfe; background:#eff6ff; color:#1d4ed8; }
    .pill.green{ border-color: #bbf7d0; background:#f0fdf4; color:#047857; }
    .pill.amber{ border-color: #fed7aa; background:#fff7ed; color:#9a3412; }
    .pill.gray{ border-color: #e5e7eb; background:#f9fafb; color:#6b7280; }

    .muted{ color: var(--muted); }

    .dropzone{
      border: 2px dashed #cbd5e1;
      background: #f8fafc;
      padding: 18px 14px;
      border-radius: 14px;
      text-align:left;
      cursor:pointer;
      outline: none;
    }
    .dropzone strong{ display:block; margin-bottom: 6px; }
    .dropzone.dragover{ border-color: #111827; background: #eef2ff; }

    details{ border:1px solid var(--line); border-radius: 12px; padding: 10px 12px; background:#fff; }
    summary{ cursor:pointer; font-weight: 800; }

    .table-wrap{ width:100%; overflow:auto; border-radius: 12px; border:1px solid var(--line); }
    table{ border-collapse: collapse; width: 100%; min-width: 720px; }
    th, td{ border-bottom:1px solid var(--line); padding: 10px 10px; text-align:left; vertical-align: top; }
    thead th{ position: sticky; top: 0; background: var(--soft); z-index: 2; }
    td.numeric, th.numeric{ text-align:right; }
    tr.clickable:hover{ background: #f3f4f6; cursor:pointer; }
    tr.is-selected{ outline: 2px solid rgba(0,0,0,0.18); outline-offset: -2px; }

    th.sortable{ user-select:none; cursor:pointer; }
    th.sortable:hover{ background: #eef2ff; }
    .sort-ind{ margin-left: 6px; font-size: .9rem; color: var(--muted); }

    .grid-two{ display:grid; grid-template-columns: 1fr 1fr; gap: 14px; }
    @media (max-width: 900px){
      .grid-two{ grid-template-columns: 1fr; }
      table{ min-width: 860px; }
    }

    /* 툴팁: 흰색 배경 + 얇은 검정 테두리 */
    #tooltip{
      position: fixed;
      z-index: 9999;
      max-width: min(560px, 92vw);
      background: #fff;
      color: #111;
      border: 1px solid #111;
      border-radius: 10px;
      padding: 10px 12px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.12);
      display:none;
      pointer-events:none;
      white-space: normal;
      line-height: 1.45;
      font-size: .95rem;
    }

    .clean-list{ list-style:none; margin:0; padding:0; }
    .clean-list li{ padding: 8px 0; border-bottom:1px dashed #e5e7eb; }
    .clean-list li:last-child{ border-bottom:0; }
    .who{ font-weight: 800; }
    .meta{ display:block; color: var(--muted); font-size: .95rem; margin-top: 2px; }
    .mini{ font-size: .92rem; }

    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.95rem;
      border: 1px solid #e5e7eb;
      background: #f9fafb;
      padding: 2px 6px;
      border-radius: 6px;
    }

    .banner{
      border: 1px solid var(--line);
      background: var(--soft);
      border-radius: 12px;
      padding: 10px 12px;
    }
    .banner .title{ font-weight: 900; }
    .badge-row{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin-top:6px; }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .small-note{ font-size: .9rem; color: var(--muted); line-height: 1.45; }
    .wrap-any{ overflow-wrap:anywhere; word-break: break-word; }
  </style>
</head>

<body>
  <div id="tooltip"></div>

  <header class="site-header">
    <div class="shell">
      <h1>학교별 전입·전출 인사발령자 명단 집계기</h1>
      <p class="muted">
        ·에듀파인 업무지원-일반게시판에서 인사발령 엑셀 첨부파일 다운받아서 한꺼번에 업로드하면 학교별 전입자, 전출자 명단 집계해주는 기능 <br/>
        ·발령 일자가 같은 모든 직군의 엑셀 파일을 한꺼번에 다 올리시면 됩니다. 교육공무원, 지방공무원, 교육공무직 한번에 집계 가능
      </p>
    </div>
  </header>

  <main class="container">

    <!-- 1) 업로드/설정 -->
    <section class="tool-card" id="uploadSection">
      <div class="tool-head">
        <div>
          <h2 class="tool-title">1. 인사발령 엑셀파일 업로드</h2>
          <p class="tool-sub">
            ·드래그해서 업로드 가능합니다. 
          </p>
        </div>
      </div>

      <hr/>

      <div class="btn-row" style="margin-bottom: 10px;">
        <label class="btn" for="fileInput">파일 선택하기</label>

        <!-- display:none 대신 화면 밖으로 보내서 브라우저 호환성(특히 iOS Safari) 개선 -->
        <input id="fileInput" type="file" accept=".xlsx,.xls" multiple
               style="position:absolute; left:-9999px; width:1px; height:1px; opacity:0;" />

        <button id="btnAnalyze" class="btn primary">발령 정보 집계하기</button>
        <button id="btnClear" class="btn ghost">초기화하기</button>

        <span id="fileMeta" class="muted mini"></span>
      </div>

      <div id="dropZone" class="dropzone" tabindex="0" role="button" aria-label="여기에 엑셀 파일을 드래그해서 업로드">
        <strong>여기에 엑셀 파일을 드래그해서 놓기</strong>
        <div class="muted mini">지원: .xlsx, .xls · 여러 개 파일 가능</div>
      </div>

      <div id="analyzeBanner" class="banner" style="display:none; margin-top: 12px;">
        <div class="title">집계 결과 요약</div>
        <div id="globalTotals" class="small-note" style="margin-top:6px;"></div>
        <div class="badge-row" id="globalBadges"></div>
      </div>

      <div class="field" style="margin-top: 14px;">
        <details id="advancedDetails">
          <summary>데이터 추출 방식 상세 설정</summary>
          <div style="margin-top: 10px;">
            <div class="row stretch">
              <label class="mini" style="display:flex; gap:8px; align-items:center; font-weight:700;">
                <input id="optAutoDetect" type="checkbox" checked />
                <span>자동 컬럼 감지(추천)</span>
              </label>

              <label class="mini" style="display:flex; gap:8px; align-items:center; font-weight:700;">
                <input id="optNormalize" type="checkbox" checked />
                <span>근무지명 공백 및 개행 정리</span>
              </label>

              <label class="mini" style="display:flex; gap:8px; align-items:center; font-weight:700;">
                <input id="optPrefixRegion" type="checkbox" checked />
                <span>관할 태그 붙이기 (여러 지역 조회할 경우)</span>
              </label>

              <label class="mini" style="display:flex; gap:8px; align-items:center; font-weight:700;">
                <input id="optUseSubject" type="checkbox" checked />
                <span>교육공무원 과목이 있으면 직종에 포함</span>
              </label>

              <label class="mini" style="display:flex; gap:8px; align-items:center; font-weight:700;">
                <input id="optMaskNames" type="checkbox" checked />
                <span>이름 마스킹하기 (기본 설정)</span>
              </label>
            </div>

            <div class="field">
              <label class="mini">근무지 판단 키워드 </label>
              <div class="help">쉼표, 줄바꿈으로 구분. 학교급과 기관 키워드를 추가하면 근무지 판별 정확도 올라감.</div>
              <textarea id="placeKeywords" style="width:100%;">유치원, 초등학교, 중학교, 고등학교, 특수학교, 학교, 교육지원청, 교육청, 도서관, 센터, 유, 초, 중, 고</textarea>
            </div>

            <div class="field">
              <label class="mini">자동 감지 실패 시 수동 집계</label>
              <div class="help">모든 시트에 동일 적용. 컬럼은 A,B,C… 형태로 입력합니다.</div>

              <div class="row stretch">
                <div>
                  <label class="mini">연번/번호</label>
                  <input id="colSeq" type="text" value="A" maxlength="3" />
                </div>
                <div>
                  <label class="mini">성명</label>
                  <input id="colName" type="text" value="B" maxlength="3" />
                </div>
                <div>
                  <label class="mini">직종/직급</label>
                  <input id="colJob" type="text" value="C" maxlength="3" />
                </div>
                <div>
                  <label class="mini">전입자 발령 근무지</label>
                  <input id="colIn" type="text" value="D" maxlength="3" />
                </div>
                <div>
                  <label class="mini">전출자 현소속 근무지</label>
                  <input id="colOut" type="text" value="F" maxlength="3" />
                </div>
                <div>
                  <label class="mini">비고</label>
                  <input id="colNote" type="text" value="H" maxlength="3" />
                </div>
              </div>

              <div class="help">
                ※ 교육공무원 서식의 비고는 자동 감지 후 전출근무지 보정으로 활용함.
              </div>
            </div>

            <p id="libWarn" class="muted" style="display:none; margin: 8px 0 0;"></p>
          </div>
        </details>
      </div>

      <div class="field">
        <details id="fileListDetails">
          <summary id="fileListSummary">선택된 파일 (0개)</summary>
          <div style="margin-top: 10px;">
            <ul id="fileList" class="clean-list"></ul>
          </div>
        </details>
      </div>
    </section>

    <!-- 2) 학교(근무지) 상세 -->
    <section class="tool-card" id="detailSection" style="display:none;">
      <div class="tool-head">
        <div>
          <h2 class="tool-title">2. 학교별 상세 발령 내역</h2>
          <p class="tool-sub">
            ·근무지 선택하면 전체 전입 전출자 확인 가능.
          </p>
        </div>
        <div class="btn-row">
          <label class="mini" style="display:flex; gap:8px; align-items:center; font-weight:700;">
            <input id="optMaskNamesQuick" type="checkbox" checked />
            <span>이름 마스킹</span>
          </label>
          <button id="btnDownloadDetail" class="btn">현재 상세 CSV</button>
        </div>
      </div>

      <hr/>

      <div class="field">
        <label>학교/부서 검색</label>
        <input id="workplaceSearch" type="text" placeholder="예: oo교육지원청, oo초 ..." />
        <div class="help">공백/괄호/대소문자 차이는 무시함. 정규화함함.</div>
      </div>

      <div class="field">
        <label>학교/부서 선택</label>
        <select id="workplaceSelect" title="근무지 선택"></select>
        <div id="workplaceMeta" class="muted mini" style="margin-top:6px;"></div>
      </div>

      <div class="field">
        <label>직종(직급·과목) 선택</label>
        <select id="jobSelect" title="직종 선택"></select>
        <div id="jobMeta" class="muted mini" style="margin-top:6px;"></div>
      </div>

      <div class="grid-two">
        <div>
          <p class="muted mini" style="margin:0 0 8px;">
            ·아래 표 행에 마우스를 올리면 요약이 뜨고, 클릭하면 명단이 해당 직종으로 전환됨.
          </p>

          <div class="table-wrap">
            <table id="jobTable">
              <thead>
                <tr>
                  <th class="sortable" data-sort="staffType">구분<span class="sort-ind"></span></th>
                  <th class="sortable" data-sort="jobName">직종(직급·과목)<span class="sort-ind"></span></th>
                  <th class="numeric sortable" data-sort="out">전출<span class="sort-ind"></span></th>
                  <th class="numeric sortable" data-sort="in">전입<span class="sort-ind"></span></th>
                  <th class="numeric sortable" data-sort="diff">차이(전출-전입)<span class="sort-ind"></span></th>
                  <th class="numeric sortable" data-sort="total">총변동<span class="sort-ind"></span></th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </div>

        <div>
          <div id="detailLists"></div>
        </div>
      </div>
    </section>

    <!-- 3) 근무지별 요약 -->
    <section class="tool-card" id="summarySection" style="display:none;">
      <div class="tool-head">
        <div>
          <h2 class="tool-title">3. 근무지별 요약</h2>
          <p class="tool-sub">기본적으로 근무지명 오름차순 정렬임. 행 클릭 시 상세로 이동.</p>
        </div>
        <div class="btn-row">
          <button id="btnDownloadSummary" class="btn">현재 요약 CSV</button>
        </div>
      </div>

      <hr/>

      <div class="field">
        <label>학교/부서 검색</label>
        <input id="summarySearch" type="text" placeholder="예: oo초, 교육지원청..." />
      </div>

      <div class="field">
        <label>보기</label>
        <select id="summaryFilter">
          <option value="all" selected>전체</option>
          <option value="outMore">전출자가 더 많은 학교</option>
          <option value="inMore">전입자가 더 많은 학교</option>
          <option value="equal">전입전출 일치 학교</option>
        </select>
      </div>

      <p id="summaryStats" class="muted" style="margin:0 0 10px;"></p>

      <div class="table-wrap">
        <table id="summaryTable">
          <thead>
            <tr>
              <th class="sortable" data-sort="name">근무지<span class="sort-ind"></span></th>
              <th class="numeric sortable" data-sort="out">전출<span class="sort-ind"></span></th>
              <th class="numeric sortable" data-sort="in">전입<span class="sort-ind"></span></th>
              <th class="numeric sortable" data-sort="total">총 인사변동<span class="sort-ind"></span></th>
              <th class="numeric sortable" data-sort="diff">차이(전출-전입)<span class="sort-ind"></span></th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </section>

    <!-- 4) 결원 의심 목록 -->
    <section class="tool-card" id="suspectSection" style="display:none;">
      <div class="tool-head">
        <div>
          <h2 class="tool-title">4. 정원 감소 여부 확인 필요 (결원 의심 선별)</h2>
          <p class="tool-sub">
            ·정원 및 배치기준 등 확인 필요. 간단하게 스크리닝 용도임임.
          </p>
        </div>
        <div class="btn-row">
          <button id="btnDownloadSuspect" class="btn">현재 목록 CSV</button>
        </div>
      </div>

      <hr/>

      <div class="row stretch">
        <div class="field" style="margin:0;">
          <label>검색</label>
          <input id="suspectSearch" type="text" placeholder="근무지/직종 검색 (예: 조리, 국어, oo중)" />
        </div>
        <div class="field" style="margin:0;">
          <label>구분</label>
          <select id="suspectType">
            <option value="ALL" selected>전체</option>
            <option value="교육공무직">교육공무직</option>
            <option value="교육공무원">교육공무원</option>
            <option value="지방공무원">지방공무원</option>
          </select>
        </div>
      </div>

      <p id="suspectStats" class="muted" style="margin:10px 0;"></p>

      <div class="table-wrap">
        <table id="suspectTable">
          <thead>
            <tr>
              <th class="sortable" data-sort="staffType">구분<span class="sort-ind"></span></th>
              <th class="sortable" data-sort="workplace">근무지<span class="sort-ind"></span></th>
              <th class="sortable" data-sort="jobName">직종(직급·과목)<span class="sort-ind"></span></th>
              <th class="numeric sortable" data-sort="out">전출<span class="sort-ind"></span></th>
              <th class="numeric sortable" data-sort="in">전입<span class="sort-ind"></span></th>
              <th class="numeric sortable" data-sort="diff">결원 의심(전출-전입)<span class="sort-ind"></span></th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </section>

    <!-- 5) 로그 -->
    <section class="tool-card">
      <details id="logDetails">
        <summary>처리 로그</summary>
        <div style="margin-top:10px;">
          <pre id="logBox" class="muted" style="white-space: pre-wrap; margin:0;"></pre>
        </div>
      </details>
    </section>

    <p><a class="btn" href="../index.html">메인으로 돌아가기</a></p>
  </main>



<script>
(() => {
  "use strict";

  // ---------------------------
  // DOM
  // ---------------------------
  const $ = (s) => document.querySelector(s);

  const el = {
    tooltip: $("#tooltip"),

    fileInput: $("#fileInput"),
    dropZone: $("#dropZone"),
    btnAnalyze: $("#btnAnalyze"),
    btnClear: $("#btnClear"),
    fileMeta: $("#fileMeta"),

    analyzeBanner: $("#analyzeBanner"),
    globalTotals: $("#globalTotals"),
    globalBadges: $("#globalBadges"),

    optAutoDetect: $("#optAutoDetect"),
    optNormalize: $("#optNormalize"),
    optPrefixRegion: $("#optPrefixRegion"),
    optUseSubject: $("#optUseSubject"),
    optMaskNames: $("#optMaskNames"),
    optMaskNamesQuick: $("#optMaskNamesQuick"),
    placeKeywords: $("#placeKeywords"),

    colSeq: $("#colSeq"),
    colName: $("#colName"),
    colJob: $("#colJob"),
    colIn: $("#colIn"),
    colOut: $("#colOut"),
    colNote: $("#colNote"),

    libWarn: $("#libWarn"),

    fileListSummary: $("#fileListSummary"),
    fileList: $("#fileList"),

    detailSection: $("#detailSection"),
    workplaceSearch: $("#workplaceSearch"),
    workplaceSelect: $("#workplaceSelect"),
    workplaceMeta: $("#workplaceMeta"),
    jobSelect: $("#jobSelect"),
    jobMeta: $("#jobMeta"),
    jobTableBody: $("#jobTable tbody"),
    detailLists: $("#detailLists"),
    btnDownloadDetail: $("#btnDownloadDetail"),

    summarySection: $("#summarySection"),
    summarySearch: $("#summarySearch"),
    summaryFilter: $("#summaryFilter"),
    summaryStats: $("#summaryStats"),
    summaryTableBody: $("#summaryTable tbody"),
    btnDownloadSummary: $("#btnDownloadSummary"),

    suspectSection: $("#suspectSection"),
    suspectSearch: $("#suspectSearch"),
    suspectType: $("#suspectType"),
    suspectStats: $("#suspectStats"),
    suspectTableBody: $("#suspectTable tbody"),
    btnDownloadSuspect: $("#btnDownloadSuspect"),

    logBox: $("#logBox"),
  };

  // ---------------------------
  // State
  // ---------------------------
  const state = {
    files: [],
    analyzed: false,

    moves: [], // flat list

    workplaces: new Map(), // workplaceKey -> { key,name, inMoves,outMoves, jobs: Map(jobKey->jobAgg) }
    workplaceOrder: [],

    selectedWorkplaceKey: "",
    selectedJobKey: "ALL",

    // sorting states
    sortSummary: { key: "name", dir: "asc" },
    sortJobs: { key: "staffType", dir: "asc" },
    sortSuspect: { key: "diff", dir: "desc" },

    heur: null,
    regionTags: new Map(), // fileName -> regionTag

    maskNames: true,

    dedupe: {
      strictSeen: new Set(),
      strictSkipped: 0,
      looseMap: new Map(), // looseKey -> firstNote
      looseCollisions: 0,
      looseExamples: [],   // {name, jobName, inWorkplace, outWorkplace, noteA, noteB, sheetName, seq}
    },

    stats: null, // global stats
  };

  // ---------------------------
  // Logging
  // ---------------------------
  function log(line) {
    const ts = new Date().toLocaleTimeString();
    el.logBox.textContent += `[${ts}] ${line}\n`;
    el.logBox.scrollTop = el.logBox.scrollHeight;
  }
  function clearLog() { el.logBox.textContent = ""; }

  // ---------------------------
  // Tooltip
  // ---------------------------
  function showTooltip(html, x, y) {
    el.tooltip.innerHTML = html;
    el.tooltip.style.display = "block";

    const pad = 14;
    const rect = el.tooltip.getBoundingClientRect();
    const vw = window.innerWidth;
    const vh = window.innerHeight;

    let left = x + 12;
    let top = y + 12;
    if (left + rect.width + pad > vw) left = Math.max(pad, vw - rect.width - pad);
    if (top + rect.height + pad > vh) top = Math.max(pad, y - rect.height - 12);

    el.tooltip.style.left = left + "px";
    el.tooltip.style.top = top + "px";
  }
  function hideTooltip() {
    el.tooltip.style.display = "none";
    el.tooltip.innerHTML = "";
  }

  // ---------------------------
  // Utilities
  // ---------------------------
  function escapeHtml(s) {
    return String(s ?? "")
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/\"/g, "&quot;")
      .replace(/'/g, "&#039;");
  }

  function normalizeSpaces(v) {
    return String(v ?? "").replace(/\s+/g, " ").trim();
  }

  function normalizeKey(v) {
    return normalizeSpaces(v).replace(/\s+/g, "");
  }

  // 정규화 검색(공백/괄호/대소문자/구두점 차이 완화)
  function normalizeSearch(v) {
    return String(v ?? "")
      .toLowerCase()
      .replace(/\s+/g, "")
      .replace(/[\[\]\(\)\{\}<>]/g, "")
      .replace(/[·ㆍ\.\-_,]/g, "");
  }
  function includesNorm(hay, needle) {
    const n = normalizeSearch(needle);
    if (!n) return true;
    return normalizeSearch(hay).includes(n);
  }

  function bytesToHuman(bytes) {
    if (!Number.isFinite(bytes)) return "-";
    const units = ["B","KB","MB","GB"];
    let v = bytes, i = 0;
    while (v >= 1024 && i < units.length - 1) { v /= 1024; i++; }
    return `${v.toFixed(i === 0 ? 0 : 1)} ${units[i]}`;
  }

  function toIntLike(v) {
    if (typeof v === "number" && Number.isFinite(v)) return Math.trunc(v);
    const s = String(v ?? "").trim();
    if (!s) return null;
    if (/^\d+$/.test(s)) return parseInt(s, 10);
    const m = s.match(/^(\d+)\s*[\.\)\-]$/);
    if (m) return parseInt(m[1], 10);
    return null;
  }

  function colToIndex(col) {
    const s = String(col ?? "").trim().toUpperCase();
    if (!s) return null;
    let n = 0;
    for (let i = 0; i < s.length; i++) {
      const code = s.charCodeAt(i);
      if (code < 65 || code > 90) return null;
      n = n * 26 + (code - 64);
    }
    return n - 1;
  }

  function indexToCol(idx) {
    if (!Number.isFinite(idx) || idx < 0) return "";
    let n = idx + 1;
    let out = "";
    while (n > 0) {
      const r = (n - 1) % 26;
      out = String.fromCharCode(65 + r) + out;
      n = Math.floor((n - 1) / 26);
    }
    return out;
  }

  function downloadCsv(filename, rows2d) {
    const bom = "\uFEFF";
    const csv = rows2d.map(row => row.map(cell => {
      const raw = String(cell ?? "");
      const escaped = raw.replace(/\"/g, '""');
      return `"${escaped}"`;
    }).join(",")).join("\n");

    const blob = new Blob([bom + csv], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename.replace(/[\\/:*?"<>|]/g, "_");
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1200);
  }

  function debounce(fn, wait = 160) {
    let t = null;
    return (...args) => {
      if (t) clearTimeout(t);
      t = setTimeout(() => fn(...args), wait);
    };
  }

  function safeShort(s, max = 36) {
    const v = String(s ?? "");
    if (v.length <= max) return v;
    return v.slice(0, max - 1) + "…";
  }

  // 이름 마스킹 (김○○ / 홍○동)
  function maskName(name) {
    const raw = normalizeSpaces(name);
    if (!raw) return "";
    const hangul = raw.replace(/[^가-힣]/g, "");
    if (hangul.length < 2) return raw;

    const first = hangul[0];
    const last = hangul[hangul.length - 1];
    const middleCount = Math.max(1, hangul.length - 2);
    const masked = first + "○".repeat(middleCount) + (hangul.length >= 3 ? last : "");
    // 2글자면 김○, 3글자면 김○동, 4글자면 김○○동 ...
    if (hangul.length === 2) return first + "○";
    return masked;
  }

  function displayName(name) {
    const n = normalizeSpaces(name);
    return state.maskNames ? maskName(n) : n;
  }

  // ---------------------------
  // XLSX attaching
  // ---------------------------
  function loadScript(src) {
    return new Promise((resolve, reject) => {
      const s = document.createElement("script");
      s.src = src;
      s.onload = () => resolve(true);
      s.onerror = () => reject(new Error("script load fail: " + src));
      document.head.appendChild(s);
    });
  }

  async function ensureXLSX() {
    if (window.XLSX) return true;
    const sources = [
      "/static/xlsx.full.min.js",
      "static/xlsx.full.min.js",
      "https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"
    ];
    for (const src of sources) {
      try {
        log(`엑셀 파서 로드 시도: ${src}`);
        await loadScript(src);
        if (window.XLSX) {
          log("엑셀 파서 로드 완료 ✅");
          return true;
        }
      } catch {
        log(`로드 실패: ${src}`);
      }
    }
    return false;
  }

  function setLibWarning(ok) {
    if (ok) {
      el.libWarn.style.display = "none";
      el.btnAnalyze.disabled = false;
      return;
    }
    el.libWarn.style.display = "";
    el.libWarn.textContent =
      "⚠️ 엑셀 파서(XLSX)가 로드되지 않았습니다. " +
      "폐쇄망이면 /static/xlsx.full.min.js 를 프로젝트에 추가하세요. (또는 인터넷 환경에서 CDN 사용)";
    el.btnAnalyze.disabled = true;
  }

  // ---------------------------
  // Heuristics
  // ---------------------------
  function escapeRegExp(s) {
    return String(s).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }

  function cellStr(v) {
    return String(v ?? "").replace(/\s+/g, " ").trim();
  }
  function cellKey(v) {
    return normalizeKey(cellStr(v));
  }

  function buildHeuristics() {
    const raw = String(el.placeKeywords.value || "");
    const tokens = raw.split(/[\n,]/).map(s => normalizeSpaces(s)).filter(Boolean);

    const oneChar = tokens.filter(t => t.length === 1);
    const normal = tokens.filter(t => t.length >= 2);

    const strongRe = normal.length ? new RegExp(normal.map(x => escapeRegExp(x)).join("|")) : null;
    const suffixRe = oneChar.length ? new RegExp("(" + oneChar.map(x => escapeRegExp(x)).join("|") + ")$") : null;

    function isPlaceLike(s) {
      const v = normalizeSpaces(s);
      if (!v) return false;
      if (strongRe && strongRe.test(v)) return true;
      if (suffixRe && suffixRe.test(v.replace(/\s+/g,""))) return true;

      if (/(유치원|초등학교|중학교|고등학교|특수학교|학교|교육지원청|교육청|지원청|도서관|센터|기관)/.test(v)) return true;
      if (/(초|중|고|유)$/.test(v.replace(/\s+/g,""))) return true;
      return false;
    }

    function isSchoolLike(s) {
      const v = normalizeSpaces(s);
      if (!v) return false;
      if (/(유치원|초등학교|중학교|고등학교|특수학교|학교)/.test(v)) return true;
      if (/(초|중|고|유)$/.test(v.replace(/\s+/g,""))) return true;
      return false;
    }

    function isEduOfficeLike(s) {
      const v = normalizeSpaces(s);
      if (!v) return false;
      return /(교육지원청|교육청|지원청|도교육청|특별자치도교육청)/.test(v);
    }

    function looksLikeName(val) {
      const raw = normalizeSpaces(val);
      if (!raw) return false;
      if (/[0-9]/.test(raw)) return false;
      if (/[A-Za-z]/.test(raw)) return false;
      if (/[\/\(\)\[\]\{\}]/.test(raw)) return false;

      const compact = raw.replace(/\s+/g, "");
      if (!compact) return false;

      if (compact.length < 2 || compact.length > 4) return false;

      const isHangulName =
        /^[가-힣]{2,4}$/.test(compact) ||
        /^[가-힣]{1,4}[·\s][가-힣]{1,4}$/.test(raw);
      if (!isHangulName) return false;

      if (/(학교|유치원|교육지원청|교육청|지원청|도서관|센터)/.test(raw)) return false;
      if (/(초|중|고|유)$/.test(compact)) return false;

      return true;
    }

    function looksLikeJob(val) {
      const s = cellStr(val);
      if (!s) return false;
      return /(교사|교감|원감|원로|주무관|행정|실무사|전담사|영양사|조리|사서|상담|보건|전문상담|치료|간호|운전|시설|청소|돌봄|늘봄)/.test(s);
    }

    return { tokens, isPlaceLike, isSchoolLike, isEduOfficeLike, looksLikeName, looksLikeJob };
  }

  // ---------------------------
  // Layout detection + data cross-check
  // ---------------------------
  function forwardFill(keys) {
    const out = [];
    let last = "";
    for (const k of keys) {
      if (k) { last = k; out.push(k); }
      else { out.push(last); }
    }
    return out;
  }

  function countHeaderSignals(keys, RE) {
    let c = 0;
    for (const k of keys) {
      if (!k) continue;
      if (RE.seq.test(k) || RE.name.test(k) || RE.job.test(k) || RE.note.test(k) || RE.place.test(k) || RE.subject.test(k)) c++;
    }
    return c;
  }

  function findIdxPrefer(primaryKeys, secondaryKeys, re) {
    for (let i = 0; i < primaryKeys.length; i++) {
      if (primaryKeys[i] && re.test(primaryKeys[i])) return i;
    }
    for (let i = 0; i < secondaryKeys.length; i++) {
      if (secondaryKeys[i] && re.test(secondaryKeys[i])) return i;
    }
    return -1;
  }

  function analyzeColumnStats(rows, dataStart, colIdx, heur, maxScanRows = 300) {
    let nonEmpty = 0;
    let placeLike = 0;
    let schoolLike = 0;
    let eduOfficeLike = 0;
    const uniqSet = new Set();

    const end = Math.min(rows.length, dataStart + maxScanRows);
    for (let r = dataStart; r < end; r++) {
      const row = rows[r] || [];
      const v = cellStr(row[colIdx]);
      if (!v) continue;
      nonEmpty++;
      uniqSet.add(v);
      if (heur.isPlaceLike(v)) placeLike++;
      if (heur.isSchoolLike(v)) schoolLike++;
      if (heur.isEduOfficeLike(v)) eduOfficeLike++;
    }

    return {
      nonEmpty,
      uniqueCount: uniqSet.size,
      placeLikeRatio: nonEmpty ? placeLike / nonEmpty : 0,
      schoolLikeRatio: nonEmpty ? schoolLike / nonEmpty : 0,
      eduOfficeLikeRatio: nonEmpty ? eduOfficeLike / nonEmpty : 0,
    };
  }

  function analyzeLikeRatio(rows, dataStart, colIdx, predicate, maxScanRows = 120) {
    let nonEmpty = 0;
    let hit = 0;
    const end = Math.min(rows.length, dataStart + maxScanRows);
    for (let r = dataStart; r < end; r++) {
      const row = rows[r] || [];
      const s = cellStr(row[colIdx]);
      if (!s) continue;
      nonEmpty++;
      if (predicate(row[colIdx])) hit++;
    }
    return nonEmpty ? hit / nonEmpty : 0;
  }

  function analyzeSeqRatio(rows, dataStart, colIdx, maxScanRows = 120) {
    let nonEmpty = 0;
    let hit = 0;
    const end = Math.min(rows.length, dataStart + maxScanRows);
    for (let r = dataStart; r < end; r++) {
      const row = rows[r] || [];
      const s = cellStr(row[colIdx]);
      if (!s) continue;
      nonEmpty++;
      if (toIntLike(row[colIdx]) !== null) hit++;
    }
    return nonEmpty ? hit / nonEmpty : 0;
  }

  function detectLayoutPlus(rows, heur) {
    const RE = {
      seq: /(연번|순번|일련|번호)/,
      name: /(성명|이름)/,
      job: /(직종|직종명|직명|직급|직위)/,
      note: /(비고|특이|사유|전소속)/,
      subject: /(과목|교과|담당|전공)/,
      place: /(부서|근무처|근무지|기관명|기관|학교명|학교\(기관\)명|교육지원청|소속|부서명|학교)/,

      // 방향 힌트(전입=발령, 전출=현소속/전소속)
      inHint: /(발령|임용|전입|전보후|발령후|신규|임지|변경후|발령사항|임용사항)/,
      outHint: /(현소속|현직|현근무|현근무처|전출|퇴직|발령전|출발|변경전|종전|전보전|전소속)/,
    };

    const maxScan = Math.min(rows.length, 70);
    let best = null;

    // 2-row header scan
    for (let r = 0; r < maxScan - 1; r++) {
      const topRow = rows[r] || [];
      const botRow = rows[r + 1] || [];

      const n = Math.max(topRow.length, botRow.length);
      if (n <= 0) continue;

      const topKeys = Array.from({ length: n }, (_, i) => cellKey(topRow[i]));
      const botKeys = Array.from({ length: n }, (_, i) => cellKey(botRow[i]));
      const topFF = forwardFill(topKeys);

      const topCnt = countHeaderSignals(topKeys, RE);
      const botCnt = countHeaderSignals(botKeys, RE);

      const fieldKeys = (botCnt >= topCnt) ? botKeys : topKeys;
      const otherKeys = (fieldKeys === botKeys) ? topKeys : botKeys;

      const seqIdx = findIdxPrefer(fieldKeys, otherKeys, RE.seq);
      const nameIdx = findIdxPrefer(fieldKeys, otherKeys, RE.name);
      const jobIdx = findIdxPrefer(fieldKeys, otherKeys, RE.job);
      const noteIdx = findIdxPrefer(fieldKeys, otherKeys, RE.note);
      const subjectIdx = findIdxPrefer(fieldKeys, otherKeys, RE.subject);

      let placeCols = [];
      for (let i = 0; i < n; i++) {
        if (fieldKeys[i] && RE.place.test(fieldKeys[i])) placeCols.push(i);
      }
      if (placeCols.length < 1) {
        for (let i = 0; i < n; i++) {
          if ((topKeys[i] && RE.place.test(topKeys[i])) || (botKeys[i] && RE.place.test(botKeys[i]))) {
            placeCols.push(i);
          }
        }
      }

      if (nameIdx < 0 || placeCols.length < 1) continue;

      const dataStart = r + 2;

      const scored = placeCols.map((i) => {
        const combined = (topFF[i] || "") + " " + (fieldKeys[i] || "");
        const inScore = RE.inHint.test(combined) ? 3 : 0;
        const outScore = RE.outHint.test(combined) ? 3 : 0;
        const stats = analyzeColumnStats(rows, dataStart, i, heur, 120);
        const dataScore = stats.placeLikeRatio;
        return { i, combined, inScore, outScore, dataScore, stats };
      });

      let inIdx = -1;
      let outIdx = -1;

      // 1) header 힌트 우선
      const inSorted = [...scored].sort((a,b) => (b.inScore - a.inScore) || (b.dataScore - a.dataScore) || (a.i - b.i));
      const outSorted = [...scored].sort((a,b) => (b.outScore - a.outScore) || (b.dataScore - a.dataScore) || (b.i - a.i));

      if (inSorted[0] && inSorted[0].inScore > 0) inIdx = inSorted[0].i;
      if (outSorted[0] && outSorted[0].outScore > 0) outIdx = outSorted[0].i;

      // 2) 사용자 제안 방식: 좌→우(발령), 우→좌(현소속)
      const threshold = 0.22;
      if (inIdx < 0) {
        const leftToRight = scored.slice().sort((a,b) => a.i - b.i);
        inIdx = leftToRight.find(x => x.dataScore >= threshold)?.i ?? -1;
      }
      if (outIdx < 0) {
        const rightToLeft = scored.slice().sort((a,b) => b.i - a.i);
        outIdx = rightToLeft.find(x => x.dataScore >= threshold)?.i ?? -1;
      }

      // 3) fallback + 1컬럼 대응(중복 카운트 방지)
      if (placeCols.length === 1) {
        const only = scored[0];
        if (only) {
          if (only.inScore > only.outScore) { inIdx = only.i; outIdx = -1; }
          else if (only.outScore > only.inScore) { outIdx = only.i; inIdx = -1; }
          else { inIdx = only.i; outIdx = -1; }
        }
      } else {
        if (inIdx < 0 && placeCols.length) inIdx = Math.min(...placeCols);
        if (outIdx < 0 && placeCols.length) outIdx = Math.max(...placeCols);
        if (inIdx === outIdx && placeCols.length >= 2) {
          inIdx = placeCols[0];
          outIdx = placeCols[1];
        }
      }

      // 데이터 기반 크로스체크(이름/번호)
      const nameRatio = (nameIdx >= 0) ? analyzeLikeRatio(rows, dataStart, nameIdx, heur.looksLikeName, 120) : 0;
      const seqRatio = (seqIdx >= 0) ? analyzeSeqRatio(rows, dataStart, seqIdx, 120) : 0;

      const score =
        (seqIdx >= 0 ? 2 : 0) +
        (nameIdx >= 0 ? 2 : 0) +
        (placeCols.length >= 2 ? 2 : 1) +
        (jobIdx >= 0 ? 1 : 0) +
        (noteIdx >= 0 ? 1 : 0) +
        (subjectIdx >= 0 ? 0.5 : 0) +
        (nameRatio >= 0.25 ? 1 : 0) +
        (seqRatio >= 0.35 ? 1 : 0);

      if (!best || score > best.score) {
        best = {
          detected: true,
          headerRow: r,
          subRow: r + 1,
          dataStart,
          seqIdx,
          nameIdx,
          jobIdx,
          inIdx,
          outIdx,
          noteIdx,
          subjectIdx,
          placeCols,
          score,
          fieldKeys,
        };
      }
    }

    // 1-row fallback
    if (!best) {
      for (let r = 0; r < maxScan; r++) {
        const row = rows[r] || [];
        const n = row.length;
        if (n <= 0) continue;

        const keys = Array.from({ length: n }, (_, i) => cellKey(row[i]));
        const seqIdx = findIdxPrefer(keys, [], RE.seq);
        const nameIdx = findIdxPrefer(keys, [], RE.name);
        const jobIdx = findIdxPrefer(keys, [], RE.job);
        const noteIdx = findIdxPrefer(keys, [], RE.note);
        const subjectIdx = findIdxPrefer(keys, [], RE.subject);

        const placeCols = [];
        for (let i = 0; i < n; i++) if (keys[i] && RE.place.test(keys[i])) placeCols.push(i);
        if (nameIdx < 0 || placeCols.length < 1) continue;

        const dataStart = r + 1;

        const statsArr = placeCols.map(i => ({ i, stats: analyzeColumnStats(rows, dataStart, i, heur, 120) }));
        const threshold = 0.22;
        let inIdx = statsArr.sort((a,b)=>a.i-b.i).find(x=>x.stats.placeLikeRatio>=threshold)?.i ?? placeCols[0];
        let outIdx = statsArr.sort((a,b)=>b.i-a.i).find(x=>x.stats.placeLikeRatio>=threshold)?.i ?? placeCols[placeCols.length-1];

        if (placeCols.length === 1) {
          const combined = keys[inIdx] || "";
          const inScore = RE.inHint.test(combined) ? 1 : 0;
          const outScore = RE.outHint.test(combined) ? 1 : 0;
          if (outScore > inScore) { outIdx = inIdx; inIdx = -1; }
          else { outIdx = -1; }
        } else if (inIdx === outIdx) {
          outIdx = -1;
        }

        const nameRatio = (nameIdx >= 0) ? analyzeLikeRatio(rows, dataStart, nameIdx, heur.looksLikeName, 120) : 0;
        const seqRatio = (seqIdx >= 0) ? analyzeSeqRatio(rows, dataStart, seqIdx, 120) : 0;

        const score =
          (seqIdx >= 0 ? 2 : 0) +
          (nameIdx >= 0 ? 2 : 0) +
          (placeCols.length >= 2 ? 2 : 1) +
          (jobIdx >= 0 ? 1 : 0) +
          (noteIdx >= 0 ? 1 : 0) +
          (nameRatio >= 0.25 ? 1 : 0) +
          (seqRatio >= 0.35 ? 1 : 0);

        best = {
          detected: true,
          headerRow: r,
          subRow: r,
          dataStart,
          seqIdx,
          nameIdx,
          jobIdx,
          inIdx,
          outIdx,
          noteIdx,
          subjectIdx,
          placeCols,
          score,
          fieldKeys: keys,
        };
        break;
      }
    }

    return best;
  }

  // ---------------------------
  // Staff type inference
  // ---------------------------
  function detectStaffType(fileName, sheetName, jobName) {
    const s = `${fileName} ${sheetName} ${jobName}`.toLowerCase();

    if (/(교육공무직|공무직|조리실무사|행정실무사|교무행정사|늘봄|돌봄|시설관리|미화)/.test(s)) return "교육공무직";
    if (/(교육공무원|교사|교감|원감|원로교사|유치원|초등|중등|고등|특수)/.test(s)) return "교육공무원";
    if (/(지방공무원|주무관|서기|행정직|시설직|운전직|공업직|기능직)/.test(s)) return "지방공무원";

    if (/(교사|교감|원감|원로)/.test(jobName)) return "교육공무원";
    if (/(주무관|서기|행정직|시설직|운전직)/.test(jobName)) return "지방공무원";
    return "교육공무직";
  }

  // ---------------------------
  // Workplace normalization / region tag
  // ---------------------------
  function inferRegionTag(fileName) {
    const m = String(fileName).match(/^\s*\[([^\]]+)\]/);
    if (m) return normalizeSpaces(m[1]);
    return "";
  }

  function normalizeWorkplace(raw, regionTag, opt) {
    const s0 = normalizeSpaces(raw);
    if (!s0) return "";
    let s = s0;
    if (opt.normalizeOn) s = s.replace(/\s+/g, " ").trim();

    if (opt.prefixOn && regionTag) {
      if (!/^\[[^\]]+\]/.test(s)) {
        s = `[${regionTag}] ${s}`;
      }
    }
    return s;
  }

  // ---------------------------
  // Note parsing (전소속교 → 전출 근무지 추정)
  // ---------------------------
  function noteHeaderSuggestsPrevAffiliation(headerKey) {
    return /(전소속|전소속교|전소속\/직급|전소속\/직위|전소속\/직명)/.test(headerKey);
  }

  function parsePlaceFromNote(note, heur) {
    const s = normalizeSpaces(note);
    if (!s) return "";

    if (s.includes("/")) {
      const left = s.split("/")[0].trim();
      if (heur.isPlaceLike(left)) return left;
    }

    const cleaned = s.replace(/\(.*?\)/g, " ").replace(/\s+/g, " ").trim();
    const parts = cleaned.split(/[,\s]+/).filter(Boolean);

    let best = "";
    for (let i = 0; i < parts.length; i++) {
      let acc = "";
      for (let j = i; j < Math.min(parts.length, i + 6); j++) {
        acc = (acc ? acc + " " : "") + parts[j];
        if (heur.isPlaceLike(acc) && acc.length > best.length) best = acc;
      }
    }

    if (!best && heur.isPlaceLike(cleaned)) best = cleaned;
    return best;
  }

  // ---------------------------
  // Data model: workplace aggregation
  // ---------------------------
  function getWorkplace(key, name) {
    if (!state.workplaces.has(key)) {
      state.workplaces.set(key, {
        key,
        name,
        inMoves: [],
        outMoves: [],
        jobs: new Map(), // jobKey -> { staffType, jobKey, jobName, inMoves, outMoves }
      });
    }
    return state.workplaces.get(key);
  }

  function getJobAgg(w, jobKey, staffType, jobName) {
    if (!w.jobs.has(jobKey)) {
      w.jobs.set(jobKey, { staffType, jobKey, jobName, inMoves: [], outMoves: [] });
    }
    return w.jobs.get(jobKey);
  }

  function addMove(move) {
    state.moves.push(move);

    if (move.inWorkplace) {
      const w = getWorkplace(move.inWorkplace, move.inWorkplace);
      w.inMoves.push(move);
      const j = getJobAgg(w, move.jobKey, move.staffType, move.jobName);
      j.inMoves.push(move);
    }

    if (move.outWorkplace) {
      const w = getWorkplace(move.outWorkplace, move.outWorkplace);
      w.outMoves.push(move);
      const j = getJobAgg(w, move.jobKey, move.staffType, move.jobName);
      j.outMoves.push(move);
    }
  }

  // ---------------------------
  // Sorting helpers
  // ---------------------------
  function toggleSort(sortState, key) {
    if (sortState.key === key) {
      sortState.dir = (sortState.dir === "asc") ? "desc" : "asc";
    } else {
      sortState.key = key;
      sortState.dir = (key === "name" || key === "workplace" || key === "jobName" || key === "staffType") ? "asc" : "desc";
    }
  }

  function compare(a, b, dir) {
    if (a === b) return 0;
    const s = (dir === "asc") ? 1 : -1;
    return (a > b ? 1 : -1) * s;
  }

  function cmpKo(a, b, dir) {
    const s = (dir === "asc") ? 1 : -1;
    return a.localeCompare(b, "ko") * s;
  }

  function renderSortIndicators(tableEl, sortState) {
    const ths = [...tableEl.querySelectorAll("thead th.sortable")];
    ths.forEach(th => {
      const span = th.querySelector(".sort-ind");
      if (!span) return;
      const key = th.dataset.sort;
      if (key === sortState.key) {
        span.textContent = sortState.dir === "asc" ? "▲" : "▼";
      } else {
        span.textContent = "";
      }
    });
  }

  // ---------------------------
  // Rendering: analysis banner (totals + dedupe)
  // ---------------------------
  function renderAnalyzeBanner() {
    if (!state.stats) return;

    el.analyzeBanner.style.display = "";

    const s = state.stats;
    const netText = s.netDiff > 0 ? `+${s.netDiff}` : String(s.netDiff);

    el.globalTotals.innerHTML = `
      총 레코드 <b>${s.totalRecords}</b>건 · 전출(출발) <b>${s.totalOut}</b> · 전입(도착) <b>${s.totalIn}</b> · 총차이(전출-전입) <b class="mono">${escapeHtml(netText)}</b>
      <br/>
      (전출만 <b>${s.onlyOut}</b>, 전입만 <b>${s.onlyIn}</b>, 양쪽 모두 <b>${s.both}</b>)
    `;

    el.globalBadges.innerHTML = "";

    const frag = document.createDocumentFragment();

    const wCnt = state.workplaceOrder.length;
    const pillW = document.createElement("span");
    pillW.className = "pill gray";
    pillW.textContent = `근무지 ${wCnt}개`;
    frag.appendChild(pillW);

    // 중복 제거 결과
    if (state.dedupe.strictSkipped > 0) {
      const p = document.createElement("span");
      p.className = "pill red";
      p.textContent = `중복 레코드 ${state.dedupe.strictSkipped}건 제외됨`;
      frag.appendChild(p);
    } else {
      const p = document.createElement("span");
      p.className = "pill green";
      p.textContent = `중복(완전 동일) 제외: 0건`;
      frag.appendChild(p);
    }

    // 중복 의심
    if (state.dedupe.looseCollisions > 0) {
      const p = document.createElement("span");
      p.className = "pill amber";
      p.textContent = `중복 의심 ${state.dedupe.looseCollisions}건(값 일부 상이)`;
      frag.appendChild(p);
    } else {
      const p = document.createElement("span");
      p.className = "pill gray";
      p.textContent = `중복 의심: 0건`;
      frag.appendChild(p);
    }

    // 마스킹 상태
    const pMask = document.createElement("span");
    pMask.className = "pill gray";
    pMask.textContent = state.maskNames ? "이름 마스킹: ON" : "이름 마스킹: OFF";
    frag.appendChild(pMask);

    el.globalBadges.appendChild(frag);
  }

  // ---------------------------
  // Rendering: Workplace select + job select
  // ---------------------------
  function renderWorkplaceSelect() {
    const q = el.workplaceSearch.value || "";
    const opts = [];

    for (const key of state.workplaceOrder) {
      const w = state.workplaces.get(key);
      if (!w) continue;
      if (q && !includesNorm(w.name, q)) continue;
      opts.push({ key: w.key, name: w.name });
    }

    const current = state.selectedWorkplaceKey;
    const hasCurrent = opts.some(o => o.key === current);

    el.workplaceSelect.innerHTML = "";
    const frag = document.createDocumentFragment();
    for (const o of opts) {
      const opt = document.createElement("option");
      opt.value = o.key;
      opt.textContent = o.name;
      frag.appendChild(opt);
    }
    el.workplaceSelect.appendChild(frag);

    if (!hasCurrent) {
      state.selectedWorkplaceKey = (opts[0]?.key || "");
    }
    el.workplaceSelect.value = state.selectedWorkplaceKey;

    el.workplaceMeta.textContent = `표시 중: ${opts.length}개 근무지`;
  }

  function renderJobSelect() {
    const w = state.workplaces.get(state.selectedWorkplaceKey);
    if (!w) return;

    const list = [];
    for (const [, j] of w.jobs) {
      const inC = j.inMoves.length;
      const outC = j.outMoves.length;
      const diff = outC - inC;
      list.push({
        staffType: j.staffType,
        jobKey: j.jobKey,
        jobName: j.jobName,
        inC,
        outC,
        diff,
        total: inC + outC,
      });
    }

    list.sort((a,b) => (b.total - a.total) || cmpKo(a.jobName, b.jobName, "asc"));

    el.jobSelect.innerHTML = "";
    const frag = document.createDocumentFragment();

    const optAll = document.createElement("option");
    optAll.value = "ALL";
    optAll.textContent = `전체 직종`;
    frag.appendChild(optAll);

    for (const r of list) {
      const opt = document.createElement("option");
      opt.value = r.jobKey;
      const badge =
        r.diff > 0 ? `결원 의심 +${r.diff}` :
        r.diff < 0 ? `순증가 ${-r.diff}` :
        `균형 0`;
      opt.textContent = `[${r.staffType}] ${r.jobName} (전출 ${r.outC}/전입 ${r.inC} · ${badge})`;
      frag.appendChild(opt);
    }

    el.jobSelect.appendChild(frag);

    if (state.selectedJobKey !== "ALL" && !list.some(x => x.jobKey === state.selectedJobKey)) {
      state.selectedJobKey = "ALL";
    }
    el.jobSelect.value = state.selectedJobKey;

    el.jobMeta.textContent = `직종(직급·과목) ${list.length}개`;
  }

  // ---------------------------
  // Rendering: Workplace detail
  // ---------------------------
  function renderWorkplaceDetail() {
    const w = state.workplaces.get(state.selectedWorkplaceKey);
    if (!w) return;

    const rows = [];
    for (const [, j] of w.jobs) {
      const inC = j.inMoves.length;
      const outC = j.outMoves.length;
      rows.push({
        staffType: j.staffType,
        jobKey: j.jobKey,
        jobName: j.jobName,
        in: inC,
        out: outC,
        diff: outC - inC,
        total: inC + outC,
        agg: j,
      });
    }

    rows.sort((a,b) => {
      const k = state.sortJobs.key;
      const dir = state.sortJobs.dir;
      if (k === "staffType") return cmpKo(a.staffType, b.staffType, dir) || cmpKo(a.jobName, b.jobName, "asc");
      if (k === "jobName") return cmpKo(a.jobName, b.jobName, dir);
      if (k === "in") return compare(a.in, b.in, dir) || cmpKo(a.jobName, b.jobName, "asc");
      if (k === "out") return compare(a.out, b.out, dir) || cmpKo(a.jobName, b.jobName, "asc");
      if (k === "diff") return compare(a.diff, b.diff, dir) || cmpKo(a.jobName, b.jobName, "asc");
      if (k === "total") return compare(a.total, b.total, dir) || cmpKo(a.jobName, b.jobName, "asc");
      return cmpKo(a.jobName, b.jobName, "asc");
    });

    const inTotal = w.inMoves.length;
    const outTotal = w.outMoves.length;
    const diffTotal = outTotal - inTotal;

    const badge =
      diffTotal > 0 ? `<span class="pill red">결원 의심 +${diffTotal}</span>` :
      diffTotal < 0 ? `<span class="pill blue">순증가 ${-diffTotal}</span>` :
      `<span class="pill gray">균형 0</span>`;

    el.workplaceMeta.innerHTML = `전출 ${outTotal} · 전입 ${inTotal} · 총변동 ${inTotal + outTotal} · ${badge}`;

    el.jobTableBody.innerHTML = "";
    const frag = document.createDocumentFragment();

    for (const r of rows) {
      const tr = document.createElement("tr");
      tr.className = "clickable";
      tr.dataset.jobKey = r.jobKey;

      const diffPill =
        r.diff > 0 ? `<span class="pill red">+${r.diff}</span>` :
        r.diff < 0 ? `<span class="pill blue">${r.diff}</span>` :
        `<span class="pill gray">0</span>`;

      tr.innerHTML = `
        <td>${escapeHtml(r.staffType)}</td>
        <td><b>${escapeHtml(r.jobName)}</b></td>
        <td class="numeric">${r.out}</td>
        <td class="numeric">${r.in}</td>
        <td class="numeric">${diffPill}</td>
        <td class="numeric">${r.total}</td>
      `;

      tr.addEventListener("mouseenter", (e) => {
        const html = `
          <div><b>${escapeHtml(w.name)}</b></div>
          <div class="mini">[${escapeHtml(r.staffType)}] ${escapeHtml(r.jobName)}</div>
          <div class="mini" style="margin-top:6px;">
            전출 <b>${r.out}</b> · 전입 <b>${r.in}</b> · 차이 <b>${escapeHtml(r.diff>0?`+${r.diff}`:String(r.diff))}</b>
          </div>
          <div class="mini muted" style="margin-top:6px;">클릭하면 오른쪽 명단이 이 직종으로 전환됩니다.</div>
        `;
        showTooltip(html, e.clientX, e.clientY);
      });
      tr.addEventListener("mousemove", (e) => {
        if (el.tooltip.style.display === "block") showTooltip(el.tooltip.innerHTML, e.clientX, e.clientY);
      });
      tr.addEventListener("mouseleave", hideTooltip);

      tr.addEventListener("click", () => {
        state.selectedJobKey = r.jobKey;
        el.jobSelect.value = r.jobKey;
        renderListsForSelectedJob();

        [...el.jobTableBody.querySelectorAll("tr")].forEach(x => x.classList.remove("is-selected"));
        tr.classList.add("is-selected");
      });

      frag.appendChild(tr);
    }

    el.jobTableBody.appendChild(frag);
    renderSortIndicators(document.getElementById("jobTable"), state.sortJobs);

    setTimeout(() => {
      const trs = [...el.jobTableBody.querySelectorAll("tr")];
      trs.forEach(t => t.classList.remove("is-selected"));
      if (state.selectedJobKey !== "ALL") {
        const hit = trs.find(t => t.dataset.jobKey === state.selectedJobKey);
        if (hit) hit.classList.add("is-selected");
      }
    }, 0);

    renderListsForSelectedJob();
  }

  function renderListsForSelectedJob() {
    const w = state.workplaces.get(state.selectedWorkplaceKey);
    if (!w) return;

    const jobKey = state.selectedJobKey;
    let inMoves = [];
    let outMoves = [];
    let title = "";

    if (jobKey === "ALL") {
      inMoves = w.inMoves.slice();
      outMoves = w.outMoves.slice();
      title = `전체 직종`;
    } else {
      const agg = w.jobs.get(jobKey);
      if (agg) {
        inMoves = agg.inMoves.slice();
        outMoves = agg.outMoves.slice();
        title = `[${agg.staffType}] ${agg.jobName}`;
      }
    }

    inMoves.sort((a,b) => a.seq - b.seq);
    outMoves.sort((a,b) => a.seq - b.seq);

    const makeEvidence = (m) => {
      const fileShort = safeShort(m.fileName, 34);
      const sheetShort = safeShort(m.sheetName, 24);
      const full = `${m.fileName} / ${m.sheetName} / ${m.rowIndex}행`;
      return `<span class="mono muted mini wrap-any" title="${escapeHtml(full)}">(${escapeHtml(fileShort)} / ${escapeHtml(sheetShort)} / ${m.rowIndex}행)</span>`;
    };

    const inList = inMoves.map(m => `
      <li>
        <span class="who">${escapeHtml(displayName(m.name) || "(이름없음)")}</span>
        <span class="meta">
          ← ${escapeHtml(m.outWorkplace || "-")}
          ${m.note ? ` <span class="pill gray">${escapeHtml(m.note)}</span>` : ""}
          ${m.staffType ? ` <span class="pill gray">${escapeHtml(m.staffType)}</span>` : ""}
          ${makeEvidence(m)}
        </span>
      </li>
    `).join("");

    const outList = outMoves.map(m => `
      <li>
        <span class="who">${escapeHtml(displayName(m.name) || "(이름없음)")}</span>
        <span class="meta">
          → ${escapeHtml(m.inWorkplace || "-")}
          ${m.note ? ` <span class="pill gray">${escapeHtml(m.note)}</span>` : ""}
          ${m.staffType ? ` <span class="pill gray">${escapeHtml(m.staffType)}</span>` : ""}
          ${makeEvidence(m)}
        </span>
      </li>
    `).join("");

    const diff = outMoves.length - inMoves.length;
    const badge =
      diff > 0 ? `<span class="pill red">결원 의심 +${diff}</span>` :
      diff < 0 ? `<span class="pill blue">순증가 ${-diff}</span>` :
      `<span class="pill gray">균형 0</span>`;

    el.detailLists.innerHTML = `
      <div class="tool-card" style="margin:0; border-color: var(--line);">
        <div class="row between" style="flex-wrap:wrap;">
          <div>
            <div class="mini muted">선택 근무지</div>
            <div style="font-weight:900; font-size:1.05rem;">${escapeHtml(w.name)}</div>
            <div class="mini muted" style="margin-top:4px;">직종: <b>${escapeHtml(title)}</b></div>
            <div class="mini muted" style="margin-top:4px;">※ 원본 근거(파일/시트/행)는 명단 항목 오른쪽 괄호에 표시됩니다.</div>
          </div>
          <div style="display:flex; flex-direction:column; align-items:flex-end; gap:6px;">
            ${badge}
            <span class="pill gray">전출 ${outMoves.length} · 전입 ${inMoves.length}</span>
          </div>
        </div>

        <hr/>

        <div class="grid-two">
          <div class="tool-card" style="margin:0; background:#fff;">
            <h3 class="tool-title" style="margin:0; font-size:1.05rem;">전출/퇴직 명단</h3>
            <p class="muted mini" style="margin:6px 0 0;">(이 근무지를 떠나는 사람들)</p>
            <ul class="clean-list" style="margin-top:8px;">${outList || `<li class="muted">없음</li>`}</ul>
          </div>
          <div class="tool-card" style="margin:0; background:#fff;">
            <h3 class="tool-title" style="margin:0; font-size:1.05rem;">전입 명단</h3>
            <p class="muted mini" style="margin:6px 0 0;">(이 근무지로 오는 사람들)</p>
            <ul class="clean-list" style="margin-top:8px;">${inList || `<li class="muted">없음</li>`}</ul>
          </div>
        </div>
      </div>
    `;
  }

  // ---------------------------
  // Rendering: Summary table
  // ---------------------------
  function renderSummary() {
    const q = el.summarySearch.value || "";
    const mode = el.summaryFilter.value;

    const list = [];
    for (const key of state.workplaceOrder) {
      const w = state.workplaces.get(key);
      if (!w) continue;
      if (q && !includesNorm(w.name, q)) continue;

      const inC = w.inMoves.length;
      const outC = w.outMoves.length;
      const diff = outC - inC;
      const total = inC + outC;

      if (mode === "outMore" && diff <= 0) continue;
      if (mode === "inMore" && diff >= 0) continue;
      if (mode === "equal" && diff !== 0) continue;

      list.push({ key, name: w.name, in: inC, out: outC, diff, total });
    }

    list.sort((a,b) => {
      const k = state.sortSummary.key;
      const dir = state.sortSummary.dir;
      if (k === "name") return cmpKo(a.name, b.name, dir);
      if (k === "in") return compare(a.in, b.in, dir) || cmpKo(a.name, b.name, "asc");
      if (k === "out") return compare(a.out, b.out, dir) || cmpKo(a.name, b.name, "asc");
      if (k === "diff") return compare(a.diff, b.diff, dir) || cmpKo(a.name, b.name, "asc");
      if (k === "total") return compare(a.total, b.total, dir) || cmpKo(a.name, b.name, "asc");
      return cmpKo(a.name, b.name, "asc");
    });

    el.summaryStats.textContent = `표시 중: ${list.length}개 근무지`;

    el.summaryTableBody.innerHTML = "";
    const frag = document.createDocumentFragment();

    for (const r of list) {
      const tr = document.createElement("tr");
      tr.className = "clickable";
      tr.dataset.key = r.key;

      const diffPill =
        r.diff > 0 ? `<span class="pill red">+${r.diff}</span>` :
        r.diff < 0 ? `<span class="pill blue">${r.diff}</span>` :
        `<span class="pill gray">0</span>`;

      tr.innerHTML = `
        <td><b>${escapeHtml(r.name)}</b></td>
        <td class="numeric">${r.out}</td>
        <td class="numeric">${r.in}</td>
        <td class="numeric">${r.total}</td>
        <td class="numeric">${diffPill}</td>
      `;

      tr.addEventListener("mouseenter", (e) => {
        const html = `
          <div><b>${escapeHtml(r.name)}</b></div>
          <div class="mini" style="margin-top:6px;">
            전출 <b>${r.out}</b> · 전입 <b>${r.in}</b> · 총변동 <b>${r.total}</b> · 차이 <b>${escapeHtml(r.diff>0?`+${r.diff}`:String(r.diff))}</b>
          </div>
          <div class="mini muted" style="margin-top:6px;">클릭하면 “학교별 상세내역”으로 이동합니다.</div>
        `;
        showTooltip(html, e.clientX, e.clientY);
      });
      tr.addEventListener("mousemove", (e) => {
        if (el.tooltip.style.display === "block") showTooltip(el.tooltip.innerHTML, e.clientX, e.clientY);
      });
      tr.addEventListener("mouseleave", hideTooltip);

      tr.addEventListener("click", () => {
        state.selectedWorkplaceKey = r.key;
        renderWorkplaceSelect();
        renderJobSelect();
        renderWorkplaceDetail();
        document.getElementById("detailSection")?.scrollIntoView({ behavior:"smooth", block:"start" });
      });

      frag.appendChild(tr);
    }

    el.summaryTableBody.appendChild(frag);
    renderSortIndicators(document.getElementById("summaryTable"), state.sortSummary);
  }

  // ---------------------------
  // Rendering: Suspect list
  // ---------------------------
  function renderSuspect() {
    const q = el.suspectSearch.value || "";
    const type = el.suspectType.value;

    const rows = [];
    for (const key of state.workplaceOrder) {
      const w = state.workplaces.get(key);
      if (!w) continue;

      for (const [, j] of w.jobs) {
        const inC = j.inMoves.length;
        const outC = j.outMoves.length;
        const diff = outC - inC;
        if (diff <= 0) continue;

        const jobName = j.jobName;
        const staffType = j.staffType;

        if (type !== "ALL" && staffType !== type) continue;

        if (q) {
          const hay = `${w.name} ${jobName} ${staffType}`;
          if (!includesNorm(hay, q)) continue;
        }

        rows.push({
          workplaceKey: w.key,
          workplace: w.name,
          staffType,
          jobKey: j.jobKey,
          jobName,
          in: inC,
          out: outC,
          diff,
        });
      }
    }

    rows.sort((a,b) => {
      const k = state.sortSuspect.key;
      const dir = state.sortSuspect.dir;
      if (k === "staffType") return cmpKo(a.staffType, b.staffType, dir) || cmpKo(a.workplace, b.workplace, "asc");
      if (k === "workplace") return cmpKo(a.workplace, b.workplace, dir) || cmpKo(a.jobName, b.jobName, "asc");
      if (k === "jobName") return cmpKo(a.jobName, b.jobName, dir);
      if (k === "in") return compare(a.in, b.in, dir) || compare(a.diff, b.diff, "desc");
      if (k === "out") return compare(a.out, b.out, dir) || compare(a.diff, b.diff, "desc");
      if (k === "diff") return compare(a.diff, b.diff, dir) || cmpKo(a.workplace, b.workplace, "asc");
      return compare(a.diff, b.diff, "desc");
    });

    el.suspectStats.textContent = `결원 의심 ${rows.length}건`;

    el.suspectTableBody.innerHTML = "";
    const frag = document.createDocumentFragment();

    for (const r of rows) {
      const tr = document.createElement("tr");
      tr.className = "clickable";
      tr.dataset.workplaceKey = r.workplaceKey;
      tr.dataset.jobKey = r.jobKey;

      tr.innerHTML = `
        <td>${escapeHtml(r.staffType)}</td>
        <td><b>${escapeHtml(r.workplace)}</b></td>
        <td>${escapeHtml(r.jobName)}</td>
        <td class="numeric">${r.out}</td>
        <td class="numeric">${r.in}</td>
        <td class="numeric"><span class="pill red">+${r.diff}</span></td>
      `;

      tr.addEventListener("mouseenter", (e) => {
        const html = `
          <div><b>${escapeHtml(r.workplace)}</b></div>
          <div class="mini">[${escapeHtml(r.staffType)}] ${escapeHtml(r.jobName)}</div>
          <div class="mini" style="margin-top:6px;">
            전출 <b>${r.out}</b> · 전입 <b>${r.in}</b> · 결원 의심 <b>+${r.diff}</b>
          </div>
          <div class="mini muted" style="margin-top:6px;">클릭하면 2) 학교별 상세내역에서 명단을 확인할 수 있습니다.</div>
        `;
        showTooltip(html, e.clientX, e.clientY);
      });
      tr.addEventListener("mousemove", (e) => {
        if (el.tooltip.style.display === "block") showTooltip(el.tooltip.innerHTML, e.clientX, e.clientY);
      });
      tr.addEventListener("mouseleave", hideTooltip);

      tr.addEventListener("click", () => {
        state.selectedWorkplaceKey = r.workplaceKey;
        state.selectedJobKey = r.jobKey;

        renderWorkplaceSelect();
        renderJobSelect();
        renderWorkplaceDetail();

        el.jobSelect.value = r.jobKey;
        renderListsForSelectedJob();

        setTimeout(() => {
          const trs = [...el.jobTableBody.querySelectorAll("tr")];
          trs.forEach(t => t.classList.remove("is-selected"));
          const hit = trs.find(t => t.dataset.jobKey === r.jobKey);
          if (hit) hit.classList.add("is-selected");
        }, 0);

        document.getElementById("detailSection")?.scrollIntoView({ behavior:"smooth", block:"start" });
      });

      frag.appendChild(tr);
    }

    el.suspectTableBody.appendChild(frag);
    renderSortIndicators(document.getElementById("suspectTable"), state.sortSuspect);
  }

  // ---------------------------
  // File selection / drag & drop
  // ---------------------------
  function updateFileMeta() {
    const n = state.files.length;
    el.fileMeta.textContent = n ? `선택됨: ${n}개 · 총 ${bytesToHuman(state.files.reduce((a,f)=>a+f.size,0))}` : "";
    el.fileListSummary.textContent = `선택된 파일 (${n}개)`;
  }

  function renderFileList() {
    el.fileList.innerHTML = "";
    const frag = document.createDocumentFragment();
    for (const f of state.files) {
      const li = document.createElement("li");
      li.innerHTML = `
        <div class="wrap-any"><b>${escapeHtml(f.name)}</b></div>
        <div class="mini muted">${bytesToHuman(f.size)} · 수정 ${escapeHtml(new Date(f.lastModified).toLocaleString())}</div>
      `;
      frag.appendChild(li);
    }
    el.fileList.appendChild(frag);
  }

  function setFiles(files) {
    state.files = Array.from(files || []);
    updateFileMeta();
    renderFileList();
  }

  // ---------------------------
  // Dedupe helpers
  // ---------------------------
  function resetDedupe() {
    state.dedupe.strictSeen = new Set();
    state.dedupe.strictSkipped = 0;
    state.dedupe.looseMap = new Map();
    state.dedupe.looseCollisions = 0;
    state.dedupe.looseExamples = [];
  }

  function makeStrictKey(m) {
    // fileName 제외: 동일 레코드가 원본/정정 파일에 중복될 때 제거되도록
    return [
      m.sheetName,
      m.seq,
      m.staffType,
      m.jobName,
      m.name,
      m.inWorkplace,
      m.outWorkplace,
      m.note
    ].join("||");
  }

  function makeLooseKey(m) {
    return [
      m.sheetName,
      m.seq,
      m.staffType,
      m.jobName,
      m.name,
      m.inWorkplace,
      m.outWorkplace
    ].join("||");
  }

  function tryDedupe(m) {
    const strictKey = makeStrictKey(m);
    if (state.dedupe.strictSeen.has(strictKey)) {
      state.dedupe.strictSkipped++;
      return false;
    }
    state.dedupe.strictSeen.add(strictKey);

    const looseKey = makeLooseKey(m);
    const prev = state.dedupe.looseMap.get(looseKey);
    if (prev !== undefined && prev !== m.note) {
      state.dedupe.looseCollisions++;
      if (state.dedupe.looseExamples.length < 6) {
        state.dedupe.looseExamples.push({
          name: m.name,
          jobName: m.jobName,
          inWorkplace: m.inWorkplace,
          outWorkplace: m.outWorkplace,
          noteA: prev,
          noteB: m.note,
          sheetName: m.sheetName,
          seq: m.seq,
        });
      }
    } else if (prev === undefined) {
      state.dedupe.looseMap.set(looseKey, m.note);
    }

    return true;
  }

  // ---------------------------
  // Analysis
  // ---------------------------
  async function analyzeAllFiles() {
    clearLog();

    if (!state.files.length) {
      log("파일이 선택되지 않았습니다.");
      return;
    }

    state.heur = buildHeuristics();
    state.maskNames = !!el.optMaskNames.checked;
    el.optMaskNamesQuick.checked = state.maskNames;

    const ok = await ensureXLSX();
    setLibWarning(ok);
    if (!ok) {
      log("XLSX 라이브러리 없음 → 중단");
      return;
    }

    // manual mapping
    const seqIdxManual = colToIndex(el.colSeq.value);
    const nameIdxManual = colToIndex(el.colName.value);
    const jobIdxManual = colToIndex(el.colJob.value);
    const inIdxManual = colToIndex(el.colIn.value);
    const outIdxManual = colToIndex(el.colOut.value);
    const noteIdxManual = colToIndex(el.colNote.value);

    const badCols = [
      ["연번", seqIdxManual],
      ["성명", nameIdxManual],
      ["직종", jobIdxManual],
      ["전입", inIdxManual],
      ["전출", outIdxManual],
      ["비고", noteIdxManual],
    ].filter(([, idx]) => idx === null);

    if (badCols.length) {
      log("수동 컬럼 입력이 잘못되었습니다: " + badCols.map(([k]) => k).join(", "));
      return;
    }

    const autoOn = el.optAutoDetect.checked;
    const normalizeOn = el.optNormalize.checked;
    const prefixOn = el.optPrefixRegion.checked;
    const useSubject = el.optUseSubject.checked;

    // reset
    state.moves = [];
    state.workplaces.clear();
    state.workplaceOrder = [];
    state.analyzed = false;
    state.selectedWorkplaceKey = "";
    state.selectedJobKey = "ALL";
    state.regionTags.clear();
    state.stats = null;
    resetDedupe();

    el.analyzeBanner.style.display = "none";

    log(`집계 시작: 파일 ${state.files.length}개`);

    for (const file of state.files) {
      const regionTag = inferRegionTag(file.name);
      state.regionTags.set(file.name, regionTag);

      log(`\n[파일] ${file.name}${regionTag ? ` (태그: ${regionTag})` : ""}`);

      let wb = null;
      try {
        const buf = await file.arrayBuffer();
        wb = XLSX.read(buf, { type: "array" });
      } catch (err) {
        log(`  ⚠️ 파일 읽기 실패: ${err?.message || err}`);
        continue;
      }

      const sheetNames = wb.SheetNames.slice();
      log(`  시트 ${sheetNames.length}개: ${sheetNames.join(", ")}`);

      for (const sheetName of sheetNames) {
        const ws = wb.Sheets[sheetName];
        const rows = XLSX.utils.sheet_to_json(ws, { header: 1, defval: "" });
        if (!rows || rows.length < 3) continue;

        let layout = null;
        if (autoOn) {
          layout = detectLayoutPlus(rows, state.heur);
          if (layout) {
            log(`  - [${sheetName}] 자동감지 OK: seq=${layout.seqIdx>=0?indexToCol(layout.seqIdx):"(없음)"} name=${indexToCol(layout.nameIdx)} job=${layout.jobIdx>=0?indexToCol(layout.jobIdx):"(없음)"} in=${layout.inIdx>=0?indexToCol(layout.inIdx):"(없음)"} out=${layout.outIdx>=0?indexToCol(layout.outIdx):"(없음)"} note=${layout.noteIdx>=0?indexToCol(layout.noteIdx):"(없음)"} subj=${layout.subjectIdx>=0?indexToCol(layout.subjectIdx):"(없음)"} startRow=${layout.dataStart+1}`);
          } else {
            log(`  - [${sheetName}] 자동감지 실패 → 수동 매핑 사용`);
          }
        }

        const seqIdx = layout ? layout.seqIdx : seqIdxManual;
        const nameIdx = layout ? layout.nameIdx : nameIdxManual;
        const jobIdx = (layout && layout.jobIdx >= 0) ? layout.jobIdx : jobIdxManual;
        const inIdx = layout ? layout.inIdx : inIdxManual;
        const outIdx = layout ? layout.outIdx : outIdxManual;
        const noteIdx = (layout && layout.noteIdx >= 0) ? layout.noteIdx : noteIdxManual;
        const subjectIdx = layout ? layout.subjectIdx : -1;

        const dataStart = layout ? layout.dataStart : 0;

        // column stats for override decision
        const outStats = (outIdx >= 0) ? analyzeColumnStats(rows, dataStart, outIdx, state.heur, 200) : null;
        const noteStats = (noteIdx >= 0) ? analyzeColumnStats(rows, dataStart, noteIdx, state.heur, 200) : null;

        // note header key for "전소속" 판단
        let noteHeaderKey = "";
        if (layout && layout.fieldKeys && noteIdx >= 0) noteHeaderKey = layout.fieldKeys[noteIdx] || "";
        else {
          for (let rr = 0; rr < Math.min(rows.length, 8); rr++) {
            const k = cellKey((rows[rr] || [])[noteIdx]);
            if (k) { noteHeaderKey = k; break; }
          }
        }

        const useNoteAsOut =
          !!(outStats && noteStats) &&
          noteIdx >= 0 &&
          noteHeaderSuggestsPrevAffiliation(noteHeaderKey) &&
          outStats.uniqueCount <= 3 &&
          outStats.eduOfficeLikeRatio >= 0.55 &&
          outStats.schoolLikeRatio < 0.25 &&
          noteStats.schoolLikeRatio >= 0.25;

        if (useNoteAsOut) {
          log(`    ↳ 비고(전소속) 기반 '전출 근무지' 보정 적용(현소속 컬럼이 교육지원청 위주로 판단됨)`);
        }

        let recordCount = 0;

        for (let r = dataStart; r < rows.length; r++) {
          const row = rows[r] || [];

          // 데이터 행 판정
          if (seqIdx >= 0) {
            const seq = toIntLike(row[seqIdx]);
            if (seq === null) continue;
          } else {
            if (!state.heur.looksLikeName(row[nameIdx])) continue;
          }

          const seq = (seqIdx >= 0 ? (toIntLike(row[seqIdx]) ?? 0) : (r + 1));
          const name = normalizeSpaces(row[nameIdx]);
          if (!name) continue;

          let baseJob = (jobIdx >= 0 ? normalizeSpaces(row[jobIdx]) : "");
          if (!baseJob) baseJob = sheetName;

          const subject = (useSubject && subjectIdx >= 0) ? normalizeSpaces(row[subjectIdx]) : "";
          const jobName = subject ? `${baseJob}(${subject})` : baseJob;

          const staffType = detectStaffType(file.name, sheetName, jobName);
          const jobKey = `${staffType}||${jobName}`;

          const inPlaceRaw = (inIdx >= 0 ? row[inIdx] : "");
          const outPlaceRaw = (outIdx >= 0 ? row[outIdx] : "");
          const noteRaw = (noteIdx >= 0 ? row[noteIdx] : "");

          let inWorkplace = normalizeWorkplace(inPlaceRaw, regionTag, { normalizeOn, prefixOn });
          let outWorkplace = normalizeWorkplace(outPlaceRaw, regionTag, { normalizeOn, prefixOn });

          const note = normalizeSpaces(noteRaw);

          // out override from note
          if (useNoteAsOut && note) {
            const inferred = parsePlaceFromNote(note, state.heur);
            if (inferred) {
              // inferred에는 이미 지역이 들어있을 수도 있어서 prefix는 건드리지 않고 normalize만
              outWorkplace = normalizeWorkplace(inferred, regionTag, { normalizeOn, prefixOn });
            }
          }

          const move = {
            fileName: file.name,
            sheetName,
            regionTag,
            staffType,
            seq,
            name,
            jobName,
            jobKey,
            inWorkplace: inWorkplace || "",
            outWorkplace: outWorkplace || "",
            note,
            rowIndex: r + 1,
          };

          // ✅ 중복 제거(완전 동일)
          if (!tryDedupe(move)) continue;

          addMove(move);
          recordCount++;
        }

        if (recordCount) log(`    → [${sheetName}] 반영 ${recordCount}건`);
        else log(`    → [${sheetName}] 데이터 행을 찾지 못함(서식/헤더 확인 필요)`);
      }
    }

    // finalize
    state.workplaceOrder = [...state.workplaces.values()]
      .sort((a,b) => a.name.localeCompare(b.name, "ko"))
      .map(w => w.key);

    // global stats
    const totalRecords = state.moves.length;
    const totalIn = state.moves.reduce((acc,m)=>acc + (m.inWorkplace ? 1 : 0), 0);
    const totalOut = state.moves.reduce((acc,m)=>acc + (m.outWorkplace ? 1 : 0), 0);
    const netDiff = totalOut - totalIn;
    const onlyIn = state.moves.reduce((acc,m)=>acc + (m.inWorkplace && !m.outWorkplace ? 1 : 0), 0);
    const onlyOut = state.moves.reduce((acc,m)=>acc + (m.outWorkplace && !m.inWorkplace ? 1 : 0), 0);
    const both = state.moves.reduce((acc,m)=>acc + (m.inWorkplace && m.outWorkplace ? 1 : 0), 0);

    state.stats = { totalRecords, totalIn, totalOut, netDiff, onlyIn, onlyOut, both };

    state.analyzed = true;

    log(`\n집계 완료. 고주무관 천재.`);
    log(`- 총 이동 레코드(중복 제거 후): ${totalRecords}건`);
    log(`- 근무지(학교/부서) 수: ${state.workplaceOrder.length}개`);
    log(`- 중복(완전 동일) 제외: ${state.dedupe.strictSkipped}건`);
    if (state.dedupe.looseCollisions > 0) {
      log(`- 중복 의심(일부 값 상이): ${state.dedupe.looseCollisions}건`);
      for (const ex of state.dedupe.looseExamples) {
        log(`  · [의심] ${ex.sheetName} ${ex.seq} ${ex.name} / ${ex.jobName} / ${ex.outWorkplace}→${ex.inWorkplace} / note: "${ex.noteA}" vs "${ex.noteB}"`);
      }
    }

    // default selection
    state.selectedWorkplaceKey = state.workplaceOrder[0] || "";
    state.selectedJobKey = "ALL";

    // show sections
    el.detailSection.style.display = "";
    el.summarySection.style.display = "";
    el.suspectSection.style.display = "";

    renderAnalyzeBanner();

    renderWorkplaceSelect();
    renderJobSelect();
    renderWorkplaceDetail();
    renderSummary();
    renderSuspect();
  }

  // ---------------------------
  // CSV downloads (마스킹 상태 반영)
  // ---------------------------
  function downloadSummaryCsv() {
    if (!state.analyzed) return;
    const q = el.summarySearch.value || "";
    const mode = el.summaryFilter.value;

    const rows = [["근무지", "전출", "전입", "총 인사변동", "차이(전출-전입)"]];

    const list = [];
    for (const key of state.workplaceOrder) {
      const w = state.workplaces.get(key);
      if (!w) continue;
      if (q && !includesNorm(w.name, q)) continue;

      const inC = w.inMoves.length;
      const outC = w.outMoves.length;
      const diff = outC - inC;
      const total = inC + outC;

      if (mode === "outMore" && diff <= 0) continue;
      if (mode === "inMore" && diff >= 0) continue;
      if (mode === "equal" && diff !== 0) continue;

      list.push({ name: w.name, in: inC, out: outC, diff, total });
    }

    list.sort((a,b) => a.name.localeCompare(b.name, "ko"));
    for (const r of list) rows.push([r.name, r.out, r.in, r.total, r.diff]);

    downloadCsv(`근무지별_요약.csv`, rows);
    log("CSV 다운로드: 현재 요약");
  }

  function downloadSuspectCsv() {
    if (!state.analyzed) return;
    const q = el.suspectSearch.value || "";
    const type = el.suspectType.value;

    const rows = [["구분", "근무지", "직종(직급·과목)", "결원 의심(전출-전입)", "전출", "전입"]];
    const list = [];

    for (const key of state.workplaceOrder) {
      const w = state.workplaces.get(key);
      if (!w) continue;

      for (const [, j] of w.jobs) {
        const inC = j.inMoves.length;
        const outC = j.outMoves.length;
        const diff = outC - inC;
        if (diff <= 0) continue;

        const staffType = j.staffType;
        const jobName = j.jobName;

        if (type !== "ALL" && staffType !== type) continue;
        if (q) {
          const hay = `${w.name} ${jobName} ${staffType}`;
          if (!includesNorm(hay, q)) continue;
        }

        list.push({ staffType, workplace: w.name, jobName, diff, outC, inC });
      }
    }

    list.sort((a,b)=> (b.diff-a.diff) || a.workplace.localeCompare(b.workplace,"ko"));
    for (const r of list) rows.push([r.staffType, r.workplace, r.jobName, r.diff, r.outC, r.inC]);

    downloadCsv(`결원의심_목록.csv`, rows);
    log("CSV 다운로드: 결원 의심 목록");
  }

  function downloadDetailCsv() {
    if (!state.analyzed) return;

    const w = state.workplaces.get(state.selectedWorkplaceKey);
    if (!w) return;

    const jobKey = state.selectedJobKey;

    let inMoves = [];
    let outMoves = [];
    let jobLabel = "전체";

    if (jobKey === "ALL") {
      inMoves = w.inMoves.slice();
      outMoves = w.outMoves.slice();
    } else {
      const agg = w.jobs.get(jobKey);
      if (agg) {
        inMoves = agg.inMoves.slice();
        outMoves = agg.outMoves.slice();
        jobLabel = `[${agg.staffType}] ${agg.jobName}`;
      }
    }

    inMoves.sort((a,b)=>a.seq-b.seq);
    outMoves.sort((a,b)=>a.seq-b.seq);

    const rows = [["근무지", "직종(선택)", "구분", "성명", "전입(발령) 근무지", "전출(현소속) 근무지", "비고", "파일", "시트", "행"]];
    for (const m of outMoves) rows.push([w.name, jobLabel, "전출", displayName(m.name), m.inWorkplace, m.outWorkplace, m.note, m.fileName, m.sheetName, m.rowIndex]);
    for (const m of inMoves) rows.push([w.name, jobLabel, "전입", displayName(m.name), m.inWorkplace, m.outWorkplace, m.note, m.fileName, m.sheetName, m.rowIndex]);

    downloadCsv(`${w.name}_${jobLabel}_상세.csv`, rows);
    log("CSV 다운로드: 현재 상세");
  }

  // ---------------------------
  // Events: table header sorting
  // ---------------------------
  function bindSortableHeaders() {
    const summaryTable = document.getElementById("summaryTable");
    const suspectTable = document.getElementById("suspectTable");
    const jobTable = document.getElementById("jobTable");

    summaryTable.querySelectorAll("thead th.sortable").forEach(th => {
      th.addEventListener("click", () => {
        toggleSort(state.sortSummary, th.dataset.sort);
        renderSummary();
      });
    });

    suspectTable.querySelectorAll("thead th.sortable").forEach(th => {
      th.addEventListener("click", () => {
        toggleSort(state.sortSuspect, th.dataset.sort);
        renderSuspect();
      });
    });

    jobTable.querySelectorAll("thead th.sortable").forEach(th => {
      th.addEventListener("click", () => {
        toggleSort(state.sortJobs, th.dataset.sort);
        renderWorkplaceDetail();
      });
    });
  }

  // ---------------------------
  // Init / Events
  // ---------------------------
  function wire() {
    // file input
    el.fileInput.addEventListener("change", () => {
      const files = el.fileInput.files ? Array.from(el.fileInput.files) : [];
      setFiles(files);
      log(`파일 선택: ${files.length}개`);
    });

    // dropzone click -> open picker
    el.dropZone.addEventListener("click", () => el.fileInput.click());
    el.dropZone.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        el.fileInput.click();
      }
    });

    // drag & drop
    ["dragenter","dragover"].forEach(evt => {
      el.dropZone.addEventListener(evt, (e) => {
        e.preventDefault();
        e.stopPropagation();
        el.dropZone.classList.add("dragover");
      });
    });
    ["dragleave","drop"].forEach(evt => {
      el.dropZone.addEventListener(evt, (e) => {
        e.preventDefault();
        e.stopPropagation();
        el.dropZone.classList.remove("dragover");
      });
    });
    el.dropZone.addEventListener("drop", (e) => {
      const dt = e.dataTransfer;
      const files = dt && dt.files ? Array.from(dt.files) : [];
      const filtered = files.filter(f => /\.(xlsx|xls)$/i.test(f.name));
      setFiles(filtered);
      log(`드롭 업로드: ${filtered.length}개`);
    });

    // analyze
    el.btnAnalyze.addEventListener("click", () => {
      analyzeAllFiles().catch(err => {
        console.error(err);
        log("에러: " + (err?.message || err));
      });
    });

    // clear
    el.btnClear.addEventListener("click", () => {
      setFiles([]);
      state.analyzed = false;
      state.moves = [];
      state.workplaces.clear();
      state.workplaceOrder = [];
      state.selectedWorkplaceKey = "";
      state.selectedJobKey = "ALL";
      state.stats = null;
      resetDedupe();

      el.analyzeBanner.style.display = "none";

      el.detailSection.style.display = "none";
      el.summarySection.style.display = "none";
      el.suspectSection.style.display = "none";

      el.workplaceSearch.value = "";
      el.summarySearch.value = "";
      el.suspectSearch.value = "";

      clearLog();
      log("초기화 완료");
    });

    // name mask sync (advanced <-> quick)
    const syncMask = (checked) => {
      state.maskNames = !!checked;
      el.optMaskNames.checked = state.maskNames;
      el.optMaskNamesQuick.checked = state.maskNames;

      // 갱신
      if (state.analyzed) {
        renderAnalyzeBanner();
        renderWorkplaceDetail();
      }
    };
    el.optMaskNames.addEventListener("change", () => syncMask(el.optMaskNames.checked));
    el.optMaskNamesQuick.addEventListener("change", () => syncMask(el.optMaskNamesQuick.checked));

    // filters (debounced)
    el.workplaceSearch.addEventListener("input", debounce(() => {
      if (!state.analyzed) return;
      renderWorkplaceSelect();
    }, 140));

    el.workplaceSelect.addEventListener("change", () => {
      if (!state.analyzed) return;
      state.selectedWorkplaceKey = el.workplaceSelect.value;
      state.selectedJobKey = "ALL";
      renderJobSelect();
      renderWorkplaceDetail();
    });

    el.jobSelect.addEventListener("change", () => {
      if (!state.analyzed) return;
      state.selectedJobKey = el.jobSelect.value;
      renderListsForSelectedJob();

      const trs = [...el.jobTableBody.querySelectorAll("tr")];
      trs.forEach(t => t.classList.remove("is-selected"));
      const hit = trs.find(t => t.dataset.jobKey === state.selectedJobKey);
      if (hit) hit.classList.add("is-selected");
    });

    el.summarySearch.addEventListener("input", debounce(() => {
      if (!state.analyzed) return;
      renderSummary();
    }, 150));

    el.summaryFilter.addEventListener("change", () => {
      if (!state.analyzed) return;
      renderSummary();
    });

    el.suspectSearch.addEventListener("input", debounce(() => {
      if (!state.analyzed) return;
      renderSuspect();
    }, 150));

    el.suspectType.addEventListener("change", () => {
      if (!state.analyzed) return;
      renderSuspect();
    });

    // downloads
    el.btnDownloadSummary.addEventListener("click", downloadSummaryCsv);
    el.btnDownloadSuspect.addEventListener("click", downloadSuspectCsv);
    el.btnDownloadDetail.addEventListener("click", downloadDetailCsv);

    // tooltip hide
    window.addEventListener("scroll", hideTooltip, { passive:true });
    window.addEventListener("resize", hideTooltip, { passive:true });
    window.addEventListener("click", () => {
      if (el.tooltip.style.display === "block") hideTooltip();
    });

    bindSortableHeaders();
  }

  async function init() {
    log("페이지 로드 완료");
    log("엑셀을 업로드한 뒤 '발령 정보 집계하기'를 누르세요.");
    setFiles([]);

    const ok = await ensureXLSX();
    setLibWarning(ok);
  }

  document.addEventListener("DOMContentLoaded", () => {
    wire();
    init();
  });
})();
</script>

  
  
<script src="/static/disable-copy.js"></script>
<script src="/static/footer.js"></script>
<script src="/static/global-loader.js?v=1"></script>
  
</body>
</html>
