<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>학교별 전입·전출 인사발령자 명단 집계기</title>

  <style>
/* ===== 인라인 공통 스타일(style.css) ===== */
/* 251204목 공통 스타일 */

/* 박스 모델 통일 */
* { box-sizing: border-box; }

/* 기본 타이포 & 반응형 글자 크기 */
html { font-size: 16px; }
@media (max-width: 600px) { html { font-size: 15px; } }

body {
  margin: 0;
  padding: 0;
  background: #fff;
  color: #111;
  font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue",
    Arial, "Apple SD Gothic Neo", "Noto Sans KR", "맑은 고딕", sans-serif;
  line-height: 1.5;
  word-break: keep-all;
}

a { text-decoration: none; color: inherit; }

/* 전역 헤딩 계층 */
body h1 {
  font-size: 2.2rem;
  margin: 28px 0 18px;
  text-align: center !important;
  color: #111;
  font-weight: 700;
}
body h2 {
  font-size: 1.6rem;
  margin: 28px 0 12px;
  color: #222;
  font-weight: 700;
}
body h3 {
  font-size: 1.4rem;
  margin: 20px 0 10px;
  color: #222;
  font-weight: 600;
}
body h4 {
  font-size: 1.2rem;
  margin: 16px 0 8px;
  color: #333;
  font-weight: 600;
}

/* 본문 텍스트 */
body p, body li, body div, body span {
  font-size: 1.1rem;
  line-height: 1.65;
  color: #333;
}
body p { margin: 14px 0; }
body li { margin: 4px 0; line-height: 1.55; }
ul, ol { margin: 12px 0 18px; padding-left: 22px; }
body .muted { font-size: 0.95rem; color: #666; }

/* 예외 클래스(local-*) */
.local-h2 { font-size: 1.3rem !important; }
.local-h3 { font-size: 1.1rem !important; }
.local-large { font-size: 1.2rem !important; }
.local-small { font-size: 0.9rem !important; }
.local-tight { margin-bottom: 6px !important; }
.local-accent { color: #0051a8 !important; }

/* 레이아웃 공통 */
.shell { max-width: 880px; margin: 0 auto; }
main { margin: 0 auto; }
.sub { margin: 0.25rem 0 0; font-size: 1rem; color: #555; }

/* 상단 헤더 */
.site-header { background: #fff; border-bottom: 1px solid #e8e8ef; }
.site-header .shell { padding: 16px; }

/* 섹션 카드 */
.section {
  border: 1px solid #e5e5e5;
  border-radius: 12px;
  padding: 20px 22px;
  margin: 18px 0;
  background: #fff;
}

/* 내부 카드 */
.card {
  border: 1px solid #e5e5e5;
  border-radius: 10px;
  padding: 14px 16px;
  margin: 14px 0;
  background: #fafafa;
}

/* 레이아웃 유틸 */
.row { display: flex; align-items: center; gap: 8px; }
.row.between { justify-content: space-between; }
.row.gap { gap: 10px; }

.grid { display: grid; gap: 12px; }
.grid.two { grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); }
.grid.three { grid-template-columns: repeat(auto-fit, minmax(210px, 1fr)); }

@media (max-width: 640px) {
  .row { flex-wrap: wrap; align-items: flex-start; }
  .grid.two, .grid.three { grid-template-columns: 1fr; }
}

/* 버튼 스타일 */
.btn {
  display: inline-block;
  padding: 10px 16px;
  border-radius: 12px;
  border: 1px solid #222;
  font-weight: 600;
  font-size: 1rem;
  color: #111;
  background: #fff;
  cursor: pointer;
}
.btn + .btn { margin-left: 10px; }
.btn:hover { background: #f3f4f6; }

.btn.primary { background: #111; color: #fff; }
.btn.primary:hover { background: #000; }

.btn.ghost { background: #f9fafb; border-color: #d4d4d8; }
.btn.ghost:hover { background: #eef2ff; }

.btn-lightgrey {
  padding: 8px 14px;
  border-radius: 10px;
  background: #f3f4f6;
  border: 1px solid #d4d4d8;
}
.row .btn + .btn { margin-left: 0; }

/* 입력 UI */
input, select, button, textarea { font: inherit; }

input[type="text"],
input[type="number"],
input[type="time"],
input[type="date"],
select,
textarea {
  padding: 10px 12px;
  border: 1px solid #d9d9e3;
  border-radius: 12px;
  background: #f9fafb;
  outline: none;
  min-width: 0;
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.02);
}

input:focus, select:focus, textarea:focus {
  border-color: #b4b4d0;
  box-shadow: 0 0 0 2px rgba(180, 180, 208, 0.25);
  background: #fff;
}

input:disabled, select:disabled, textarea:disabled {
  background: #f6f7fb;
  color: #888;
}

.numeric { text-align: right; }

/* 구분선(hr) */
hr {
  border-top: 1px solid #ddd;
  margin: 26px 0;
  opacity: 0.9;
}
body h2 + hr { margin-top: 10px !important; }

/* 테이블 스타일 */
.table-wrap,
.table-wrapper {
  width: 100%;
  max-width: 100%;
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
  margin: 12px 0;
  padding-bottom: 6px;
}

.table-wrap table,
.table-wrapper table {
  min-width: 800px;
  border-collapse: collapse;
}

.sheetlike {
  width: 100%;
  border-collapse: collapse;
  font-size: 1rem;
  background: #fff;
}

.sheetlike th,
.sheetlike td {
  border: 1px solid #e5e7eb;
  padding: 8px 10px;
}

.sheetlike th {
  background: #f9fafb;
  font-weight: 600;
}

/* main 컨테이너 */
.container {
  max-width: 880px;
  margin: 0 auto;
  padding: 24px 16px;
}

/* index 서브타이틀 */
.subtitle {
  margin: 0 0 12px;
  color: #444;
  font-size: 0.98rem;
  text-align: center;
}

/* 업무 경감 프로그램 카드형 UI */
.tool-card {
  border: 1px solid #e5e5e5;
  border-radius: 14px;
  padding: 18px 20px;
  background: #fff;
  margin: 18px 0;
}

.tool-head { margin-bottom: 10px; }
.tool-title {
  font-size: 1.2rem;
  font-weight: 700;
  margin: 0 0 4px;
  color: #111;
}
.tool-sub {
  font-size: 0.95rem;
  color: #555;
  margin: 0;
}

/* 푸터 */
.site-footer {
  margin-top: 64px;
  padding: 24px 16px;
  border-top: 1px solid #e5e7eb;
  background: #fafafa;
  color: #6b7280;
  font-size: 0.875rem;
}
.site-footer .shell {
  max-width: 1024px;
  margin: 0 auto;
  text-align: center;
  line-height: 1.6;
}

/* 카드/섹션 내부에서 넘침 차단(공통) */
.section,
.tool-card,
.tool-shot {
  overflow-x: hidden;
}

/* ===== 페이지 전용 추가 스타일 ===== */

.card-head{
  display:flex;
  align-items:flex-start;
  justify-content:space-between;
  gap: 12px;
  flex-wrap: wrap;
}
.card-title { margin: 0; }

.card-actions{
  display:flex;
  gap: 10px;
  flex-wrap: wrap;
  align-items: center;
  justify-content: flex-end;
  min-width: 0;
  max-width: 100%;
  flex: 1 1 420px;
}
.card-actions > * { min-width: 0; }

@media (max-width: 640px) {
  .card-actions { justify-content: flex-start; width: 100%; }
}

/* 파일 input 숨김 */
#fileInput { display:none; }

/* 클릭 가능한 행 */
tr.clickable:hover { background:#f3f4f6; cursor:pointer; }

/* 선택 강조 */
tr.is-selected { outline: 2px solid rgba(0,0,0,0.18); outline-offset: -2px; }

/* 스크롤 컨테이너 + 틀고정 */
.sticky-wrap{
  max-height: 520px;
  overflow: auto;
  border-radius: 12px;
}
table.sticky-table thead th{
  position: sticky;
  top: 0;
  z-index: 5;
  background: #f9fafb;
  box-shadow: 0 1px 0 #e5e7eb;
}
table.sticky-table th:first-child,
table.sticky-table td:first-child{
  position: sticky;
  left: 0;
  z-index: 4;
  background: #fff;
  box-shadow: 1px 0 0 #e5e7eb;
}
table.sticky-table thead th:first-child{
  z-index: 6;
  background: #f9fafb;
}
.table-wrap table { min-width: 760px; }
@media (max-width: 640px){
  .sticky-wrap { max-height: 460px; }
}

/* 배지 */
.pill{
  display:inline-block;
  padding: 2px 10px;
  border-radius: 999px;
  border: 1px solid #d4d4d8;
  background: #f9fafb;
  font-size: 0.9rem;
  line-height: 1.4;
  white-space: nowrap;
}
.pill.red { border-color:#fecaca; background:#fef2f2; color:#991b1b; }
.pill.blue { border-color:#bfdbfe; background:#eff6ff; color:#1d4ed8; }
.pill.gray { border-color:#e5e7eb; background:#f9fafb; color:#6b7280; }

/* 직군 색상(분리 표시) */
.pill.amber { border-color:#fde68a; background:#fffbeb; color:#92400e; }   /* 지방공무원 */
.pill.purple{ border-color:#ddd6fe; background:#f5f3ff; color:#5b21b6; }   /* 교육공무원 */
.pill.green { border-color:#a7f3d0; background:#ecfdf5; color:#065f46; }   /* 교육공무직 */

.diff.pos{ color:#b91c1c; font-weight:700; }
.diff.neg{ color:#1d4ed8; font-weight:700; }
.diff.zero{ color:#6b7280; }

.kbd{
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 0.95rem;
  border: 1px solid #e5e7eb;
  background: #f9fafb;
  padding: 2px 6px;
  border-radius: 6px;
}

/* 리스트 */
.clean-list { list-style: none; margin: 0; padding: 0; }
.clean-list li { margin: 8px 0; }
.clean-list .who { font-weight: 700; color: #111; }
.clean-list .meta { display:block; color:#555; font-size: 0.95rem; margin-top:2px; }

.move-item{
  padding: 8px 8px;
  border-radius: 10px;
  cursor: help;
}
.move-item:hover{
  background: #f3f4f6;
}

/* details(접기/펼치기) */
.shot-details{
  margin-top: 12px;
  border: 1px solid #e5e5e5;
  border-radius: 12px;
  background: #fafafa;
  padding: 10px 12px;
}
.shot-summary{
  cursor: pointer;
  font-weight: 700;
  color: #111;
  font-size: 0.98rem;
  list-style: none;
}
.shot-summary::-webkit-details-marker{ display:none; }
.shot-summary::before{ content:"▸ "; }
.shot-details[open] .shot-summary::before{ content:"▾ "; }
.shot-summary:hover{ text-decoration: underline; }

/* 직종 그룹(details) */
details.job-group{
  border: 1px solid #e5e7eb;
  border-radius: 12px;
  background: #fff;
  margin: 10px 0;
  overflow: hidden;
}
details.job-group summary{
  padding: 10px 12px;
  cursor: pointer;
  font-weight: 700;
  list-style: none;
  display:flex;
  align-items:center;
  justify-content: space-between;
  gap: 10px;
}
details.job-group summary::-webkit-details-marker{ display:none; }
details.job-group .group-body{ padding: 0 12px 12px; }

/* ✅ 로그: 기본 숨김(details) */
details.log-details summary{
  cursor: pointer;
  font-weight: 800;
  color: #111;
  font-size: 1.05rem;
  list-style: none;
}
details.log-details summary::-webkit-details-marker{ display:none; }
details.log-details summary::before{ content:"▸ "; }
details.log-details[open] summary::before{ content:"▾ "; }

/* ==========================
   ✅ 커스텀 드롭다운(줄바꿈)
   ========================== */
#detailSection { overflow: visible; }
.native-select { display: none !important; }

.cselect{
  position: relative;
  flex: 1 1 320px;
  min-width: 220px;
  max-width: 100%;
}
@media (max-width: 640px){ .cselect{ flex-basis: 100%; } }

.cselect-btn{
  width: 100%;
  text-align: left;
  cursor: pointer;

  padding: 10px 12px;
  padding-right: 34px;
  border: 1px solid #d9d9e3;
  border-radius: 12px;
  background: #f9fafb;
  box-shadow: 0 0 0 1px rgba(0,0,0,0.02);

  white-space: normal;
  overflow-wrap: anywhere;
  word-break: break-word;
  line-height: 1.35;
}
.cselect-btn:focus{
  border-color: #b4b4d0;
  box-shadow: 0 0 0 2px rgba(180, 180, 208, 0.25);
  background: #fff;
  outline: none;
}

.cselect-btn::after{
  content: "▾";
  position: absolute;
  right: 12px;
  top: 50%;
  transform: translateY(-50%);
  color: #666;
  font-size: 0.95rem;
}
.cselect.open .cselect-btn::after{ content: "▴"; }

.cselect-list{
  position: absolute;
  left: 0;
  right: 0;
  top: calc(100% + 6px);
  z-index: 60;

  background: #fff;
  border: 1px solid #e5e7eb;
  border-radius: 12px;
  padding: 6px;
  box-shadow: 0 10px 30px rgba(0,0,0,0.12);

  max-height: 360px;
  overflow: auto;
}

.cselect-item{
  padding: 8px 10px;
  border-radius: 10px;
  cursor: pointer;

  white-space: normal;
  overflow-wrap: anywhere;
  word-break: break-word;
  line-height: 1.35;
}
.cselect-item:hover{ background: #f3f4f6; }
.cselect-item.is-selected{ background: #eef2ff; }
.cselect-item.is-disabled{ opacity: 0.5; cursor: not-allowed; }

/* ==========================
   ✅ Hover Tooltip
   ========================== */
.hover-tip{
  position: fixed;
  z-index: 99999;
  max-width: 380px;
  padding: 10px 12px;
  border-radius: 12px;
  border: 1px solid rgba(0,0,0,0.12);
  background: #111;
  color: #fff;
  box-shadow: 0 16px 40px rgba(0,0,0,0.25);
  font-size: 0.95rem;
  line-height: 1.45;
  pointer-events: none;
  white-space: normal;
  overflow-wrap: anywhere;
}
.hover-tip .small{ font-size: 0.85rem; opacity: 0.9; }
.hover-tip .mono{
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 0.86rem;
  opacity: 0.95;
}

/* 정렬 컨트롤 라벨 */
.ctrl-label{
  font-size: 0.95rem;
  color: #555;
  white-space: nowrap;
}
  </style>
</head>

<body>
  <header class="site-header">
    <div class="shell">
      <h1>학교별 전입·전출 인사발령자 명단 집계기</h1>
      <p class="subtitle">
        엑셀(여러 파일 가능)을 업로드하면 <span class="kbd">학교(부서)</span> 기준으로
        <b>전입(도착)</b> / <b>전출·퇴직(출발)</b> 명단을 직종별로 모아 보여줍니다.
      </p>
      <p class="subtitle" style="margin-top:-6px;">
        ※ “결원 의심(정원 확인 필요)”는 <b>직종별</b>로 <b>전출·퇴직 &gt; 전입</b>인 경우를 합산하며,
        <b>지방공무원/교육공무원/교육공무직</b>으로 분리 집계합니다.
      </p>
    </div>
  </header>

  <main class="container">
    <!-- 1) 업로드 -->
    <section class="tool-card">
      <div class="tool-head card-head">
        <div>
          <h2 class="card-title">1) 엑셀 업로드</h2>
          <p class="tool-sub">
            여러 파일을 한 번에 올릴 수 있습니다. (예: [강릉], [원주] 파일들 동시 선택)
          </p>
        </div>

        <div class="card-actions">
          <label class="btn" for="fileInput">파일 선택(복수)</label>
          <input id="fileInput" type="file" accept=".xlsx,.xls" multiple />
          <button id="btnAnalyze" class="btn primary">분석 실행</button>
          <button id="btnClear" class="btn ghost">초기화</button>
        </div>
      </div>

      <hr/>

      <div class="grid two">
        <div class="card">
          <p id="fileMeta" class="muted" style="margin:0;">아직 파일이 없습니다.</p>
          <div id="fileList" class="muted" style="margin-top:10px;"></div>
          <p id="libWarn" class="note muted" style="display:none; margin:10px 0 0;"></p>

          <div class="help muted" style="margin-top:10px;">
            <ul>
              <li>데이터 행은 기본적으로 <span class="kbd">연번/순번/번호</span>가 숫자인 행만 사용합니다.</li>
              <li>학교명에 줄바꿈/여러 공백이 들어간 경우 <span class="kbd">학교명 공백/개행 정리</span> 옵션을 켜세요.</li>
              <li>파일명이 <span class="kbd">[강릉]</span>처럼 시작하면 자동으로 “구분(교육지원청)”으로 사용합니다.</li>
            </ul>
          </div>
        </div>

        <div>
          <details class="shot-details">
            <summary class="shot-summary">고급 설정: 자동 감지 / 컬럼 매핑 / 학교키 / 직군(지방·교육·공무직) 분류</summary>

            <div class="card" style="margin-top:10px;">
              <div class="grid two">
                <div class="field">
                  <label class="row gap" style="margin-top:6px;">
                    <input id="optAutoDetect" type="checkbox" checked />
                    <span class="muted"><b>자동 컬럼 감지(추천)</b> · 시트마다 헤더 위치가 달라도 찾아봅니다</span>
                  </label>
                  <p class="note" style="margin-top:8px;">
                    ※ 자동 감지는 “성명/번호/직종/부서/비고/임용사항/현직” 패턴으로 잡습니다.
                    실패하면 아래 수동 매핑을 사용합니다.
                  </p>
                </div>

                <div class="field">
                  <label class="row gap" style="margin-top:6px;">
                    <input id="optNormalize" type="checkbox" checked />
                    <span class="muted">학교명 공백/개행 정리</span>
                  </label>
                </div>

                <div class="field" style="grid-column: 1 / -1;">
                  <label class="row gap" style="margin-top:6px;">
                    <input id="optSchoolKeyPrefix" type="checkbox" checked />
                    <span class="muted">
                      <b>학교키에 파일 구분([강릉] 등) 포함</b> · 동일 학교명이 다른 지역에 있을 때 섞이는 것을 방지
                    </span>
                  </label>
                  <p class="note" style="margin-top:8px;">
                    ※ 여러 교육지원청 파일을 같이 올릴 때는 켜는 것을 권장합니다.
                    (파일명에 [ ] 구분자가 없으면 자동으로 비워둡니다.)
                  </p>
                </div>
              </div>

              <hr style="margin:16px 0;"/>

              <p class="muted" style="margin-top:0;">
                수동 매핑(모든 시트에 동일 적용). 기본(원주형) 매핑:
                <span class="kbd">A=연번</span>, <span class="kbd">B=성명</span>, <span class="kbd">C=직종</span>,
                <span class="kbd">D=전입(부서)</span>, <span class="kbd">F=전출/퇴직(부서)</span>, <span class="kbd">H=비고</span>
              </p>

              <div class="grid three">
                <div class="field">
                  <label class="muted">연번(순번) 컬럼</label>
                  <input id="colSeq" type="text" value="A" maxlength="3" />
                </div>
                <div class="field">
                  <label class="muted">성명 컬럼</label>
                  <input id="colName" type="text" value="B" maxlength="3" />
                </div>
                <div class="field">
                  <label class="muted">직종 컬럼(한 시트에 직종이 섞여있을 때)</label>
                  <input id="colJob" type="text" value="C" maxlength="3" />
                </div>
                <div class="field">
                  <label class="muted">전입(도착) ‘부서/학교’ 컬럼</label>
                  <input id="colIn" type="text" value="D" maxlength="3" />
                </div>
                <div class="field">
                  <label class="muted">전출/퇴직(출발) ‘부서/학교’ 컬럼</label>
                  <input id="colOut" type="text" value="F" maxlength="3" />
                </div>
                <div class="field">
                  <label class="muted">비고 컬럼</label>
                  <input id="colNote" type="text" value="H" maxlength="3" />
                </div>
              </div>

              <hr style="margin:16px 0;"/>

              <div class="field">
                <label class="muted"><b>직군 분류 규칙(선택)</b></label>
                <p class="note" style="margin:8px 0 8px;">
                  “결원 의심”을 <b>지방공무원/교육공무원/교육공무직</b>으로 분리하기 위한 규칙입니다.
                  규칙이 비어 있으면 <b>기본 휴리스틱(추정)</b>으로 분류합니다.
                  부분일치는 <span class="kbd">*</span>를 사용하세요. (예: <span class="kbd">*교사*</span>)
                </p>

                <textarea id="typeRules" rows="6" placeholder="# 예시
지방공무원 = *주무관*, *행정직*, *시설직*, *공업직*, *운전직*
교육공무원 = *교장*, *교감*, *교사*, *사서교사*, *보건교사*
교육공무직 = *실무사*, *전담사*, *조리*, *영양사*, *교무행정사*, *늘봄*, *돌봄*"></textarea>

                <div class="row gap" style="margin-top:10px; flex-wrap:wrap;">
                  <button id="btnApplyTypeRules" class="btn btn-lightgrey">직군 규칙 적용</button>
                  <button id="btnFillTypeSample" class="btn ghost">예시 채우기</button>
                  <span id="typeHint" class="muted"></span>
                </div>
              </div>
            </div>
          </details>
        </div>
      </div>
    </section>

    <!-- 2) 학교별 요약 -->
    <section class="tool-card" id="schoolSummarySection" style="display:none;">
      <div class="tool-head card-head">
        <div>
          <h2 class="card-title">2) 학교(부서)별 요약</h2>
          <p class="tool-sub">
            학교 기준으로 모든 직종을 합산해 요약합니다. 행 클릭 → 아래 “학교 상세”로 이동합니다.
          </p>
        </div>
        <div class="card-actions">
          <button id="btnDownloadSchoolSummary" class="btn btn-lightgrey">현재 요약 CSV</button>
        </div>
      </div>

      <hr/>

      <div class="row gap" style="margin:0 0 10px; flex-wrap:wrap;">
        <input id="schoolFilter" type="text" placeholder="학교/부서/구분 검색 (예: 반곡중, 강릉)" />
        <span class="ctrl-label">보기</span>
        <select id="schoolModeSelect">
          <option value="suspect" selected>결원 의심(직종별 전출&gt;전입 존재)</option>
          <option value="all">전체</option>
          <option value="surplus">순증가(직종별 전입&gt;전출 존재)</option>
          <option value="mixed">혼재(결원 의심+순증가 모두 존재)</option>
          <option value="balanced">완전 균형(모든 직종 전입=전출)</option>
        </select>

        <span class="ctrl-label">정렬</span>
        <select id="schoolSortKey">
          <option value="shortageTotal" selected>결원 의심(총)</option>
          <option value="shortage_local">결원 의심(지방공무원)</option>
          <option value="shortage_edu">결원 의심(교육공무원)</option>
          <option value="shortage_worker">결원 의심(교육공무직)</option>
          <option value="surplusTotal">순증가(총)</option>
          <option value="netDiff">총차이(전출-전입)</option>
          <option value="outTotal">전출</option>
          <option value="inTotal">전입</option>
          <option value="jobCount">직종수</option>
          <option value="region">구분</option>
          <option value="school">학교명</option>
        </select>
        <select id="schoolSortDir">
          <option value="desc" selected>내림차순</option>
          <option value="asc">오름차순</option>
        </select>

        <span id="schoolStats" class="muted"></span>
      </div>

      <div class="table-wrap sticky-wrap">
        <table class="sheetlike sticky-table" id="schoolSummaryTable">
          <thead>
            <tr>
              <th>구분</th>
              <th>학교(부서)</th>
              <th class="numeric">전출</th>
              <th class="numeric">전입</th>
              <th class="numeric">결원 의심(직군별)</th>
              <th class="numeric">순증가(직군별)</th>
              <th class="numeric">총차이(전출-전입)</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>

      <p class="muted">
        ※ “결원 의심/순증가”는 <b>직종별</b> 차이를 합산한 값입니다.
        (직군 분리는 규칙 또는 기본 추정 로직으로 분류됩니다.)
      </p>
    </section>

    <!-- 3) 전체 결원 의심(학교-직종) 목록 -->
    <section class="tool-card" id="suspectSection" style="display:none;">
      <div class="tool-head card-head">
        <div>
          <h2 class="card-title">3) 전체 결원 의심(학교-직종) 목록</h2>
          <p class="tool-sub">모든 학교의 “직종별 전출&gt;전입”만 모아 빠르게 스캔합니다. 행 클릭 → 해당 학교/직종 상세로 이동합니다.</p>
        </div>
        <div class="card-actions">
          <input id="suspectFilter" type="text" placeholder="학교/직종/직군/구분 검색" />

          <span class="ctrl-label">정렬</span>
          <select id="suspectSortKey">
            <option value="diff" selected>결원 의심(전출-전입)</option>
            <option value="outC">전출</option>
            <option value="inC">전입</option>
            <option value="region">구분</option>
            <option value="school">학교</option>
            <option value="staffType">직군</option>
            <option value="jobName">직종</option>
          </select>
          <select id="suspectSortDir">
            <option value="desc" selected>내림차순</option>
            <option value="asc">오름차순</option>
          </select>

          <button id="btnDownloadSuspect" class="btn btn-lightgrey">현재 목록 CSV</button>
        </div>
      </div>

      <hr/>

      <p id="suspectStats" class="muted" style="margin-top:0;"></p>

      <div class="table-wrap sticky-wrap">
        <table class="sheetlike sticky-table" id="suspectTable">
          <thead>
            <tr>
              <th>구분</th>
              <th>학교(부서)</th>
              <th>직군</th>
              <th>직종</th>
              <th class="numeric">전출</th>
              <th class="numeric">전입</th>
              <th class="numeric">결원 의심(전출-전입)</th>
              <th class="numeric">전입없음</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </section>

    <!-- 4) 상세(학교 → 직종 → 명단) -->
    <section class="tool-card" id="detailSection" style="display:none;">
      <div class="tool-head card-head">
        <div>
          <h2 class="card-title">4) 학교 상세</h2>
          <p class="tool-sub">학교를 고른 뒤, 직종(전체/개별)을 선택하면 전입·전출 명단을 확인할 수 있습니다. (행/명단에 마우스를 올리면 툴팁이 표시됩니다.)</p>
        </div>

        <div class="card-actions">
          <span class="ctrl-label">학교</span>
          <select id="schoolSelect"></select>

          <span class="ctrl-label">직종</span>
          <select id="jobSelect"></select>

          <button id="btnDownloadSchoolJobs" class="btn btn-lightgrey">직종표 CSV</button>
          <button id="btnDownloadSchoolMoves" class="btn btn-lightgrey">명단 CSV</button>
        </div>
      </div>

      <hr/>

      <div class="grid two">
        <div>
          <div class="row gap" style="margin-bottom:10px; flex-wrap:wrap;">
            <input id="jobFilter" type="text" placeholder="직종 검색 (예: 조리, 교무)" />
            <span class="ctrl-label">보기</span>
            <select id="jobModeSelect">
              <option value="suspect" selected>결원 의심(전출&gt;전입)</option>
              <option value="all">전체</option>
              <option value="surplus">순증가(전입&gt;전출)</option>
              <option value="balanced">균형(전입=전출)</option>
            </select>

            <span class="ctrl-label">정렬</span>
            <select id="jobSortKey">
              <option value="diff" selected>차이(전출-전입)</option>
              <option value="outC">전출</option>
              <option value="inC">전입</option>
              <option value="staffType">직군</option>
              <option value="jobName">직종</option>
            </select>
            <select id="jobSortDir">
              <option value="desc" selected>내림차순</option>
              <option value="asc">오름차순</option>
            </select>
          </div>

          <p id="jobStats" class="muted" style="margin:0 0 10px;"></p>

          <div class="table-wrap sticky-wrap">
            <table class="sheetlike sticky-table" id="jobTable">
              <thead>
                <tr>
                  <th>직종</th>
                  <th>직군</th>
                  <th class="numeric">전출</th>
                  <th class="numeric">전입</th>
                  <th class="numeric">차이(전출-전입)</th>
                  <th class="numeric">전입없음</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>

          <p class="muted">※ 직종 행 클릭 → 오른쪽 명단이 해당 직종으로 바뀝니다.</p>
        </div>

        <div class="card" id="moveDetailCard">
          <h3 class="local-h3 local-tight">명단</h3>
          <p class="muted" style="margin-top:0;">분석 후 학교를 선택하세요.</p>
        </div>
      </div>
    </section>

    <!-- ✅ 로그(기본 숨김) -->
    <details class="tool-card log-details">
      <summary>처리 로그 (원할 때만 펼치기)</summary>
      <div style="margin-top:12px;">
        <p class="tool-sub">엑셀 파서 로드/분석 진행 상황을 확인할 수 있습니다.</p>
        <hr style="margin:14px 0;"/>
        <pre id="logBox" class="muted"></pre>
      </div>
    </details>
  </main>

  <footer class="site-footer">
    <div class="shell">
      <p>
        ※ 이 도구는 “전출·퇴직 &amp; 전입” 집계로 <b>정원 확인 필요 후보</b>를 빠르게 파악하기 위한 화면입니다.
        최종 결원 여부는 정원/배치 기준 확인이 필요합니다.
      </p>
    </div>
  </footer>

  <!-- Hover Tooltip -->
  <div id="hoverTip" class="hover-tip" hidden></div>

<script>
(() => {
  "use strict";

  // ---------------------------
  // DOM helpers
  // ---------------------------
  const $ = (sel) => document.querySelector(sel);

  const el = {
    fileInput: $("#fileInput"),
    fileMeta: $("#fileMeta"),
    fileList: $("#fileList"),
    btnAnalyze: $("#btnAnalyze"),
    btnClear: $("#btnClear"),
    libWarn: $("#libWarn"),

    optAutoDetect: $("#optAutoDetect"),
    optNormalize: $("#optNormalize"),
    optSchoolKeyPrefix: $("#optSchoolKeyPrefix"),

    colSeq: $("#colSeq"),
    colName: $("#colName"),
    colJob: $("#colJob"),
    colIn: $("#colIn"),
    colOut: $("#colOut"),
    colNote: $("#colNote"),

    typeRules: $("#typeRules"),
    btnApplyTypeRules: $("#btnApplyTypeRules"),
    btnFillTypeSample: $("#btnFillTypeSample"),
    typeHint: $("#typeHint"),

    schoolSummarySection: $("#schoolSummarySection"),
    schoolFilter: $("#schoolFilter"),
    schoolModeSelect: $("#schoolModeSelect"),
    schoolSortKey: $("#schoolSortKey"),
    schoolSortDir: $("#schoolSortDir"),
    schoolStats: $("#schoolStats"),
    schoolSummaryBody: $("#schoolSummaryTable tbody"),
    btnDownloadSchoolSummary: $("#btnDownloadSchoolSummary"),

    suspectSection: $("#suspectSection"),
    suspectFilter: $("#suspectFilter"),
    suspectSortKey: $("#suspectSortKey"),
    suspectSortDir: $("#suspectSortDir"),
    suspectStats: $("#suspectStats"),
    suspectTableBody: $("#suspectTable tbody"),
    btnDownloadSuspect: $("#btnDownloadSuspect"),

    detailSection: $("#detailSection"),
    schoolSelect: $("#schoolSelect"),
    jobSelect: $("#jobSelect"),

    jobFilter: $("#jobFilter"),
    jobModeSelect: $("#jobModeSelect"),
    jobSortKey: $("#jobSortKey"),
    jobSortDir: $("#jobSortDir"),
    jobStats: $("#jobStats"),
    jobTableBody: $("#jobTable tbody"),

    moveDetailCard: $("#moveDetailCard"),
    btnDownloadSchoolJobs: $("#btnDownloadSchoolJobs"),
    btnDownloadSchoolMoves: $("#btnDownloadSchoolMoves"),

    logBox: $("#logBox"),
    hoverTip: $("#hoverTip"),
  };

  // ---------------------------
  // Constants
  // ---------------------------
  const STAFF_TYPES = ["지방공무원", "교육공무원", "교육공무직"];
  const STAFF_TYPE_META = {
    "지방공무원": { pillClass: "amber", short: "지방" },
    "교육공무원": { pillClass: "purple", short: "교육" },
    "교육공무직": { pillClass: "green", short: "공무직" },
  };

  // ---------------------------
  // State
  // ---------------------------
  const state = {
    files: [],
    analyzed: false,

    // moves: {id, staffType, fileName, region, sheetName, jobName, seq, name, inSchoolRaw, outSchoolRaw, inSchool, outSchool, note, rowIndex}
    moves: [],
    moveIdCounter: 0,
    moveById: new Map(),

    // schools: key -> record
    // record: { key, school, regions:Set, inMoves:[], outMoves:[], byJob:Map(job->info), summary }
    schools: new Map(),
    schoolOrder: [],

    selectedSchoolKey: "",
    selectedJob: "__ALL__", // "__ALL__" or jobName

    // parsed type rules
    typeRulesParsed: null, // { groups: [{name, patterns:[]}, ...] }

    // CSV export buffers
    lastSchoolSummaryList: [],
    lastSuspectList: [],
    lastSchoolJobList: [],
    lastMoveList: [],
  };

  // ---------------------------
  // Logging
  // ---------------------------
  function log(line) {
    const ts = new Date().toLocaleTimeString();
    el.logBox.textContent += `[${ts}] ${line}\n`;
    el.logBox.scrollTop = el.logBox.scrollHeight;
  }
  function clearLog() { el.logBox.textContent = ""; }

  // ---------------------------
  // Tooltip
  // ---------------------------
  let tipHideTimer = null;

  function escapeHtml(s) {
    return String(s ?? "")
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/\"/g, "&quot;")
      .replace(/'/g, "&#039;");
  }

  function showTip(html, x, y, autoHideMs = 0) {
    if (!el.hoverTip) return;
    el.hoverTip.innerHTML = html;
    el.hoverTip.hidden = false;
    moveTip(x, y);

    if (tipHideTimer) clearTimeout(tipHideTimer);
    if (autoHideMs && autoHideMs > 0) {
      tipHideTimer = setTimeout(() => {
        hideTip();
      }, autoHideMs);
    }
  }

  function moveTip(x, y) {
    if (!el.hoverTip || el.hoverTip.hidden) return;

    const pad = 12;
    const offset = 14;

    // 일단 배치
    let left = x + offset;
    let top = y + offset;

    // 크기 측정(표시된 상태여야 getBoundingClientRect가 의미있음)
    const rect = el.hoverTip.getBoundingClientRect();

    // 오른쪽 벗어나면 반대쪽
    if (left + rect.width + pad > window.innerWidth) {
      left = x - rect.width - offset;
    }
    // 아래 벗어나면 위로
    if (top + rect.height + pad > window.innerHeight) {
      top = y - rect.height - offset;
    }

    // 좌/상단 최소
    left = Math.max(pad, left);
    top = Math.max(pad, top);

    el.hoverTip.style.left = left + "px";
    el.hoverTip.style.top = top + "px";
  }

  function hideTip() {
    if (!el.hoverTip) return;
    el.hoverTip.hidden = true;
    if (tipHideTimer) clearTimeout(tipHideTimer);
    tipHideTimer = null;
  }

  // ---------------------------
  // Utilities
  // ---------------------------
  function bytesToHuman(bytes) {
    if (!Number.isFinite(bytes)) return "-";
    const units = ["B","KB","MB","GB"];
    let v = bytes, i = 0;
    while (v >= 1024 && i < units.length - 1) { v /= 1024; i++; }
    return `${v.toFixed(i === 0 ? 0 : 1)} ${units[i]}`;
  }

  function colToIndex(col) {
    const s = String(col ?? "").trim().toUpperCase();
    if (!s) return null;
    let n = 0;
    for (let i = 0; i < s.length; i++) {
      const code = s.charCodeAt(i);
      if (code < 65 || code > 90) return null;
      n = n * 26 + (code - 64);
    }
    return n - 1;
  }

  function indexToCol(idx) {
    if (!Number.isFinite(idx) || idx < 0) return "";
    let n = idx + 1;
    let out = "";
    while (n > 0) {
      const r = (n - 1) % 26;
      out = String.fromCharCode(65 + r) + out;
      n = Math.floor((n - 1) / 26);
    }
    return out;
  }

  function toIntLike(v) {
    if (typeof v === "number" && Number.isFinite(v)) return Math.trunc(v);
    const s = String(v ?? "").trim();
    if (!s) return null;
    if (/^\d+$/.test(s)) return parseInt(s, 10);
    return null;
  }

  function normalizeSchoolName(v, enabled) {
    if (v === null || v === undefined) return "";
    const s = String(v);
    if (!enabled) return s.trim();
    return s.replace(/\s+/g, " ").trim();
  }

  function sanitizeFilename(name) {
    return String(name ?? "").replace(/[\\/:*?"<>|]/g, "_");
  }

  function downloadCsv(filename, rows2d) {
    const bom = "\uFEFF"; // Excel 한글 깨짐 방지
    const csv = rows2d.map(row => row.map(cell => {
      const raw = String(cell ?? "");
      const escaped = raw.replace(/\"/g, '""');
      return `"${escaped}"`;
    }).join(",")).join("\n");

    const blob = new Blob([bom + csv], { type: "text/csv;charset=utf-8;" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1200);
  }

  function normalizeKey(s) {
    return String(s ?? "").replace(/\s+/g, "").trim();
  }

  function parseRegionFromFilename(fileName) {
    const s = String(fileName ?? "");
    const m = s.match(/\[([^\]]+)\]/);
    return m ? String(m[1]).trim() : "";
  }

  // ---------------------------
  // ✅ Custom Select (wrap options)
  // ---------------------------
  const customSelectInstances = [];
  const custom = { school: null, job: null };

  function createCustomSelect(selectEl, { placeholder = "선택" } = {}) {
    const exist = customSelectInstances.find(x => x.select === selectEl);
    if (exist) return exist;

    selectEl.classList.add("native-select");

    const wrap = document.createElement("div");
    wrap.className = "cselect";
    const parent = selectEl.parentNode;
    parent.insertBefore(wrap, selectEl);
    wrap.appendChild(selectEl);

    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "cselect-btn";
    btn.setAttribute("aria-haspopup", "listbox");
    btn.setAttribute("aria-expanded", "false");
    wrap.appendChild(btn);

    const list = document.createElement("div");
    list.className = "cselect-list";
    list.setAttribute("role", "listbox");
    list.hidden = true;
    wrap.appendChild(list);

    function close() {
      if (list.hidden) return;
      list.hidden = true;
      wrap.classList.remove("open");
      btn.setAttribute("aria-expanded", "false");
    }

    function open() {
      for (const inst of customSelectInstances) {
        if (inst.wrap !== wrap) inst.close();
      }
      list.hidden = false;
      wrap.classList.add("open");
      btn.setAttribute("aria-expanded", "true");
    }

    function toggle() {
      if (list.hidden) open();
      else close();
    }

    function sync() {
      const opt = selectEl.options[selectEl.selectedIndex];
      const text = opt ? opt.textContent : "";
      btn.textContent = text || placeholder;
      btn.title = text || "";

      const items = list.querySelectorAll(".cselect-item");
      items.forEach(it => {
        it.classList.toggle("is-selected", it.dataset.value === selectEl.value);
      });

      btn.disabled = !!selectEl.disabled;
      if (btn.disabled) close();
    }

    function refresh() {
      list.innerHTML = "";
      const frag = document.createDocumentFragment();

      for (const opt of Array.from(selectEl.options)) {
        const item = document.createElement("div");
        item.className = "cselect-item";
        item.textContent = opt.textContent || "";
        item.dataset.value = opt.value;

        if (opt.disabled) {
          item.classList.add("is-disabled");
        } else {
          item.addEventListener("click", () => {
            selectEl.value = opt.value;
            selectEl.dispatchEvent(new Event("change", { bubbles: true }));
            sync();
            close();
          });
        }
        frag.appendChild(item);
      }

      list.appendChild(frag);
      sync();
    }

    btn.addEventListener("click", (e) => {
      e.preventDefault();
      toggle();
    });

    document.addEventListener("click", (e) => {
      if (!wrap.contains(e.target)) close();
    });

    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape") close();
    });

    selectEl.addEventListener("change", () => sync());

    const inst = { select: selectEl, wrap, btn, list, refresh, sync, open, close };
    customSelectInstances.push(inst);
    refresh();
    return inst;
  }

  function ensureCustomSelects() {
    if (!custom.school) custom.school = createCustomSelect(el.schoolSelect, { placeholder: "학교 선택" });
    if (!custom.job) custom.job = createCustomSelect(el.jobSelect, { placeholder: "직종 선택" });
  }

  // ---------------------------
  // XLSX loader (로컬 → CDN 폴백)
  // ---------------------------
  function loadScript(src) {
    return new Promise((resolve, reject) => {
      const s = document.createElement("script");
      s.src = src;
      s.onload = () => resolve(true);
      s.onerror = () => reject(new Error("script load fail: " + src));
      document.head.appendChild(s);
    });
  }

  async function ensureXLSX() {
    if (window.XLSX) return true;
    const sources = [
      "/static/xlsx.full.min.js",
      "static/xlsx.full.min.js",
      "https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"
    ];
    for (const src of sources) {
      try {
        log(`엑셀 파서 로드 시도: ${src}`);
        await loadScript(src);
        if (window.XLSX) {
          log("엑셀 파서 로드 완료 ✅");
          return true;
        }
      } catch {
        log(`로드 실패: ${src}`);
      }
    }
    return false;
  }

  function setLibWarning(ok) {
    if (ok) {
      el.libWarn.style.display = "none";
      el.btnAnalyze.disabled = false;
      return;
    }
    el.libWarn.style.display = "";
    el.libWarn.textContent =
      "⚠️ 엑셀 파서(XLSX)가 로드되지 않았습니다. " +
      "폐쇄망이면 /static/xlsx.full.min.js 를 프로젝트에 추가하세요. (또는 인터넷 환경에서 CDN 사용)";
    el.btnAnalyze.disabled = true;
  }

  // ---------------------------
  // Layout detection (자동 컬럼 감지)
  // ---------------------------
  function cellStr(v) {
    return String(v ?? "").replace(/\s+/g, " ").trim();
  }

  function cellKey(v) {
    return normalizeKey(cellStr(v));
  }

  function forwardFill(keys) {
    const out = [];
    let last = "";
    for (const k of keys) {
      if (k) { last = k; out.push(k); }
      else { out.push(last); }
    }
    return out;
  }

  function countHeaderSignals(keys, RE) {
    let c = 0;
    for (const k of keys) {
      if (!k) continue;
      if (RE.seq.test(k) || RE.name.test(k) || RE.job.test(k) || RE.note.test(k) || RE.place.test(k)) c++;
    }
    return c;
  }

  function findIdxPrefer(primaryKeys, secondaryKeys, re) {
    for (let i = 0; i < primaryKeys.length; i++) {
      if (primaryKeys[i] && re.test(primaryKeys[i])) return i;
    }
    for (let i = 0; i < secondaryKeys.length; i++) {
      if (secondaryKeys[i] && re.test(secondaryKeys[i])) return i;
    }
    return -1;
  }

  function detectLayout(rows) {
    const RE = {
      seq: /(연번|순번|일련|번호)/,
      name: /(성명|이름)/,
      job: /(직종|직종명|직명)/,
      note: /(비고|특이|사유)/,
      place: /(부서|근무처|근무지|기관|학교|소속)/,

      inHint: /(임용|전입|발령후|신규|도착|변경후|임용사항|전보후)/,
      outHint: /(현직|현근무|현근무처|전출|퇴직|발령전|출발|변경전|종전|전보전)/,
    };

    const maxScan = Math.min(rows.length, 60);
    let best = null;

    for (let r = 0; r < maxScan; r++) {
      const topRow = rows[r] || [];
      const botRow = rows[r + 1] || [];

      const n = Math.max(topRow.length, botRow.length);
      if (n <= 0) continue;

      const topKeys = Array.from({ length: n }, (_, i) => cellKey(topRow[i]));
      const botKeys = Array.from({ length: n }, (_, i) => cellKey(botRow[i]));
      const topFF = forwardFill(topKeys);

      const topCnt = countHeaderSignals(topKeys, RE);
      const botCnt = countHeaderSignals(botKeys, RE);

      const fieldKeys = (botCnt >= topCnt) ? botKeys : topKeys;
      const otherKeys = (fieldKeys === botKeys) ? topKeys : botKeys;

      const seqIdx = findIdxPrefer(fieldKeys, otherKeys, RE.seq);
      const nameIdx = findIdxPrefer(fieldKeys, otherKeys, RE.name);
      const jobIdx = findIdxPrefer(fieldKeys, otherKeys, RE.job);
      const noteIdx = findIdxPrefer(fieldKeys, otherKeys, RE.note);

      let placeCols = [];
      for (let i = 0; i < n; i++) {
        if (fieldKeys[i] && RE.place.test(fieldKeys[i])) placeCols.push(i);
      }
      if (placeCols.length < 2) {
        placeCols = [];
        for (let i = 0; i < n; i++) {
          if ((topKeys[i] && RE.place.test(topKeys[i])) || (botKeys[i] && RE.place.test(botKeys[i]))) {
            placeCols.push(i);
          }
        }
      }

      if (seqIdx < 0 || nameIdx < 0 || placeCols.length < 2) continue;

      const scored = placeCols.map((i) => {
        const combined = (topFF[i] || "") + (fieldKeys[i] || "");
        let inScore = 0;
        let outScore = 0;

        if (RE.inHint.test(combined)) inScore += 3;
        if (RE.outHint.test(combined)) outScore += 3;

        if (fieldKeys[i]) {
          if (RE.inHint.test(fieldKeys[i])) inScore += 2;
          if (RE.outHint.test(fieldKeys[i])) outScore += 2;
        }
        if (topFF[i]) {
          if (RE.inHint.test(topFF[i])) inScore += 2;
          if (RE.outHint.test(topFF[i])) outScore += 2;
        }

        return { i, inScore, outScore };
      });

      const inSorted = [...scored].sort((a, b) =>
        (b.inScore - a.inScore) ||
        (a.outScore - b.outScore) ||
        (a.i - b.i)
      );

      const outSorted = [...scored].sort((a, b) =>
        (b.outScore - a.outScore) ||
        (a.inScore - b.inScore) ||
        (a.i - b.i)
      );

      let inIdx = inSorted[0]?.i ?? -1;
      let outIdx = outSorted[0]?.i ?? -1;

      if (inIdx === outIdx) {
        outIdx = outSorted.find(x => x.i !== inIdx)?.i ?? -1;
      }
      if (inIdx === outIdx || inIdx < 0 || outIdx < 0) {
        inIdx = placeCols[0];
        outIdx = placeCols[1];
      }

      const score =
        (seqIdx >= 0 ? 2 : 0) +
        (nameIdx >= 0 ? 2 : 0) +
        ((inIdx >= 0 && outIdx >= 0 && inIdx !== outIdx) ? 2 : 0) +
        (jobIdx >= 0 ? 1 : 0) +
        (noteIdx >= 0 ? 1 : 0);

      if (!best || score > best.score) {
        best = {
          headerIdx: r,
          subIdx: r + 1,
          seqIdx,
          nameIdx,
          jobIdx,
          inIdx,
          outIdx,
          noteIdx: noteIdx >= 0 ? noteIdx : -1,
          detected: true,
          score,
        };
      }
    }

    return best;
  }

  // ---------------------------
  // 직군(지방/교육/공무직) 규칙 파서
  // ---------------------------
  function parseMappingRules(text) {
    const lines = String(text ?? "").split(/\r?\n/);
    const groups = [];

    for (let raw of lines) {
      raw = raw.replace(/(#|\/\/).*$/, "").trim();
      if (!raw) continue;

      let sep = null;
      for (const s of ["=", ":", "->", "⇒"]) {
        if (raw.includes(s)) { sep = s; break; }
      }
      if (!sep) continue;

      const parts = raw.split(sep);
      if (parts.length < 2) continue;

      const name = parts[0].trim();
      const rhs = parts.slice(1).join(sep).trim();
      if (!name || !rhs) continue;

      const patterns = rhs.split(",").map(x => x.trim()).filter(Boolean);
      if (!patterns.length) continue;

      groups.push({ name, patterns });
    }

    return { groups };
  }

  function matchPattern(text, pattern) {
    const t = String(text ?? "");
    const p = String(pattern ?? "").trim();
    if (!p) return false;

    // 와일드카드(*) 지원
    if (p.includes("*")) {
      const esc = p.replace(/[.+?^${}()|[\]\\]/g, "\\$&").replace(/\*/g, ".*");
      const re = new RegExp("^" + esc + "$", "i");
      // 전체 문자열 비교가 기본. 부분일치는 *를 양옆에 붙이면 됨.
      return re.test(t) || re.test(normalizeKey(t));
    }

    // 기본: 공백 제거 후 동일 비교
    return normalizeKey(p) === normalizeKey(t);
  }

  function normalizeStaffType(raw) {
    const s = String(raw ?? "").trim();
    if (STAFF_TYPES.includes(s)) return s;

    // 느슨한 매핑
    if (s.includes("지방")) return "지방공무원";
    if (s.includes("교육공무원") || s.includes("교원")) return "교육공무원";
    if (s.includes("공무직")) return "교육공무직";

    // 기본 폴백
    return "교육공무직";
  }

  function classifyStaffType(jobName, sheetName, fileName) {
    const j = String(jobName ?? "").trim();
    const sn = String(sheetName ?? "").trim();
    const fn = String(fileName ?? "").trim();

    // 1) 사용자 규칙 우선(직종명 기준)
    const parsed = state.typeRulesParsed;
    if (parsed && parsed.groups && parsed.groups.length) {
      for (const g of parsed.groups) {
        const typeName = normalizeStaffType(g.name);
        for (const p of g.patterns) {
          if (matchPattern(j, p) || matchPattern(sn, p) || matchPattern(fn, p)) {
            return typeName;
          }
        }
      }
    }

    // 2) 휴리스틱(추정)
    const H = (s) => String(s ?? "");

    // 파일명 힌트(가장 강력)
    if (/교육공무원|교원/.test(fn)) return "교육공무원";
    if (/지방공무원/.test(fn)) return "지방공무원";
    if (/교육공무직/.test(fn)) return "교육공무직";

    // 교육공무직(공무직) 키워드
    if (/(공무직|실무사|전담사|지도사|조리|영양사(?!\s*교사)|늘봄|돌봄|방과후|교무행정사|행정실무사|시설관리원|미화|청소|환경|당직|통학)/.test(j)) {
      return "교육공무직";
    }

    // 교육공무원(교원) 키워드
    if (/(교장|교감|교사|교원|수석교사|기간제교사|사서교사|보건교사|상담교사|영양교사)/.test(j)) {
      return "교육공무원";
    }

    // 지방공무원 키워드(행정직 등)
    if (/(주무관|사무관|지방공무원|행정직|시설직|공업직|운전직|전산직|통신직|공무원)/.test(j)) {
      return "지방공무원";
    }

    // 기본
    return "교육공무직";
  }

  // ---------------------------
  // School aggregation
  // ---------------------------
  function makeSchoolKey(schoolName, region, includePrefix) {
    const s = String(schoolName ?? "").trim();
    const r = String(region ?? "").trim();
    if (!includePrefix) return s;
    if (!r) return s;
    return `${r}||${s}`;
  }

  function splitSchoolKey(key) {
    const s = String(key ?? "");
    const i = s.indexOf("||");
    if (i >= 0) return { region: s.slice(0, i), school: s.slice(i + 2) };
    return { region: "", school: s };
  }

  function getOrCreateSchoolRecord(key, schoolName) {
    if (!state.schools.has(key)) {
      state.schools.set(key, {
        key,
        school: String(schoolName ?? "").trim(),
        regions: new Set(),
        inMoves: [],
        outMoves: [],
        byJob: new Map(), // job -> {jobName, staffType, inCount,outCount,inMoves,outMoves}
        summary: null,
      });
    }
    return state.schools.get(key);
  }

  function getOrCreateJobInfo(rec, jobName, staffType) {
    const j = String(jobName ?? "").trim() || "(직종미상)";
    const t = normalizeStaffType(staffType);

    if (!rec.byJob.has(j)) {
      rec.byJob.set(j, { jobName: j, staffType: t, inCount: 0, outCount: 0, inMoves: [], outMoves: [] });
    } else {
      // 기존 타입과 다르면(혼재) 로그만 남기고 기존 유지
      const exist = rec.byJob.get(j);
      if (exist && exist.staffType !== t) {
        log(`⚠️ 직군 불일치 감지: [${rec.school}] 직종 '${j}' 기존=${exist.staffType}, 신규=${t} (기존 유지)`);
      }
    }
    return rec.byJob.get(j);
  }

  function addMoveToSchool(rec, move, dir) {
    if (dir === "in") rec.inMoves.push(move);
    else rec.outMoves.push(move);

    const ji = getOrCreateJobInfo(rec, move.jobName, move.staffType);
    if (dir === "in") { ji.inCount++; ji.inMoves.push(move); }
    else { ji.outCount++; ji.outMoves.push(move); }
  }

  function getRegionText(rec) {
    const arr = [...rec.regions].filter(Boolean);
    arr.sort((a,b)=>a.localeCompare(b,"ko"));
    if (!arr.length) return "-";
    if (arr.length <= 2) return arr.join(", ");
    return `${arr.slice(0,2).join(", ")} 외 ${arr.length - 2}`;
  }

  function emptyTypeAgg() {
    const obj = {};
    for (const t of STAFF_TYPES) {
      obj[t] = {
        inTotal: 0,
        outTotal: 0,
        shortageJobs: 0,
        shortagePositions: 0,
        surplusJobs: 0,
        surplusPositions: 0,
        balancedJobs: 0,
        jobCount: 0,
      };
    }
    return obj;
  }

  function finalizeSchoolSummary(rec) {
    const typeAgg = emptyTypeAgg();

    let inTotal = rec.inMoves.length;
    let outTotal = rec.outMoves.length;

    let shortageJobs = 0;
    let shortagePositions = 0;
    let surplusJobs = 0;
    let surplusPositions = 0;
    let balancedJobs = 0;

    for (const [, ji] of rec.byJob.entries()) {
      const type = normalizeStaffType(ji.staffType);
      const diff = ji.outCount - ji.inCount;

      typeAgg[type].jobCount++;
      typeAgg[type].inTotal += ji.inCount;
      typeAgg[type].outTotal += ji.outCount;

      if (diff > 0) {
        shortageJobs++; shortagePositions += diff;
        typeAgg[type].shortageJobs++;
        typeAgg[type].shortagePositions += diff;
      } else if (diff < 0) {
        surplusJobs++; surplusPositions += (-diff);
        typeAgg[type].surplusJobs++;
        typeAgg[type].surplusPositions += (-diff);
      } else {
        balancedJobs++;
        typeAgg[type].balancedJobs++;
      }
    }

    rec.summary = {
      key: rec.key,
      school: rec.school,
      inTotal,
      outTotal,
      shortageJobs,
      shortagePositions,
      surplusJobs,
      surplusPositions,
      balancedJobs,
      netDiff: outTotal - inTotal,
      jobCount: rec.byJob.size,
      regionText: getRegionText(rec),
      typeAgg,
    };
  }

  function rebuildSchoolOrder() {
    // 기본은 "결원 의심(총)" 내림차순
    state.schoolOrder = [...state.schools.keys()].sort((ka, kb) => {
      const a = state.schools.get(ka)?.summary;
      const b = state.schools.get(kb)?.summary;

      const ad = a ? a.shortagePositions : 0;
      const bd = b ? b.shortagePositions : 0;
      if (bd !== ad) return bd - ad;

      const an = a ? a.netDiff : 0;
      const bn = b ? b.netDiff : 0;
      if (Math.abs(bn) !== Math.abs(an)) return Math.abs(bn) - Math.abs(an);

      const ar = a ? a.regionText : "";
      const br = b ? b.regionText : "";
      const rc = ar.localeCompare(br, "ko");
      if (rc !== 0) return rc;

      const as = a ? a.school : "";
      const bs = b ? b.school : "";
      return as.localeCompare(bs, "ko");
    });
  }

  // ---------------------------
  // Sorting helpers
  // ---------------------------
  function cmp(aVal, bVal, dir, locale = "ko") {
    const d = (dir === "asc") ? 1 : -1;

    const aNum = (typeof aVal === "number" && Number.isFinite(aVal)) ? aVal : null;
    const bNum = (typeof bVal === "number" && Number.isFinite(bVal)) ? bVal : null;

    if (aNum !== null && bNum !== null) {
      if (aNum === bNum) return 0;
      return (aNum - bNum) * d;
    }

    const aStr = String(aVal ?? "");
    const bStr = String(bVal ?? "");
    const c = aStr.localeCompare(bStr, locale);
    return c * d;
  }

  function getSchoolSortValue(s, key) {
    const T = s.typeAgg || emptyTypeAgg();
    switch (key) {
      case "shortageTotal": return s.shortagePositions;
      case "shortage_local": return T["지방공무원"].shortagePositions;
      case "shortage_edu": return T["교육공무원"].shortagePositions;
      case "shortage_worker": return T["교육공무직"].shortagePositions;
      case "surplusTotal": return s.surplusPositions;
      case "netDiff": return s.netDiff;
      case "outTotal": return s.outTotal;
      case "inTotal": return s.inTotal;
      case "jobCount": return s.jobCount;
      case "region": return s.regionText || "";
      case "school": return s.school || "";
      default: return s.shortagePositions;
    }
  }

  // ---------------------------
  // 직군 pill 렌더
  // ---------------------------
  function pillForType(type, text) {
    const meta = STAFF_TYPE_META[type] || { pillClass: "gray", short: type };
    return `<span class="pill ${meta.pillClass}">${escapeHtml(text)}</span>`;
  }

  function renderShortageBreakdown(typeAgg) {
    const chunks = [];
    for (const t of STAFF_TYPES) {
      const v = typeAgg?.[t]?.shortagePositions ?? 0;
      if (v > 0) chunks.push(pillForType(t, `${STAFF_TYPE_META[t].short} +${v}`));
    }
    return chunks.length ? chunks.join(" ") : `<span class="pill gray">-</span>`;
  }

  function renderSurplusBreakdown(typeAgg) {
    const chunks = [];
    for (const t of STAFF_TYPES) {
      const v = typeAgg?.[t]?.surplusPositions ?? 0;
      if (v > 0) chunks.push(pillForType(t, `${STAFF_TYPE_META[t].short} ${v}`));
    }
    return chunks.length ? chunks.join(" ") : `<span class="pill gray">-</span>`;
  }

  function renderTypeHeaderPills(summary) {
    const T = summary.typeAgg || emptyTypeAgg();
    const shortTotal = summary.shortagePositions || 0;
    const surpTotal = summary.surplusPositions || 0;

    const top = [];
    if (shortTotal > 0) top.push(`<span class="pill red">결원 의심 +${shortTotal}</span>`);
    else top.push(`<span class="pill gray">결원 의심 -</span>`);

    if (surpTotal > 0) top.push(`<span class="pill blue">순증가 ${surpTotal}</span>`);
    else top.push(`<span class="pill gray">순증가 -</span>`);

    const net =
      summary.netDiff > 0 ? `<span class="pill red">총차이 +${summary.netDiff}</span>` :
      summary.netDiff < 0 ? `<span class="pill blue">총차이 ${summary.netDiff}</span>` :
      `<span class="pill gray">총차이 0</span>`;
    top.push(net);

    // 직군 breakdown(결원 의심만)
    const breakdown = renderShortageBreakdown(T);
    return `${top.join(" ")} <span class="pill gray">직군</span> ${breakdown}`;
  }

  // ---------------------------
  // Analysis
  // ---------------------------
  function resetAll() {
    state.files = [];
    state.analyzed = false;
    state.moves = [];
    state.moveIdCounter = 0;
    state.moveById.clear();

    state.schools.clear();
    state.schoolOrder = [];

    state.selectedSchoolKey = "";
    state.selectedJob = "__ALL__";

    state.lastSchoolSummaryList = [];
    state.lastSuspectList = [];
    state.lastSchoolJobList = [];
    state.lastMoveList = [];

    hideTip();
  }

  function rebuildAggregationsFromMoves({ preserveSelection = true } = {}) {
    if (!state.moves.length) return;

    const normOn = el.optNormalize.checked;
    const includePrefix = el.optSchoolKeyPrefix.checked;

    // 선택 유지(가능한 경우)
    const prevSchoolKey = preserveSelection ? state.selectedSchoolKey : "";

    state.schools.clear();
    state.schoolOrder = [];

    for (const move of state.moves) {
      // 옵션 반영 재정규화
      move.inSchool = normalizeSchoolName(move.inSchoolRaw, normOn);
      move.outSchool = normalizeSchoolName(move.outSchoolRaw, normOn);

      // 직군 재분류(규칙 변경 반영)
      move.staffType = classifyStaffType(move.jobName, move.sheetName, move.fileName);

      // 학교 집계
      if (move.inSchool) {
        const k = makeSchoolKey(move.inSchool, move.region, includePrefix);
        const rec = getOrCreateSchoolRecord(k, splitSchoolKey(k).school);
        if (move.region) rec.regions.add(move.region);
        addMoveToSchool(rec, move, "in");
      }
      if (move.outSchool) {
        const k = makeSchoolKey(move.outSchool, move.region, includePrefix);
        const rec = getOrCreateSchoolRecord(k, splitSchoolKey(k).school);
        if (move.region) rec.regions.add(move.region);
        addMoveToSchool(rec, move, "out");
      }
    }

    for (const [, rec] of state.schools) finalizeSchoolSummary(rec);
    rebuildSchoolOrder();

    // 렌더/셀렉트
    renderSchoolSummary();
    renderSuspectList();
    initSchoolSelect();

    // 선택 복구(가능하면)
    if (prevSchoolKey && state.schools.has(prevSchoolKey)) {
      selectSchool(prevSchoolKey, state.selectedJob);
    } else {
      selectSchool(state.schoolOrder[0] || "", "__ALL__");
    }
  }

  async function analyzeCurrentFiles() {
    clearLog();

    if (!state.files.length) {
      log("파일이 선택되지 않았습니다.");
      return;
    }

    // 직군 규칙 파싱
    state.typeRulesParsed = parseMappingRules(el.typeRules.value);
    if (state.typeRulesParsed?.groups?.length) {
      el.typeHint.textContent = `규칙 ${state.typeRulesParsed.groups.length}개 적용됨`;
    } else {
      el.typeHint.textContent = "규칙 없음 → 기본 추정 분류 사용";
    }

    const ok = await ensureXLSX();
    setLibWarning(ok);
    if (!ok) {
      log("XLSX 라이브러리 없음 → 분석 중단");
      return;
    }

    const seqIdxManual = colToIndex(el.colSeq.value);
    const nameIdxManual = colToIndex(el.colName.value);
    const jobIdxManual = colToIndex(el.colJob.value);
    const inIdxManual = colToIndex(el.colIn.value);
    const outIdxManual = colToIndex(el.colOut.value);
    const noteIdxManual = colToIndex(el.colNote.value);

    const badCols = [
      ["연번", seqIdxManual],
      ["성명", nameIdxManual],
      ["직종", jobIdxManual],
      ["전입(부서)", inIdxManual],
      ["전출(부서)", outIdxManual],
      ["비고", noteIdxManual],
    ].filter(([, idx]) => idx === null);

    if (badCols.length) {
      log("컬럼 입력이 잘못되었습니다: " + badCols.map(([k]) => k).join(", "));
      return;
    }

    const normOn = el.optNormalize.checked;
    const autoOn = el.optAutoDetect.checked;
    const includePrefix = el.optSchoolKeyPrefix.checked;

    // 상태 초기화
    state.analyzed = false;
    state.moves = [];
    state.moveIdCounter = 0;
    state.moveById.clear();

    state.schools.clear();
    state.schoolOrder = [];
    state.selectedSchoolKey = "";
    state.selectedJob = "__ALL__";

    log(`분석 시작: 파일 ${state.files.length}개`);

    for (const file of state.files) {
      const region = parseRegionFromFilename(file.name);
      log(`- 파일: ${file.name}${region ? ` (구분=${region})` : ""}`);

      const buf = await file.arrayBuffer();
      const wb = XLSX.read(buf, { type: "array" });

      log(`  → 시트 ${wb.SheetNames.length}개`);

      for (const sheetName of wb.SheetNames) {
        const ws = wb.Sheets[sheetName];
        const rows = XLSX.utils.sheet_to_json(ws, { header: 1, defval: "" });

        let layout = null;
        if (autoOn) {
          layout = detectLayout(rows);
          if (layout) {
            log(`    [${sheetName}] 자동감지 OK: seq=${indexToCol(layout.seqIdx)}, name=${indexToCol(layout.nameIdx)}, job=${layout.jobIdx>=0?indexToCol(layout.jobIdx):"(없음)"}, in=${indexToCol(layout.inIdx)}, out=${indexToCol(layout.outIdx)}, note=${layout.noteIdx>=0?indexToCol(layout.noteIdx):"(없음)"}`);
          } else {
            log(`    [${sheetName}] 자동감지 실패 → 수동 매핑 사용`);
          }
        }

        const seqIdx = layout ? layout.seqIdx : seqIdxManual;
        const nameIdx = layout ? layout.nameIdx : nameIdxManual;
        const jobIdx = layout ? layout.jobIdx : jobIdxManual;
        const inIdx = layout ? layout.inIdx : inIdxManual;
        const outIdx = layout ? layout.outIdx : outIdxManual;
        const noteIdx = layout ? layout.noteIdx : noteIdxManual;

        let used = 0;

        for (let r = 0; r < rows.length; r++) {
          const row = rows[r] || [];
          const seq = toIntLike(row[seqIdx]);
          if (seq === null) continue;

          const name = String(row[nameIdx] ?? "").trim();
          const rawJob = jobIdx >= 0 ? String(row[jobIdx] ?? "").trim() : "";
          const jobName = rawJob || sheetName || "(직종미상)";

          const inSchoolRaw = row[inIdx];
          const outSchoolRaw = row[outIdx];
          const inSchool = normalizeSchoolName(inSchoolRaw, normOn);
          const outSchool = normalizeSchoolName(outSchoolRaw, normOn);
          const note = noteIdx >= 0 ? String(row[noteIdx] ?? "").trim() : "";

          const staffType = classifyStaffType(jobName, sheetName, file.name);

          const id = ++state.moveIdCounter;
          const move = {
            id,
            staffType,

            fileName: file.name,
            region,
            sheetName,
            jobName,

            seq,
            name,

            inSchoolRaw,
            outSchoolRaw,
            inSchool,
            outSchool,

            note,
            rowIndex: r + 1,
          };

          state.moves.push(move);
          state.moveById.set(id, move);

          used++;

          // 학교 집계
          if (inSchool) {
            const k = makeSchoolKey(inSchool, region, includePrefix);
            const rec = getOrCreateSchoolRecord(k, splitSchoolKey(k).school);
            if (region) rec.regions.add(region);
            addMoveToSchool(rec, move, "in");
          }

          if (outSchool) {
            const k = makeSchoolKey(outSchool, region, includePrefix);
            const rec = getOrCreateSchoolRecord(k, splitSchoolKey(k).school);
            if (region) rec.regions.add(region);
            addMoveToSchool(rec, move, "out");
          }
        }

        if (used > 0) log(`    [${sheetName}] 데이터행 ${used}건 처리`);
      }
    }

    for (const [, rec] of state.schools) finalizeSchoolSummary(rec);
    rebuildSchoolOrder();

    state.analyzed = true;

    // 렌더
    renderSchoolSummary();
    renderSuspectList();
    initSchoolSelect();
    selectSchool(state.schoolOrder[0] || "", "__ALL__");

    el.schoolSummarySection.style.display = "";
    el.suspectSection.style.display = "";
    el.detailSection.style.display = "";

    log(`분석 완료 ✅ (이동기록 ${state.moves.length}건, 학교(부서) ${state.schools.size}개)`);
  }

  // ---------------------------
  // Rendering
  // ---------------------------
  function formatSchoolLabel(rec) {
    const rtxt = getRegionText(rec);
    return (rtxt && rtxt !== "-" ? `[${rtxt}] ` : "") + rec.school;
  }

  function renderSchoolSummary() {
    if (!state.analyzed) return;

    const q = (el.schoolFilter.value || "").trim();
    const mode = el.schoolModeSelect.value;

    const sortKey = el.schoolSortKey.value;
    const sortDir = el.schoolSortDir.value;

    const rows = [];
    for (const key of state.schoolOrder) {
      const rec = state.schools.get(key);
      if (!rec || !rec.summary) continue;
      const s = rec.summary;

      const textForFilter = `${s.regionText} ${s.school}`;
      if (q && !textForFilter.includes(q)) continue;

      const hasShort = s.shortagePositions > 0;
      const hasSurp = s.surplusPositions > 0;
      const isBalanced = !hasShort && !hasSurp;

      if (mode === "suspect" && !hasShort) continue;
      if (mode === "surplus" && !hasSurp) continue;
      if (mode === "mixed" && !(hasShort && hasSurp)) continue;
      if (mode === "balanced" && !isBalanced) continue;

      rows.push({ key, rec, s });
    }

    rows.sort((a, b) => {
      const av = getSchoolSortValue(a.s, sortKey);
      const bv = getSchoolSortValue(b.s, sortKey);
      const c = cmp(av, bv, sortDir);
      if (c !== 0) return c;

      // tie-breaker
      const rc = (a.s.regionText||"").localeCompare((b.s.regionText||""), "ko");
      if (rc !== 0) return rc;
      return (a.s.school||"").localeCompare((b.s.school||""), "ko");
    });

    state.lastSchoolSummaryList = rows.map(x => x.s);

    el.schoolStats.innerHTML =
      `표시 <b>${rows.length}</b>개 · 전체 학교 <b>${state.schools.size}</b>개` +
      (q ? ` · 필터: <span class="pill gray">${escapeHtml(q)}</span>` : "");

    el.schoolSummaryBody.innerHTML = "";
    const frag = document.createDocumentFragment();

    for (const row of rows) {
      const { key, s } = row;
      const T = s.typeAgg || emptyTypeAgg();

      const netPill =
        s.netDiff > 0 ? `<span class="pill red">+${s.netDiff}</span>` :
        s.netDiff < 0 ? `<span class="pill blue">${s.netDiff}</span>` :
        `<span class="pill gray">0</span>`;

      const shortCell = s.shortagePositions > 0
        ? `<span class="pill red">총 +${s.shortagePositions}</span> ${renderShortageBreakdown(T)}`
        : `<span class="pill gray">-</span>`;

      const surpCell = s.surplusPositions > 0
        ? `<span class="pill blue">총 ${s.surplusPositions}</span> ${renderSurplusBreakdown(T)}`
        : `<span class="pill gray">-</span>`;

      const tr = document.createElement("tr");
      tr.className = "clickable";
      tr.dataset.key = key;
      if (key === state.selectedSchoolKey) tr.classList.add("is-selected");

      tr.innerHTML = `
        <td>${escapeHtml(s.regionText || "-")}</td>
        <td><b>${escapeHtml(s.school)}</b></td>
        <td class="numeric">${s.outTotal}</td>
        <td class="numeric">${s.inTotal}</td>
        <td class="numeric">${shortCell}</td>
        <td class="numeric">${surpCell}</td>
        <td class="numeric">${netPill}</td>
      `;

      tr.addEventListener("click", () => {
        selectSchool(key, "__ALL__");
        document.getElementById("detailSection")?.scrollIntoView({ behavior: "smooth", block: "start" });
      });

      // hover tip
      tr.addEventListener("mouseenter", (e) => {
        const html = `
          <div><b>${escapeHtml(s.school)}</b> <span class="small">(${escapeHtml(s.regionText || "-")})</span></div>
          <div class="small">전출 ${s.outTotal} · 전입 ${s.inTotal} · 직종 ${s.jobCount}</div>
          <div style="margin-top:6px;">${renderTypeHeaderPills(s)}</div>
          <div class="small" style="margin-top:6px;">클릭하면 학교 상세로 이동</div>
        `;
        showTip(html, e.clientX, e.clientY);
      });
      tr.addEventListener("mousemove", (e) => moveTip(e.clientX, e.clientY));
      tr.addEventListener("mouseleave", hideTip);
      tr.addEventListener("click", (e) => {
        // 클릭 시에도 잠깐 표시(모바일/터치 대응)
        const html = `
          <div><b>${escapeHtml(s.school)}</b> <span class="small">(${escapeHtml(s.regionText || "-")})</span></div>
          <div class="small">전출 ${s.outTotal} · 전입 ${s.inTotal} · 직종 ${s.jobCount}</div>
          <div style="margin-top:6px;">${renderTypeHeaderPills(s)}</div>
        `;
        showTip(html, e.clientX, e.clientY, 1800);
      });

      frag.appendChild(tr);
    }

    el.schoolSummaryBody.appendChild(frag);
  }

  function renderSuspectList() {
    if (!state.analyzed) return;

    const q = (el.suspectFilter.value || "").trim();
    const sortKey = el.suspectSortKey.value;
    const sortDir = el.suspectSortDir.value;

    const rows = [];

    for (const [key, rec] of state.schools.entries()) {
      if (!rec) continue;
      const regionText = getRegionText(rec);

      for (const [jobName, ji] of rec.byJob.entries()) {
        const diff = ji.outCount - ji.inCount;
        if (diff <= 0) continue;

        const noIncoming = (ji.inCount === 0 && ji.outCount > 0);
        const staffType = normalizeStaffType(ji.staffType);

        const filterText = `${regionText} ${rec.school} ${staffType} ${jobName}`;
        if (q && !filterText.includes(q)) continue;

        rows.push({
          key,
          regionText,
          school: rec.school,
          staffType,
          jobName,
          outC: ji.outCount,
          inC: ji.inCount,
          diff,
          noIncoming,
        });
      }
    }

    function getSuspectSortValue(r, key) {
      switch (key) {
        case "diff": return r.diff;
        case "outC": return r.outC;
        case "inC": return r.inC;
        case "region": return r.regionText || "";
        case "school": return r.school || "";
        case "staffType": return r.staffType || "";
        case "jobName": return r.jobName || "";
        default: return r.diff;
      }
    }

    rows.sort((a, b) => {
      const av = getSuspectSortValue(a, sortKey);
      const bv = getSuspectSortValue(b, sortKey);
      const c = cmp(av, bv, sortDir);
      if (c !== 0) return c;

      // tie
      const rc = (a.regionText||"").localeCompare((b.regionText||""), "ko");
      if (rc !== 0) return rc;
      const sc = (a.school||"").localeCompare((b.school||""), "ko");
      if (sc !== 0) return sc;
      return (a.jobName||"").localeCompare((b.jobName||""), "ko");
    });

    state.lastSuspectList = rows;

    el.suspectStats.innerHTML =
      `결원 의심(학교-직종) <b>${rows.length}</b>건` +
      (q ? ` · 필터: <span class="pill gray">${escapeHtml(q)}</span>` : "");

    el.suspectTableBody.innerHTML = "";
    const frag = document.createDocumentFragment();

    for (const r of rows) {
      const tr = document.createElement("tr");
      tr.className = "clickable";
      tr.dataset.key = r.key;
      tr.dataset.job = r.jobName;

      const typePill = pillForType(r.staffType, r.staffType);

      tr.innerHTML = `
        <td>${escapeHtml(r.regionText || "-")}</td>
        <td><b>${escapeHtml(r.school)}</b></td>
        <td>${typePill}</td>
        <td>${escapeHtml(r.jobName)}</td>
        <td class="numeric">${r.outC}</td>
        <td class="numeric">${r.inC}</td>
        <td class="numeric"><span class="pill red">+${r.diff}</span></td>
        <td class="numeric">${r.noIncoming ? '<span class="pill red">Y</span>' : '<span class="pill gray">-</span>'}</td>
      `;

      tr.addEventListener("click", (e) => {
        selectSchool(r.key, r.jobName);
        document.getElementById("detailSection")?.scrollIntoView({ behavior: "smooth", block: "start" });

        // 클릭 툴팁(짧게)
        const html = `
          <div><b>${escapeHtml(r.school)}</b> <span class="small">(${escapeHtml(r.regionText || "-")})</span></div>
          <div class="small">직군: ${escapeHtml(r.staffType)} · 직종: ${escapeHtml(r.jobName)}</div>
          <div class="small">전출 ${r.outC} · 전입 ${r.inC} · 결원 의심 +${r.diff}</div>
        `;
        showTip(html, e.clientX, e.clientY, 2000);
      });

      tr.addEventListener("mouseenter", (e) => {
        const html = `
          <div><b>${escapeHtml(r.school)}</b> <span class="small">(${escapeHtml(r.regionText || "-")})</span></div>
          <div class="small">직군: ${escapeHtml(r.staffType)} · 직종: ${escapeHtml(r.jobName)}</div>
          <div class="small">전출 ${r.outC} · 전입 ${r.inC} · 결원 의심 +${r.diff}</div>
          <div class="small" style="margin-top:6px;">클릭하면 해당 학교/직종 상세로 이동</div>
        `;
        showTip(html, e.clientX, e.clientY);
      });
      tr.addEventListener("mousemove", (e) => moveTip(e.clientX, e.clientY));
      tr.addEventListener("mouseleave", hideTip);

      frag.appendChild(tr);
    }

    el.suspectTableBody.appendChild(frag);
  }

  function initSchoolSelect() {
    if (!state.analyzed) return;

    el.schoolSelect.innerHTML = "";
    const frag = document.createDocumentFragment();

    const keys = [...state.schools.keys()].sort((a, b) => {
      const ra = state.schools.get(a);
      const rb = state.schools.get(b);
      const ar = getRegionText(ra).localeCompare(getRegionText(rb), "ko");
      if (ar !== 0) return ar;
      return ra.school.localeCompare(rb.school, "ko");
    });

    for (const key of keys) {
      const rec = state.schools.get(key);
      if (!rec) continue;
      const opt = document.createElement("option");
      opt.value = key;
      opt.textContent = formatSchoolLabel(rec);
      frag.appendChild(opt);
    }

    el.schoolSelect.appendChild(frag);

    if (!state.selectedSchoolKey || !state.schools.has(state.selectedSchoolKey)) {
      state.selectedSchoolKey = state.schoolOrder[0] || keys[0] || "";
    }
    if (state.selectedSchoolKey) el.schoolSelect.value = state.selectedSchoolKey;

    ensureCustomSelects();
    custom.school.refresh();
  }

  function selectSchool(key, jobName = "__ALL__") {
    if (!key || !state.schools.has(key)) {
      state.selectedSchoolKey = "";
      state.selectedJob = "__ALL__";
      renderSchoolDetail();
      return;
    }

    state.selectedSchoolKey = key;
    state.selectedJob = jobName || "__ALL__";

    if (el.schoolSelect.value !== key) el.schoolSelect.value = key;

    ensureCustomSelects();
    custom.school.sync();

    [...el.schoolSummaryBody.querySelectorAll("tr")].forEach(tr => {
      tr.classList.toggle("is-selected", tr.dataset.key === key);
    });

    renderSchoolDetail();
  }

  function renderSchoolDetail() {
    const rec = state.schools.get(state.selectedSchoolKey);

    if (!rec || !rec.summary) {
      el.jobTableBody.innerHTML = "";
      el.jobStats.textContent = "";
      el.moveDetailCard.innerHTML = `
        <h3 class="local-h3 local-tight">명단</h3>
        <p class="muted" style="margin-top:0;">분석 후 학교를 선택하세요.</p>
      `;
      return;
    }

    const s = rec.summary;

    // 직종 셀렉트 구성
    const jobNames = [...rec.byJob.keys()].sort((a,b)=>a.localeCompare(b,"ko"));

    if (state.selectedJob !== "__ALL__" && !rec.byJob.has(state.selectedJob)) {
      state.selectedJob = "__ALL__";
    }

    el.jobSelect.innerHTML = "";
    const jf = document.createDocumentFragment();

    const optAll = document.createElement("option");
    optAll.value = "__ALL__";
    optAll.textContent = "전체 직종";
    jf.appendChild(optAll);

    for (const j of jobNames) {
      const ji = rec.byJob.get(j);
      const t = normalizeStaffType(ji?.staffType || "교육공무직");
      const opt = document.createElement("option");
      opt.value = j;
      opt.textContent = `[${t}] ${j}`;
      jf.appendChild(opt);
    }

    el.jobSelect.appendChild(jf);
    el.jobSelect.value = state.selectedJob;

    ensureCustomSelects();
    custom.job.refresh();

    renderJobTable(rec);
    renderMoveLists(rec);
  }

  function renderJobTable(rec) {
    const mode = el.jobModeSelect.value;
    const q = (el.jobFilter.value || "").trim();

    const sortKey = el.jobSortKey.value;
    const sortDir = el.jobSortDir.value;

    const jobRows = [];
    for (const [jobName, ji] of rec.byJob.entries()) {
      const outC = ji.outCount;
      const inC = ji.inCount;
      const diff = outC - inC;
      const noIncoming = inC === 0 && outC > 0;
      const staffType = normalizeStaffType(ji.staffType);

      if (q && !(jobName.includes(q) || staffType.includes(q))) continue;

      if (mode === "suspect" && diff <= 0) continue;
      if (mode === "surplus" && diff >= 0) continue;
      if (mode === "balanced" && diff !== 0) continue;

      jobRows.push({ jobName, staffType, outC, inC, diff, noIncoming, ji });
    }

    function getJobSortValue(r, key) {
      switch (key) {
        case "diff": return r.diff;
        case "outC": return r.outC;
        case "inC": return r.inC;
        case "staffType": return r.staffType;
        case "jobName": return r.jobName;
        default: return r.diff;
      }
    }

    jobRows.sort((a, b) => {
      const av = getJobSortValue(a, sortKey);
      const bv = getJobSortValue(b, sortKey);
      const c = cmp(av, bv, sortDir);
      if (c !== 0) return c;

      // tie
      const tc = a.staffType.localeCompare(b.staffType, "ko");
      if (tc !== 0) return tc;
      return a.jobName.localeCompare(b.jobName, "ko");
    });

    state.lastSchoolJobList = jobRows;

    const s = rec.summary;
    const label =
      mode === "suspect" ? "결원 의심" :
      mode === "surplus" ? "순증가" :
      mode === "balanced" ? "균형" : "전체";

    const typePills = renderTypeHeaderPills(s);

    el.jobStats.innerHTML =
      `<b>${escapeHtml(formatSchoolLabel(rec))}</b> · 직종 ${s.jobCount}개 · 전출 ${s.outTotal} / 전입 ${s.inTotal}` +
      ` · <span class="pill gray">현재보기: ${label} ${jobRows.length}건</span><br/>` +
      `${typePills}`;

    el.jobTableBody.innerHTML = "";
    const frag = document.createDocumentFragment();

    for (const row of jobRows) {
      const tr = document.createElement("tr");
      tr.className = "clickable";
      tr.dataset.job = row.jobName;
      if (row.jobName === state.selectedJob) tr.classList.add("is-selected");

      const diffClass = row.diff > 0 ? "pos" : row.diff < 0 ? "neg" : "zero";
      const diffText = row.diff > 0 ? `+${row.diff}` : String(row.diff);

      const typePill = pillForType(row.staffType, row.staffType);

      tr.innerHTML = `
        <td><b>${escapeHtml(row.jobName)}</b></td>
        <td>${typePill}</td>
        <td class="numeric">${row.outC}</td>
        <td class="numeric">${row.inC}</td>
        <td class="numeric"><span class="diff ${diffClass}">${escapeHtml(diffText)}</span></td>
        <td class="numeric">${row.noIncoming ? '<span class="pill red">Y</span>' : '<span class="pill gray">-</span>'}</td>
      `;

      tr.addEventListener("click", (e) => {
        state.selectedJob = row.jobName;
        el.jobSelect.value = row.jobName;

        ensureCustomSelects();
        custom.job.sync();

        [...el.jobTableBody.querySelectorAll("tr")].forEach(x => x.classList.remove("is-selected"));
        tr.classList.add("is-selected");

        renderMoveLists(rec);

        // 클릭 툴팁(짧게)
        const html = `
          <div><b>${escapeHtml(row.jobName)}</b> <span class="small">(${escapeHtml(row.staffType)})</span></div>
          <div class="small">전출 ${row.outC} · 전입 ${row.inC} · 차이 ${escapeHtml(diffText)}</div>
          <div class="small" style="margin-top:6px;">해당 직종 명단으로 전환됨</div>
        `;
        showTip(html, e.clientX, e.clientY, 1600);
      });

      // hover tooltip
      tr.addEventListener("mouseenter", (e) => {
        const html = `
          <div><b>${escapeHtml(row.jobName)}</b> <span class="small">(${escapeHtml(row.staffType)})</span></div>
          <div class="small">전출 ${row.outC} · 전입 ${row.inC} · 차이 ${escapeHtml(diffText)}</div>
          <div class="small" style="margin-top:6px;">클릭하면 해당 직종 명단으로 전환</div>
        `;
        showTip(html, e.clientX, e.clientY);
      });
      tr.addEventListener("mousemove", (e) => moveTip(e.clientX, e.clientY));
      tr.addEventListener("mouseleave", hideTip);

      frag.appendChild(tr);
    }

    el.jobTableBody.appendChild(frag);
  }

  function sortMovesForDisplay(moves) {
    return moves.slice().sort((a,b) => {
      const as = Number.isFinite(a.seq) ? a.seq : 0;
      const bs = Number.isFinite(b.seq) ? b.seq : 0;
      if (as !== bs) return as - bs;
      return String(a.name||"").localeCompare(String(b.name||""), "ko");
    });
  }

  function tipHtmlForMove(move, dirLabel) {
    const other = dirLabel === "전출" ? (move.inSchool || "-") : (move.outSchool || "-");
    const otherLabel = dirLabel === "전출" ? "도착" : "출발";
    return `
      <div><b>${escapeHtml(move.name || "(이름없음)")}</b> <span class="small">(${escapeHtml(move.staffType)})</span></div>
      <div class="small">직종: ${escapeHtml(move.jobName)}</div>
      <div class="small">${escapeHtml(dirLabel)} · ${escapeHtml(otherLabel)}: ${escapeHtml(other)}</div>
      ${move.note ? `<div class="small">비고: ${escapeHtml(move.note)}</div>` : ""}
      <div class="small" style="margin-top:6px;">
        <span class="mono">${escapeHtml(move.region || "-")}</span> ·
        <span class="mono">${escapeHtml(move.fileName || "")}</span><br/>
        <span class="mono">시트:${escapeHtml(move.sheetName || "")} · 연번:${escapeHtml(move.seq)} · 행:${escapeHtml(move.rowIndex)}</span>
      </div>
    `;
  }

  function renderMoveItem(move, dir) {
    // dir: "out" => current school is outSchool, show → inSchool
    // dir: "in"  => current school is inSchool, show ← outSchool
    const who = escapeHtml(move.name || "(이름없음)");
    const other = dir === "out" ? (move.inSchool || "-") : (move.outSchool || "-");
    const arrow = dir === "out" ? "→" : "←";
    const dirLabel = dir === "out" ? "전출" : "전입";

    const chips = [];
    chips.push(pillForType(move.staffType, STAFF_TYPE_META[move.staffType]?.short || move.staffType));
    if (move.note) chips.push(`<span class="pill gray">${escapeHtml(move.note)}</span>`);
    if (move.region) chips.push(`<span class="pill gray">${escapeHtml(move.region)}</span>`);

    return `
      <li class="move-item" data-moveid="${move.id}" data-dir="${escapeHtml(dirLabel)}">
        <span class="who">${who}</span>
        <span class="meta">${arrow} ${escapeHtml(other)} ${chips.join(" ")}</span>
      </li>
    `;
  }

  function bindMoveItemHover() {
    const items = el.moveDetailCard.querySelectorAll(".move-item");
    items.forEach(li => {
      const moveId = Number(li.dataset.moveid);
      const dirLabel = String(li.dataset.dir || "");
      const move = state.moveById.get(moveId);
      if (!move) return;

      li.addEventListener("mouseenter", (e) => {
        showTip(tipHtmlForMove(move, dirLabel), e.clientX, e.clientY);
      });
      li.addEventListener("mousemove", (e) => moveTip(e.clientX, e.clientY));
      li.addEventListener("mouseleave", hideTip);

      // 클릭 시 잠깐 고정(모바일 대응 느낌)
      li.addEventListener("click", (e) => {
        showTip(tipHtmlForMove(move, dirLabel), e.clientX, e.clientY, 2400);
      });
    });
  }

  function renderMoveLists(rec) {
    const job = state.selectedJob;

    let outGroups = [];
    let inGroups = [];

    if (job === "__ALL__") {
      const jobNames = [...rec.byJob.keys()].sort((a,b)=>a.localeCompare(b,"ko"));
      for (const j of jobNames) {
        const ji = rec.byJob.get(j);
        if (!ji) continue;

        if (ji.outMoves.length) outGroups.push({ jobName: j, staffType: normalizeStaffType(ji.staffType), moves: ji.outMoves, count: ji.outMoves.length });
        if (ji.inMoves.length) inGroups.push({ jobName: j, staffType: normalizeStaffType(ji.staffType), moves: ji.inMoves, count: ji.inMoves.length });
      }
    } else {
      const ji = rec.byJob.get(job);
      const st = normalizeStaffType(ji?.staffType || "교육공무직");
      outGroups = ji && ji.outMoves.length ? [{ jobName: job, staffType: st, moves: ji.outMoves, count: ji.outMoves.length }] : [];
      inGroups = ji && ji.inMoves.length ? [{ jobName: job, staffType: st, moves: ji.inMoves, count: ji.inMoves.length }] : [];
    }

    // CSV용: 현재 보여주는 명단(전출+전입)
    const flatMoves = [];
    for (const g of outGroups) for (const m of g.moves) flatMoves.push({ dir: "전출", jobName: g.jobName, staffType: g.staffType, move: m });
    for (const g of inGroups) for (const m of g.moves) flatMoves.push({ dir: "전입", jobName: g.jobName, staffType: g.staffType, move: m });
    state.lastMoveList = flatMoves;

    const headerPills = renderTypeHeaderPills(rec.summary);

    const title = job === "__ALL__"
      ? `<b>${escapeHtml(formatSchoolLabel(rec))}</b> · <span class="pill gray">전체 직종</span>`
      : `<b>${escapeHtml(formatSchoolLabel(rec))}</b> · <span class="pill gray">${escapeHtml(job)}</span>`;

    function renderGroupList(groups, dir) {
      if (!groups.length) return `<p class="muted" style="margin:8px 0 0;">없음</p>`;

      if (job === "__ALL__") {
        return groups.map(g => {
          const moves = sortMovesForDisplay(g.moves);
          const badge = dir === "out"
            ? `<span class="pill red">전출 ${g.count}</span>`
            : `<span class="pill blue">전입 ${g.count}</span>`;

          const typeChip = pillForType(g.staffType, g.staffType);

          const listHtml = moves.map(m => renderMoveItem(m, dir)).join("");
          return `
            <details class="job-group" ${g.count > 0 ? "open" : ""}>
              <summary>
                <span>${escapeHtml(g.jobName)} ${typeChip}</span>
                <span>${badge}</span>
              </summary>
              <div class="group-body">
                <ul class="clean-list">${listHtml}</ul>
              </div>
            </details>
          `;
        }).join("");
      }

      const moves = sortMovesForDisplay(groups[0].moves);
      const listHtml = moves.map(m => renderMoveItem(m, dir)).join("");
      return `<ul class="clean-list">${listHtml}</ul>`;
    }

    el.moveDetailCard.innerHTML = `
      <div class="row between" style="flex-wrap:wrap; margin-bottom:8px;">
        <h3 class="local-h3 local-tight" style="margin:0;">명단</h3>
        <div class="row gap" style="flex-wrap:wrap;">${headerPills}</div>
      </div>

      <p class="muted" style="margin-top:0;">${title}</p>

      <div class="grid two">
        <div class="card" style="background:#fff;">
          <h4 class="local-h4 local-tight" style="margin:0;">전출·퇴직 명단</h4>
          <p class="muted" style="margin:6px 0 0;">(이 학교를 떠나는 사람들)</p>
          ${renderGroupList(outGroups, "out")}
        </div>

        <div class="card" style="background:#fff;">
          <h4 class="local-h4 local-tight" style="margin:0;">전입 명단</h4>
          <p class="muted" style="margin:6px 0 0;">(이 학교로 오는 사람들)</p>
          ${renderGroupList(inGroups, "in")}
        </div>
      </div>

      <p class="note">
        ※ 결원 의심은 “전출·퇴직 &gt; 전입” 기반 후보이며,
        직군(지방/교육/공무직) 분리는 규칙 또는 기본 추정 로직을 사용합니다.
      </p>
    `;

    // hover 바인딩
    bindMoveItemHover();

    // 직종표 선택 표시
    [...el.jobTableBody.querySelectorAll("tr")].forEach(tr => {
      tr.classList.toggle("is-selected", tr.dataset.job === state.selectedJob);
    });
  }

  // ---------------------------
  // Events
  // ---------------------------
  el.fileInput.addEventListener("change", () => {
    state.files = (el.fileInput.files ? Array.from(el.fileInput.files) : []).filter(Boolean);
    state.analyzed = false;

    if (!state.files.length) {
      el.fileMeta.textContent = "아직 파일이 없습니다.";
      el.fileList.innerHTML = "";
      return;
    }

    const totalBytes = state.files.reduce((a,f)=>a+(f.size||0), 0);
    el.fileMeta.innerHTML = `파일 <b>${state.files.length}</b>개 선택됨 · 총 ${bytesToHuman(totalBytes)}`;

    const listHtml = state.files.map(f => {
      const region = parseRegionFromFilename(f.name);
      const meta = `${bytesToHuman(f.size)} · 수정 ${new Date(f.lastModified).toLocaleString()}`;
      return `<div>• <b>${escapeHtml(f.name)}</b>${region ? ` <span class="pill gray">구분:${escapeHtml(region)}</span>` : ""}<br/><span class="muted">${escapeHtml(meta)}</span></div>`;
    }).join("<div style='height:8px;'></div>");

    el.fileList.innerHTML = listHtml;
    log(`파일 선택: ${state.files.length}개`);
  });

  el.btnAnalyze.addEventListener("click", () => {
    analyzeCurrentFiles().catch(err => {
      console.error(err);
      log("에러: " + (err && err.message ? err.message : String(err)));
    });
  });

  el.btnClear.addEventListener("click", () => {
    resetAll();

    el.fileInput.value = "";
    el.fileMeta.textContent = "아직 파일이 없습니다.";
    el.fileList.innerHTML = "";

    el.schoolSummarySection.style.display = "none";
    el.suspectSection.style.display = "none";
    el.detailSection.style.display = "none";

    el.schoolSummaryBody.innerHTML = "";
    el.suspectTableBody.innerHTML = "";
    el.jobTableBody.innerHTML = "";
    el.schoolSelect.innerHTML = "";
    el.jobSelect.innerHTML = "";

    ensureCustomSelects();
    custom.school.refresh();
    custom.job.refresh();

    el.schoolFilter.value = "";
    el.suspectFilter.value = "";
    el.jobFilter.value = "";

    el.moveDetailCard.innerHTML = `
      <h3 class="local-h3 local-tight">명단</h3>
      <p class="muted" style="margin-top:0;">분석 후 학교를 선택하세요.</p>
    `;

    clearLog();
    log("초기화 완료");
  });

  // 요약 필터/정렬
  el.schoolFilter.addEventListener("input", () => renderSchoolSummary());
  el.schoolModeSelect.addEventListener("change", () => renderSchoolSummary());
  el.schoolSortKey.addEventListener("change", () => renderSchoolSummary());
  el.schoolSortDir.addEventListener("change", () => renderSchoolSummary());

  // 결원 의심 목록 필터/정렬
  el.suspectFilter.addEventListener("input", () => renderSuspectList());
  el.suspectSortKey.addEventListener("change", () => renderSuspectList());
  el.suspectSortDir.addEventListener("change", () => renderSuspectList());

  // 상세 셀렉트
  el.schoolSelect.addEventListener("change", () => {
    const key = el.schoolSelect.value;
    selectSchool(key, "__ALL__");
  });

  el.jobSelect.addEventListener("change", () => {
    const rec = state.schools.get(state.selectedSchoolKey);
    if (!rec) return;

    // jobSelect는 텍스트에 [직군]이 붙었지만 value는 jobName
    state.selectedJob = el.jobSelect.value;
    ensureCustomSelects();
    custom.job.sync();
    renderMoveLists(rec);
  });

  // 직종표 필터/보기/정렬
  el.jobFilter.addEventListener("input", () => {
    const rec = state.schools.get(state.selectedSchoolKey);
    if (!rec) return;
    renderJobTable(rec);
  });

  el.jobModeSelect.addEventListener("change", () => {
    const rec = state.schools.get(state.selectedSchoolKey);
    if (!rec) return;
    renderJobTable(rec);
  });

  el.jobSortKey.addEventListener("change", () => {
    const rec = state.schools.get(state.selectedSchoolKey);
    if (!rec) return;
    renderJobTable(rec);
  });

  el.jobSortDir.addEventListener("change", () => {
    const rec = state.schools.get(state.selectedSchoolKey);
    if (!rec) return;
    renderJobTable(rec);
  });

  // 직군 규칙 적용
  el.btnApplyTypeRules.addEventListener("click", () => {
    state.typeRulesParsed = parseMappingRules(el.typeRules.value);
    if (state.typeRulesParsed?.groups?.length) {
      el.typeHint.textContent = `규칙 ${state.typeRulesParsed.groups.length}개 적용됨`;
    } else {
      el.typeHint.textContent = "규칙 없음 → 기본 추정 분류 사용";
    }

    if (state.analyzed) {
      rebuildAggregationsFromMoves({ preserveSelection: true });
    }
    log("직군 규칙 적용 완료");
  });

  el.btnFillTypeSample.addEventListener("click", () => {
    const sample = [
      "# 예시: 부분일치는 * 로 감싸기",
      "지방공무원 = *주무관*, *행정직*, *시설직*, *공업직*, *운전직*",
      "교육공무원 = *교장*, *교감*, *교사*, *사서교사*, *보건교사*",
      "교육공무직 = *실무사*, *전담사*, *조리*, *영양사*, *교무행정사*, *늘봄*, *돌봄*",
    ].join("\n");
    el.typeRules.value = sample;
    el.typeHint.textContent = "예시 입력됨 → '직군 규칙 적용'을 눌러 반영";
    log("직군 규칙 예시를 채웠습니다. 필요에 맞게 수정 후 적용하세요.");
  });

  // 옵션 변경 시 재집계(분석된 경우)
  el.optNormalize.addEventListener("change", () => {
    if (!state.analyzed) return;
    rebuildAggregationsFromMoves({ preserveSelection: false });
    log("옵션 변경: 학교명 정규화 → 재집계 완료");
  });

  el.optSchoolKeyPrefix.addEventListener("change", () => {
    if (!state.analyzed) return;
    rebuildAggregationsFromMoves({ preserveSelection: false });
    log("옵션 변경: 학교키 구분 포함 → 재집계 완료");
  });

  // CSV downloads
  el.btnDownloadSchoolSummary.addEventListener("click", () => {
    if (!state.analyzed) { log("다운로드할 데이터가 없습니다."); return; }
    const q = (el.schoolFilter.value || "").trim();
    const mode = el.schoolModeSelect.value;
    const filename = sanitizeFilename(`학교별요약_${mode}${q ? "_filter" : ""}.csv`);

    const rows = [[
      "구분", "학교(부서)",
      "전출", "전입",
      "결원 의심(총)",
      "결원 의심(지방공무원)", "결원 의심(교육공무원)", "결원 의심(교육공무직)",
      "순증가(총)",
      "순증가(지방공무원)", "순증가(교육공무원)", "순증가(교육공무직)",
      "총차이(전출-전입)",
      "직종수"
    ]];

    for (const s of state.lastSchoolSummaryList) {
      const T = s.typeAgg || emptyTypeAgg();
      rows.push([
        s.regionText || "-",
        s.school,
        s.outTotal,
        s.inTotal,
        s.shortagePositions,
        T["지방공무원"].shortagePositions,
        T["교육공무원"].shortagePositions,
        T["교육공무직"].shortagePositions,
        s.surplusPositions,
        T["지방공무원"].surplusPositions,
        T["교육공무원"].surplusPositions,
        T["교육공무직"].surplusPositions,
        s.netDiff,
        s.jobCount
      ]);
    }

    downloadCsv(filename, rows);
    log(`CSV 다운로드: ${filename}`);
  });

  el.btnDownloadSuspect.addEventListener("click", () => {
    if (!state.analyzed) { log("다운로드할 데이터가 없습니다."); return; }
    const q = (el.suspectFilter.value || "").trim();
    const filename = sanitizeFilename(`전체_결원의심_학교-직종${q ? "_filter" : ""}.csv`);

    const rows = [["구분", "학교(부서)", "직군", "직종", "전출", "전입", "결원 의심(전출-전입)", "전입없음"]];
    for (const r of state.lastSuspectList) {
      rows.push([r.regionText || "-", r.school, r.staffType, r.jobName, r.outC, r.inC, r.diff, r.noIncoming ? "Y" : ""]);
    }

    downloadCsv(filename, rows);
    log(`CSV 다운로드: ${filename}`);
  });

  el.btnDownloadSchoolJobs.addEventListener("click", () => {
    if (!state.analyzed || !state.selectedSchoolKey) { log("다운로드할 데이터가 없습니다."); return; }
    const rec = state.schools.get(state.selectedSchoolKey);
    if (!rec || !rec.summary) { log("다운로드할 데이터가 없습니다."); return; }

    const q = (el.jobFilter.value || "").trim();
    const mode = el.jobModeSelect.value;
    const filename = sanitizeFilename(`학교_${formatSchoolLabel(rec)}_직종표_${mode}${q ? "_filter" : ""}.csv`);

    const rows = [["구분", "학교(부서)", "직군", "직종", "전출", "전입", "차이(전출-전입)", "전입없음"]];
    for (const r of state.lastSchoolJobList) {
      rows.push([getRegionText(rec), rec.school, r.staffType, r.jobName, r.outC, r.inC, r.diff, r.noIncoming ? "Y" : ""]);
    }

    downloadCsv(filename, rows);
    log(`CSV 다운로드: ${filename}`);
  });

  el.btnDownloadSchoolMoves.addEventListener("click", () => {
    if (!state.analyzed || !state.selectedSchoolKey) { log("다운로드할 데이터가 없습니다."); return; }
    const rec = state.schools.get(state.selectedSchoolKey);
    if (!rec) { log("다운로드할 데이터가 없습니다."); return; }

    const job = state.selectedJob;
    const filename = sanitizeFilename(`학교_${formatSchoolLabel(rec)}_${job==="__ALL__"?"전체직종":"직종_"+job}_명단.csv`);

    const rows = [["구분", "학교(부서)", "직군", "직종", "방향(학교기준)", "성명", "상대학교", "비고", "파일", "시트", "연번", "원본행"]];
    for (const x of state.lastMoveList) {
      const m = x.move;
      const other = x.dir === "전출" ? (m.inSchool || "") : (m.outSchool || "");
      rows.push([
        m.region || "",
        rec.school,
        m.staffType || "",
        x.jobName,
        x.dir,
        m.name || "",
        other,
        m.note || "",
        m.fileName || "",
        m.sheetName || "",
        m.seq ?? "",
        m.rowIndex ?? ""
      ]);
    }

    downloadCsv(filename, rows);
    log(`CSV 다운로드: ${filename}`);
  });

  // ---------------------------
  // Init
  // ---------------------------
  async function init() {
    log("페이지 로드 완료");
    log("엑셀 업로드 후 '분석 실행'을 누르세요.");

    ensureCustomSelects();

    const ok = await ensureXLSX();
    setLibWarning(ok);

    // 버튼 스타일 체크(디버깅용)
    const probe = document.createElement("button");
    probe.className = "btn";
    probe.style.position = "absolute";
    probe.style.left = "-9999px";
    probe.textContent = "probe";
    document.body.appendChild(probe);
    const br = getComputedStyle(probe).borderRadius;
    document.body.removeChild(probe);
    log(`버튼 스타일 체크: .btn border-radius = ${br} (회색/각진이면 CSS 미적용 가능성)`);

    // 초기 힌트
    const parsed = parseMappingRules(el.typeRules.value);
    if (parsed?.groups?.length) el.typeHint.textContent = `규칙 ${parsed.groups.length}개 입력됨 (적용 버튼 필요)`;
    else el.typeHint.textContent = "규칙 없음 → 기본 추정 분류 사용";
  }

  document.addEventListener("DOMContentLoaded", init);
})();
</script>

</body>
</html>
