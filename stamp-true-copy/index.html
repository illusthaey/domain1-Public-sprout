<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="/static/style.css" />
  <title>원본대조필 도장 찍기 (실측 6.1×2.5cm)</title>

  <!-- pdf-lib (PDF 편집/저장) -->
  <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>

  <!-- PDF.js (미리보기 렌더링) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

  <style>
    /* 추가 CSS 파일 금지 조건이므로, 최소한의 인라인 스타일만 사용 */
    .stage-wrap { margin-top: 14px; }
    .stage {
      position: relative;
      display: inline-block;
      max-width: 100%;
      touch-action: none;
      user-select: none;
    }
    #pdfCanvas {
      display: block;
      max-width: 100%;
      height: auto;
      border: 1px solid #e5e5e5;
      border-radius: 12px;
      background: #fff;
    }

    #stampOverlay {
      position: absolute;
      box-sizing: border-box;
      border: 2px solid rgba(17, 24, 39, 0.65);
      border-radius: 10px;
      cursor: grab;
      touch-action: none;
      user-select: none;
      transform-origin: center center;
      background: rgba(255,255,255,0.10);
      backdrop-filter: blur(0.2px);
    }
    #stampOverlay.dragging { cursor: grabbing; }

    #stampOverlay img {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: fill; /* PDF에 찍힐 때도 fixed W/H로 늘어나므로 미리보기와 일치 */
      pointer-events: none;
      border-radius: 8px;
    }

    #innerGuide {
      position: absolute;
      pointer-events: none;
      border: 2px dashed rgba(17, 24, 39, 0.35);
      border-radius: 8px;
      box-sizing: border-box;
    }

    #overlayLabel {
      position: absolute;
      left: 8px;
      top: 8px;
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 12px;
      background: rgba(255,255,255,0.85);
      border: 1px solid rgba(0,0,0,0.08);
      pointer-events: none;
      color: #111;
      font-weight: 700;
    }

    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .hint { margin-top: 10px; }
  </style>
</head>

<body>
  <header class="site-header">
    <div class="shell">
      <div class="row between">
        <div style="font-weight:700;">업무보조</div>
        <a class="btn btn-home" href="/">홈</a>
      </div>
    </div>
  </header>

  <main>
    <div class="container">
      <h1>원본대조필 도장 찍기</h1>
      <p class="subtitle">
        도장 실측: <b>가로 6.1cm × 세로 2.5cm</b> (PDF 포인트로 고정 삽입).<br/>
        정확한 실측을 원하면 출력 시 <b>“실제 크기(100%)”</b>로 인쇄하세요.
      </p>

      <section class="section">
        <div class="card">
          <form id="form">
            <div class="grid two">
              <div>
                <div class="local-small muted" style="margin-bottom:6px;">PDF 파일 (필수)</div>
                <input id="pdfInput" type="file" accept="application/pdf" required />
                <div class="muted local-small" style="margin-top:6px;">
                  첫 페이지 미리보기가 아래에 표시됩니다.
                </div>
              </div>

              <div>
                <div class="local-small muted" style="margin-bottom:6px;">도장 PNG (필수, 투명 권장)</div>
                <input id="stampInput" type="file" accept="image/png,image/webp,image/jpeg" required />
                <div class="muted local-small" style="margin-top:6px;">
                  업로드 도장은 자동으로 <b>여백 트림</b> + <b>배경 투명화</b>됩니다.
                </div>
              </div>
            </div>

            <hr />

            <div class="grid three">
              <div>
                <div class="local-small muted" style="margin-bottom:6px;">회전 각도(도)</div>
                <input id="angleDeg" type="number" min="-180" max="180" step="1" value="0" />
                <div class="muted local-small" style="margin-top:6px;">
                  도장 중심 기준 회전
                </div>
              </div>

              <div>
                <div class="local-small muted" style="margin-bottom:6px;">불투명도</div>
                <input id="opacity" type="number" min="0.1" max="1" step="0.05" value="0.45" />
                <div class="muted local-small" style="margin-top:6px;">
                  0.35~0.6 추천
                </div>
              </div>

              <div>
                <div class="local-small muted" style="margin-bottom:6px;">도장 위치 초기화</div>
                <div class="row gap">
                  <button id="resetBR" class="btn ghost" type="button">우하단 기본</button>
                  <button id="resetCenter" class="btn ghost" type="button">가운데</button>
                </div>
                <div class="muted local-small" style="margin-top:6px;">
                  미리보기에서 드래그/클릭으로 이동
                </div>
              </div>
            </div>

            <div class="card hint">
              <div class="muted local-small">
                <b>사용법</b><br/>
                1) PDF 업로드 → 2) 도장 PNG 업로드 → 3) 첫 페이지 미리보기에서 도장 박스를 드래그해 위치 지정 → 4) 다운로드
              </div>
            </div>

            <div class="stage-wrap" id="stageWrap" style="display:none;">
              <div class="muted local-small" style="margin: 10px 0 8px;">
                첫 페이지 미리보기(여기서 도장 위치를 지정하세요)
              </div>

              <div class="stage" id="stage">
                <canvas id="pdfCanvas"></canvas>

                <div id="stampOverlay" aria-label="stamp overlay">
                  <img id="stampOverlayImg" alt="" style="display:none;" />
                  <div id="innerGuide"></div>
                  <div id="overlayLabel">6.1×2.5cm</div>
                </div>
              </div>

              <div class="muted local-small mono" id="coordReadout" style="margin-top:8px;"></div>
            </div>

            <div class="row between" style="margin-top:16px;">
              <button id="submitBtn" class="btn primary" type="submit">도장 찍고 다운로드</button>
              <div id="status" class="muted local-small"></div>
            </div>
          </form>
        </div>
      </section>

      <section class="section">
        <div class="card">
          <h3 class="local-h3">주의</h3>
          <ul class="tool-list">
            <li>실측 크기는 PDF 내 포인트(pt)로 고정 삽입되며, 출력 시 “페이지에 맞춤”을 켜면 실측이 달라질 수 있습니다.</li>
            <li>도장 PNG에 여백이 크면 실제 도장 글자가 작아지므로, 본 도구는 자동으로 여백을 트림합니다.</li>
          </ul>
        </div>
      </section>
    </div>
  </main>

  <footer class="site-footer">
    <div class="shell">
      <p>© 업무보조</p>
    </div>
  </footer>

  <script>
    "use strict";

    // =========================
    // 라이브러리 준비
    // =========================
    if (!window.pdfjsLib) {
      console.error("PDF.js 로드 실패");
    } else {
      // PDF.js worker 설정
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
    }

    // =========================
    // 실측 도장 크기 고정 (cm -> pt)
    // =========================
    const CM_TO_PT = 72 / 2.54;
    const STAMP_W_CM = 6.1;
    const STAMP_H_CM = 2.5;
    const BORDER_CM  = 0.5;

    const STAMP_W_PT = STAMP_W_CM * CM_TO_PT;  // ≈ 172.913
    const STAMP_H_PT = STAMP_H_CM * CM_TO_PT;  // ≈ 70.866
    const BORDER_PT  = BORDER_CM  * CM_TO_PT;  // ≈ 14.173

    const MAX_PDF_BYTES = 30 * 1024 * 1024;

    // =========================
    // DOM
    // =========================
    const $ = (sel) => document.querySelector(sel);
    const pdfInput = $("#pdfInput");
    const stampInput = $("#stampInput");
    const angleDegInput = $("#angleDeg");
    const opacityInput = $("#opacity");
    const stageWrap = $("#stageWrap");
    const stage = $("#stage");
    const pdfCanvas = $("#pdfCanvas");
    const overlay = $("#stampOverlay");
    const overlayImg = $("#stampOverlayImg");
    const innerGuide = $("#innerGuide");
    const coordReadout = $("#coordReadout");
    const submitBtn = $("#submitBtn");

    function setStatus(msg) {
      $("#status").textContent = msg || "";
    }

    function clamp(n, min, max) {
      return Math.max(min, Math.min(max, n));
    }

    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function readFileAsArrayBuffer(file) {
      return new Promise((resolve, reject) => {
        const r = new FileReader();
        r.onload = () => resolve(r.result);
        r.onerror = () => reject(r.error);
        r.readAsArrayBuffer(file);
      });
    }

    // =========================
    // 상태
    // =========================
    const state = {
      pdf: {
        bytes: null,          // ArrayBuffer
        doc: null,            // PDF.js document
        page1: null,          // PDF.js page
        viewport: null,       // PDF.js viewport (scale 적용)
        scale: null,          // viewport scale
        pageWpt: null,        // 1페이지 폭(pt)
        pageHpt: null,        // 1페이지 높이(pt)
        normX: null,          // 선택 중심 좌표 (0~1)
        normY: null,
      },
      stamp: {
        pngBytes: null,       // Uint8Array (trim + 투명화된 PNG)
        previewUrl: null,     // ObjectURL
      },
      overlay: {
        wPx: 0,
        hPx: 0,
        cxPx: 0,
        cyPx: 0,
      },
      dragging: {
        active: false,
        pointerId: null,
        dx: 0,
        dy: 0,
        moved: false,
      }
    };

    // =========================
    // 도장 이미지: 트림 + 배경 투명화
    // =========================
    function loadImageFromArrayBuffer(ab) {
      return new Promise((resolve, reject) => {
        const blob = new Blob([ab]);
        const url = URL.createObjectURL(blob);
        const img = new Image();
        img.decoding = "async";
        img.onload = () => { URL.revokeObjectURL(url); resolve(img); };
        img.onerror = () => { URL.revokeObjectURL(url); reject(new Error("도장 이미지 로드 실패")); };
        img.src = url;
      });
    }

    async function canvasToPngBytes(canvas) {
      const blob = await new Promise((resolve) => canvas.toBlob(resolve, "image/png"));
      const ab = await blob.arrayBuffer();
      return new Uint8Array(ab);
    }

    function computeStampBBox(imageData, bgThreshold = 245) {
      const { data, width, height } = imageData;

      let minX = width, minY = height, maxX = -1, maxY = -1;
      let found = 0;

      for (let y = 0; y < height; y++) {
        const row = y * width;
        for (let x = 0; x < width; x++) {
          const i = (row + x) * 4;
          const r = data[i], g = data[i + 1], b = data[i + 2], a = data[i + 3];

          // 배경 판정:
          // - 완전/거의 투명은 배경
          // - 거의 흰색은 배경(비투명 이미지 대비)
          const isTransparentBg = a < 16;
          const isWhiteBg = (r >= bgThreshold && g >= bgThreshold && b >= bgThreshold);

          const isBg = isTransparentBg || isWhiteBg;
          if (!isBg) {
            found++;
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
          }
        }
      }

      if (!found || maxX < 0) return null;

      // 아주 약간의 안전 여유(1px): 안티앨리어싱 가장자리 살리기
      const pad = 1;
      minX = Math.max(0, minX - pad);
      minY = Math.max(0, minY - pad);
      maxX = Math.min(width - 1, maxX + pad);
      maxY = Math.min(height - 1, maxY + pad);

      return { minX, minY, maxX, maxY };
    }

    async function trimAndTransparentizeStamp(stampArrayBuffer) {
      const img = await loadImageFromArrayBuffer(stampArrayBuffer);
      const srcW = img.naturalWidth || img.width;
      const srcH = img.naturalHeight || img.height;

      const srcCanvas = document.createElement("canvas");
      srcCanvas.width = srcW;
      srcCanvas.height = srcH;
      const sctx = srcCanvas.getContext("2d", { willReadFrequently: true });
      sctx.drawImage(img, 0, 0);

      const imgData = sctx.getImageData(0, 0, srcW, srcH);
      const bbox = computeStampBBox(imgData, 245);
      if (!bbox) throw new Error("도장 이미지에서 도장을 찾지 못했습니다(배경/투명 확인).");

      const w = bbox.maxX - bbox.minX + 1;
      const h = bbox.maxY - bbox.minY + 1;

      const outCanvas = document.createElement("canvas");
      outCanvas.width = w;
      outCanvas.height = h;
      const octx = outCanvas.getContext("2d", { willReadFrequently: true });
      octx.drawImage(srcCanvas, bbox.minX, bbox.minY, w, h, 0, 0, w, h);

      // 배경(흰색/투명) -> alpha 0 처리
      const outData = octx.getImageData(0, 0, w, h);
      const p = outData.data;
      const t = 245;

      for (let i = 0; i < p.length; i += 4) {
        const r = p[i], g = p[i + 1], b = p[i + 2], a = p[i + 3];
        if (a < 16) { p[i + 3] = 0; continue; }
        const isWhite = (r >= t && g >= t && b >= t);
        if (isWhite) p[i + 3] = 0;
      }

      octx.putImageData(outData, 0, 0);

      const pngBytes = await canvasToPngBytes(outCanvas);

      // preview URL
      const blob = new Blob([pngBytes], { type: "image/png" });
      const url = URL.createObjectURL(blob);

      return { pngBytes, previewUrl: url };
    }

    function setStampPreview(url) {
      // 이전 URL 정리
      if (state.stamp.previewUrl) {
        try { URL.revokeObjectURL(state.stamp.previewUrl); } catch (_) {}
      }
      state.stamp.previewUrl = url;

      overlayImg.src = url;
      overlayImg.style.display = "block";
      updateOverlayOpacity();
    }

    // =========================
    // PDF 1페이지 렌더링 (PDF.js)
    // =========================
    function getFitScale(pageViewport1, targetCssWidth) {
      const scale = targetCssWidth / pageViewport1.width;
      return clamp(scale, 0.25, 3.0);
    }

    async function renderFirstPage() {
      const page = state.pdf.page1;
      if (!page) return;

      // 컨테이너 폭에 맞춰 scale 결정
      const containerWidth = Math.max(320, Math.min(stageWrap.clientWidth || 800, 860));

      const viewport1 = page.getViewport({ scale: 1 });
      const scale = getFitScale(viewport1, containerWidth);

      const viewport = page.getViewport({ scale });
      state.pdf.viewport = viewport;
      state.pdf.scale = scale;
      state.pdf.pageWpt = viewport1.width;
      state.pdf.pageHpt = viewport1.height;

      // 캔버스 DPR 렌더
      const dpr = window.devicePixelRatio || 1;
      const canvas = pdfCanvas;
      const ctx = canvas.getContext("2d", { alpha: false });

      canvas.width = Math.floor(viewport.width * dpr);
      canvas.height = Math.floor(viewport.height * dpr);
      canvas.style.width = `${Math.floor(viewport.width)}px`;
      canvas.style.height = `${Math.floor(viewport.height)}px`;

      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.clearRect(0, 0, viewport.width, viewport.height);

      setStatus("첫 페이지 렌더링 중…");
      await page.render({ canvasContext: ctx, viewport }).promise;

      stageWrap.style.display = "block";

      // 오버레이 크기(px) 계산: 실측 pt * scale
      state.overlay.wPx = STAMP_W_PT * scale;
      state.overlay.hPx = STAMP_H_PT * scale;

      // inner guide: border thickness(0.5cm) 표시 (미리보기용)
      const borderPx = BORDER_PT * scale;
      innerGuide.style.left = `${borderPx}px`;
      innerGuide.style.top = `${borderPx}px`;
      innerGuide.style.width = `${Math.max(0, state.overlay.wPx - 2 * borderPx)}px`;
      innerGuide.style.height = `${Math.max(0, state.overlay.hPx - 2 * borderPx)}px`;

      overlay.style.width = `${state.overlay.wPx}px`;
      overlay.style.height = `${state.overlay.hPx}px`;

      // 위치 복원: norm 좌표가 있으면 그걸 사용, 없으면 우하단 기본
      if (state.pdf.normX != null && state.pdf.normY != null) {
        const cxPt = state.pdf.normX * state.pdf.pageWpt;
        const cyPt = state.pdf.normY * state.pdf.pageHpt;
        const [cxPx, cyPx] = viewport.convertToViewportPoint(cxPt, cyPt);
        setOverlayCenterPx(cxPx, cyPx);
      } else {
        resetOverlayToBottomRight();
      }

      updateOverlayTransform();
      updateReadout();
      setStatus("미리보기에서 도장 위치를 지정하세요.");
    }

    async function loadPdfForPreview(pdfArrayBuffer) {
      if (!window.pdfjsLib) throw new Error("PDF.js 로드 실패(CDN 차단 여부 확인).");

      const loadingTask = pdfjsLib.getDocument({ data: pdfArrayBuffer });
      const pdfDoc = await loadingTask.promise;
      const page1 = await pdfDoc.getPage(1);

      state.pdf.bytes = pdfArrayBuffer;
      state.pdf.doc = pdfDoc;
      state.pdf.page1 = page1;

      // norm 초기화(새 PDF면 위치 초기화)
      state.pdf.normX = null;
      state.pdf.normY = null;

      await renderFirstPage();
    }

    // =========================
    // 오버레이 위치/드래그
    // =========================
    function setOverlayCenterPx(cx, cy) {
      state.overlay.cxPx = cx;
      state.overlay.cyPx = cy;

      const left = cx - state.overlay.wPx / 2;
      const top  = cy - state.overlay.hPx / 2;

      overlay.style.left = `${left}px`;
      overlay.style.top = `${top}px`;

      updateNormFromOverlayCenter();
      updateReadout();
    }

    function updateNormFromOverlayCenter() {
      const vp = state.pdf.viewport;
      if (!vp) return;

      // viewport(픽셀 좌표) -> PDF pt
      const [cxPt, cyPt] = vp.convertToPdfPoint(state.overlay.cxPx, state.overlay.cyPx);

      const w = state.pdf.pageWpt;
      const h = state.pdf.pageHpt;
      if (!w || !h) return;

      state.pdf.normX = cxPt / w;
      state.pdf.normY = cyPt / h;
    }

    function updateReadout() {
      const vp = state.pdf.viewport;
      if (!vp || state.pdf.normX == null) {
        coordReadout.textContent = "";
        return;
      }

      const cxPt = state.pdf.normX * state.pdf.pageWpt;
      const cyPt = state.pdf.normY * state.pdf.pageHpt;

      // pt -> cm (참고 표시)
      const ptToCm = 2.54 / 72;
      const cxCm = cxPt * ptToCm;
      const cyCm = cyPt * ptToCm;

      coordReadout.textContent =
        `중심 좌표(첫 페이지 기준): X=${cxPt.toFixed(1)}pt (${cxCm.toFixed(2)}cm), ` +
        `Y=${cyPt.toFixed(1)}pt (${cyCm.toFixed(2)}cm)  |  ` +
        `도장 크기: ${STAMP_W_PT.toFixed(1)}×${STAMP_H_PT.toFixed(1)}pt (6.1×2.5cm)`;
    }

    function getStagePointFromEvent(e) {
      const r = stage.getBoundingClientRect();
      const x = e.clientX - r.left;
      const y = e.clientY - r.top;
      return { x, y };
    }

    overlay.addEventListener("pointerdown", (e) => {
      if (!state.pdf.viewport) return;
      e.preventDefault();

      const p = getStagePointFromEvent(e);

      const left = parseFloat(overlay.style.left || "0");
      const top  = parseFloat(overlay.style.top || "0");

      state.dragging.active = true;
      state.dragging.pointerId = e.pointerId;
      state.dragging.dx = p.x - left;
      state.dragging.dy = p.y - top;
      state.dragging.moved = false;

      overlay.classList.add("dragging");
      overlay.setPointerCapture(e.pointerId);
    });

    overlay.addEventListener("pointermove", (e) => {
      if (!state.dragging.active || e.pointerId !== state.dragging.pointerId) return;
      e.preventDefault();

      const p = getStagePointFromEvent(e);

      let left = p.x - state.dragging.dx;
      let top  = p.y - state.dragging.dy;

      // 캔버스 안쪽으로 clamp(기본 bbox 기준)
      const stageW = parseFloat(pdfCanvas.style.width || pdfCanvas.getBoundingClientRect().width);
      const stageH = parseFloat(pdfCanvas.style.height || pdfCanvas.getBoundingClientRect().height);

      left = clamp(left, 0, Math.max(0, stageW - state.overlay.wPx));
      top  = clamp(top, 0, Math.max(0, stageH - state.overlay.hPx));

      overlay.style.left = `${left}px`;
      overlay.style.top = `${top}px`;

      const cx = left + state.overlay.wPx / 2;
      const cy = top + state.overlay.hPx / 2;
      state.overlay.cxPx = cx;
      state.overlay.cyPx = cy;

      state.dragging.moved = true;

      updateNormFromOverlayCenter();
      updateReadout();
    });

    overlay.addEventListener("pointerup", (e) => {
      if (e.pointerId !== state.dragging.pointerId) return;
      state.dragging.active = false;
      state.dragging.pointerId = null;
      overlay.classList.remove("dragging");
      try { overlay.releasePointerCapture(e.pointerId); } catch (_) {}
    });

    overlay.addEventListener("pointercancel", (e) => {
      if (e.pointerId !== state.dragging.pointerId) return;
      state.dragging.active = false;
      state.dragging.pointerId = null;
      overlay.classList.remove("dragging");
      try { overlay.releasePointerCapture(e.pointerId); } catch (_) {}
    });

    // 스테이지 클릭: 도장 중심을 클릭 위치로 이동 (드래그로 이동한 직후 클릭 오작동 방지)
    stage.addEventListener("click", (e) => {
      if (!state.pdf.viewport) return;
      if (state.dragging.moved) {
        // 드래그 직후 click 이벤트가 발생하는 브라우저가 있어 방지
        state.dragging.moved = false;
        return;
      }
      const p = getStagePointFromEvent(e);

      // 클릭 위치를 중심으로, bbox를 캔버스 안쪽으로 clamp
      const stageW = parseFloat(pdfCanvas.style.width || pdfCanvas.getBoundingClientRect().width);
      const stageH = parseFloat(pdfCanvas.style.height || pdfCanvas.getBoundingClientRect().height);

      const cx = clamp(p.x, state.overlay.wPx / 2, stageW - state.overlay.wPx / 2);
      const cy = clamp(p.y, state.overlay.hPx / 2, stageH - state.overlay.hPx / 2);

      setOverlayCenterPx(cx, cy);
    });

    // =========================
    // 오버레이 회전/불투명도
    // =========================
    function updateOverlayTransform() {
      const angle = clamp(parseFloat(angleDegInput.value || "0"), -180, 180);
      overlay.style.transform = `rotate(${angle}deg)`;
    }

    function updateOverlayOpacity() {
      const op = clamp(parseFloat(opacityInput.value || "0.45"), 0.1, 1.0);
      overlayImg.style.opacity = String(op);
    }

    angleDegInput.addEventListener("input", () => {
      updateOverlayTransform();
    });

    opacityInput.addEventListener("input", () => {
      updateOverlayOpacity();
    });

    // =========================
    // 기본 위치 버튼
    // =========================
    function resetOverlayToBottomRight() {
      const vp = state.pdf.viewport;
      if (!vp) return;

      const marginPt = 36;
      const cxPt = state.pdf.pageWpt - marginPt - STAMP_W_PT / 2;
      const cyPt = marginPt + STAMP_H_PT / 2;

      const [cxPx, cyPx] = vp.convertToViewportPoint(cxPt, cyPt);
      setOverlayCenterPx(cxPx, cyPx);
    }

    function resetOverlayToCenter() {
      const vp = state.pdf.viewport;
      if (!vp) return;

      const cxPt = state.pdf.pageWpt / 2;
      const cyPt = state.pdf.pageHpt / 2;
      const [cxPx, cyPx] = vp.convertToViewportPoint(cxPt, cyPt);
      setOverlayCenterPx(cxPx, cyPx);
    }

    $("#resetBR").addEventListener("click", () => resetOverlayToBottomRight());
    $("#resetCenter").addEventListener("click", () => resetOverlayToCenter());

    // =========================
    // 입력 이벤트
    // =========================
    pdfInput.addEventListener("change", async () => {
      const file = pdfInput.files && pdfInput.files[0];
      if (!file) return;

      if (!/\.pdf$/i.test(file.name)) {
        setStatus("PDF 파일만 업로드할 수 있습니다.");
        return;
      }
      if (file.size > MAX_PDF_BYTES) {
        setStatus("PDF 파일이 너무 큽니다(30MB 이하 권장).");
        return;
      }

      submitBtn.disabled = true;
      try {
        setStatus("PDF 로딩 중…");
        const ab = await readFileAsArrayBuffer(file);

        // 간단한 헤더 체크
        const head = new TextDecoder("ascii").decode(new Uint8Array(ab).slice(0, 1024));
        if (!head.includes("%PDF-")) throw new Error("PDF로 보이지 않습니다. 파일을 확인해주세요.");

        await loadPdfForPreview(ab);
      } catch (err) {
        setStatus(err && err.message ? err.message : String(err));
      } finally {
        submitBtn.disabled = false;
      }
    });

    stampInput.addEventListener("change", async () => {
      const file = stampInput.files && stampInput.files[0];
      if (!file) return;

      submitBtn.disabled = true;
      try {
        setStatus("도장 이미지 처리 중…");
        const ab = await readFileAsArrayBuffer(file);
        const { pngBytes, previewUrl } = await trimAndTransparentizeStamp(ab);

        state.stamp.pngBytes = pngBytes;
        setStampPreview(previewUrl);

        setStatus("도장 이미지 준비 완료.");
      } catch (err) {
        setStatus(err && err.message ? err.message : String(err));
      } finally {
        submitBtn.disabled = false;
      }
    });

    // =========================
    // PDF에 도장 찍기 (pdf-lib)
    // =========================
    async function stampAllPagesAndDownload() {
      if (!window.PDFLib) throw new Error("pdf-lib 로드 실패(CDN 차단 여부 확인).");
      if (!state.pdf.bytes) throw new Error("PDF 파일을 먼저 업로드하세요.");
      if (!state.stamp.pngBytes) throw new Error("도장 PNG 파일을 업로드하세요.");
      if (state.pdf.normX == null || state.pdf.normY == null) throw new Error("미리보기에서 도장 위치를 지정하세요.");

      const angleDeg = clamp(parseFloat(angleDegInput.value || "0"), -180, 180);
      const opacity = clamp(parseFloat(opacityInput.value || "0.45"), 0.1, 1.0);

      const { PDFDocument, degrees } = PDFLib;

      setStatus("PDF 처리 준비 중…");
      const pdfDoc = await PDFDocument.load(state.pdf.bytes);

      // 도장 1회 임베드
      const stampImg = await pdfDoc.embedPng(state.stamp.pngBytes);

      const pages = pdfDoc.getPages();
      const total = pages.length;

      // 회전 중심 고정 보정
      const theta = angleDeg * Math.PI / 180;
      const cos = Math.cos(theta);
      const sin = Math.sin(theta);

      const drawW = STAMP_W_PT;
      const drawH = STAMP_H_PT;

      // (drawW/2, drawH/2)를 회전시킨 벡터
      const cxRot = (drawW / 2) * cos - (drawH / 2) * sin;
      const cyRot = (drawW / 2) * sin + (drawH / 2) * cos;

      for (let i = 0; i < total; i++) {
        const page = pages[i];
        const { width: pageW, height: pageH } = page.getSize();

        // 첫 페이지에서 잡은 norm 좌표를 각 페이지 크기에 맞춰 적용
        const CX = state.pdf.normX * pageW;
        const CY = state.pdf.normY * pageH;

        // 중심(CX,CY)이 고정되도록 좌하단(x,y) 계산
        const x = CX - cxRot;
        const y = CY - cyRot;

        page.drawImage(stampImg, {
          x, y,
          width: drawW,
          height: drawH,
          rotate: degrees(angleDeg),
          opacity
        });

        if (i === total - 1 || i % 2 === 0) {
          setStatus(`페이지 처리 중… (${i + 1}/${total})`);
          await new Promise(r => setTimeout(r, 0));
        }
      }

      const outBytes = await pdfDoc.save({ useObjectStreams: true });
      return outBytes;
    }

    // 제출
    $("#form").addEventListener("submit", async (e) => {
      e.preventDefault();

      const pdfFile = pdfInput.files && pdfInput.files[0];
      if (!pdfFile) { setStatus("PDF 파일을 선택하세요."); return; }

      submitBtn.disabled = true;
      try {
        const stampedBytes = await stampAllPagesAndDownload();
        const outBlob = new Blob([stampedBytes], { type: "application/pdf" });

        const base = pdfFile.name.replace(/\.pdf$/i, "");
        downloadBlob(outBlob, `stamped_${base}.pdf`);

        setStatus("완료! 다운로드가 시작되었습니다.");
      } catch (err) {
        setStatus(err && err.message ? err.message : String(err));
      } finally {
        submitBtn.disabled = false;
      }
    });

    // =========================
    // 리사이즈 대응(선택): 화면 폭 바뀌면 미리보기 재렌더 & 위치 유지
    // =========================
    let resizeTimer = null;
    window.addEventListener("resize", () => {
      if (!state.pdf.page1) return;
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(async () => {
        try {
          await renderFirstPage(); // normX/normY 기반으로 위치 복원
        } catch (_) {}
      }, 200);
    });
  </script>
</body>
</html>
