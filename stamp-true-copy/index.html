<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="/static/style.css" />
  <title>원본대조필 도장 찍기 (실측 6.1×2.5cm)</title>

  <!-- pdf-lib (PDF 편집/저장) -->
  <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>

  <!-- PDF.js (미리보기 렌더링) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

  <style>
    /* 추가 CSS 파일은 금지이므로, 필수 UI(드롭존/오버레이)만 최소 인라인 스타일 */
    .dropzone {
      border: 2px dashed #d4d4d8;
      border-radius: 14px;
      padding: 16px;
      background: #fafafa;
      cursor: pointer;
      min-height: 120px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 6px;
    }
    .dropzone.dragover {
      border-color: #111;
      background: #f3f4f6;
    }
    .dropzone .dz-title { font-weight: 800; color: #111; }
    .dropzone .dz-sub { font-size: 0.95rem; color: #555; }
    .dropzone .dz-file { font-size: 0.95rem; color: #111; }
    .dropzone input[type="file"] { display: none; }

    .stage-wrap { margin-top: 14px; }
    .stage {
      position: relative;
      display: inline-block;
      max-width: 100%;
      touch-action: none;
      user-select: none;
    }
    #pdfCanvas {
      display: block;
      max-width: 100%;
      height: auto;
      border: 1px solid #e5e5e5;
      border-radius: 12px;
      background: #fff;
    }

    #stampOverlay {
      position: absolute;
      box-sizing: border-box;
      border: 2px solid rgba(17, 24, 39, 0.65);
      border-radius: 10px;
      cursor: grab;
      touch-action: none;
      user-select: none;
      transform-origin: center center;
      background: rgba(255,255,255,0.10);
      backdrop-filter: blur(0.2px);
    }
    #stampOverlay.dragging { cursor: grabbing; }

    #stampOverlay img {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: fill;
      pointer-events: none;
      border-radius: 8px;
    }

    #innerGuide {
      position: absolute;
      pointer-events: none;
      border: 2px dashed rgba(17, 24, 39, 0.35);
      border-radius: 8px;
      box-sizing: border-box;
    }

    #overlayBadge {
      position: absolute;
      left: 8px;
      top: 8px;
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 12px;
      background: rgba(255,255,255,0.90);
      border: 1px solid rgba(0,0,0,0.08);
      pointer-events: none;
      color: #111;
      font-weight: 800;
      white-space: nowrap;
    }

    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .warn { color: #b42318; font-weight: 700; }
    .ok { color: #166534; font-weight: 700; }

    .chip-wrap { display:flex; flex-wrap:wrap; gap:8px; margin-top: 8px; }
    .chip {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border: 1px solid #d4d4d8;
      border-radius: 999px;
      background: #f3f4f6;
    }
    .chip .chip-link {
      cursor: pointer;
      font-weight: 800;
      color: #111;
      background: transparent;
      border: 0;
      padding: 0;
    }
    .chip .chip-x {
      cursor: pointer;
      font-weight: 900;
      color: #111;
      background: transparent;
      border: 0;
      padding: 0 2px;
      line-height: 1;
      font-size: 16px;
    }

    .small-input {
      max-width: 220px;
      width: 100%;
    }
  </style>
</head>

<body>
  <header class="site-header">
    <div class="shell">
      <div class="row between">
        <div style="font-weight:700;">업무보조</div>
        <a class="btn btn-home" href="/">홈</a>
      </div>
    </div>
  </header>

  <main>
    <div class="container">
      <h1>원본대조필 도장 찍기</h1>
      <p class="subtitle">
        도장 실측: <b>가로 6.1cm × 세로 2.5cm</b> (PDF 포인트로 고정 삽입).<br/>
        인쇄 시 “페이지에 맞춤”을 끄고 <b>실제 크기(100%)</b>로 출력해야 실측이 맞습니다.
      </p>

      <section class="section">
        <div class="grid two">
          <div class="card">
            <div class="dropzone" id="pdfDrop">
              <div class="dz-title">PDF 드래그&드롭</div>
              <div class="dz-sub">여기에 PDF를 놓거나 클릭해서 선택</div>
              <div class="dz-file" id="pdfFileName">선택된 파일 없음</div>
              <input id="pdfInput" type="file" accept="application/pdf" />
            </div>
          </div>

          <div class="card">
            <div class="dropzone" id="stampDrop">
              <div class="dz-title">도장 업로드(선택)</div>
              <div class="dz-sub">
                기본 도장: <code>/stamp-true-copy/stamp_copy.png</code><br/>
                업로드하면 기본 도장 대신 사용됩니다.
              </div>
              <div class="dz-file" id="stampFileName">기본 도장 로딩 중…</div>
              <input id="stampInput" type="file" accept="image/png,image/webp,image/jpeg" />
            </div>
          </div>
        </div>
      </section>

      <section class="section">
        <div class="card">
          <div class="grid three">
            <div>
              <div class="local-small muted" style="margin-bottom:6px;">회전 각도(도) — <b>+는 시계방향</b></div>
              <input id="angleDeg" type="number" min="-180" max="180" step="1" value="0" />
              <div class="muted local-small" style="margin-top:6px;">미리보기/출력 동일</div>
            </div>

            <div>
              <div class="local-small muted" style="margin-bottom:6px;">불투명도</div>
              <input id="opacity" type="number" min="0.1" max="1" step="0.05" value="0.45" />
              <div class="muted local-small" style="margin-top:6px;">0.35~0.6 추천</div>
            </div>

            <div>
              <div class="local-small muted" style="margin-bottom:6px;">기본 위치(전체 적용) 빠른 이동</div>
              <div class="row gap">
                <button id="resetBR" class="btn ghost" type="button">우하단</button>
                <button id="resetCenter" class="btn ghost" type="button">가운데</button>
              </div>
              <div class="muted local-small" style="margin-top:6px;">기본 위치는 오버라이드 없는 페이지에 적용</div>
            </div>
          </div>

          <hr/>

          <div class="grid three">
            <div>
              <div class="local-small muted" style="margin-bottom:6px;">페이지 이동</div>
              <div class="row gap">
                <button id="prevPage" class="btn ghost" type="button">이전</button>
                <button id="nextPage" class="btn ghost" type="button">다음</button>
              </div>
              <div class="row gap" style="margin-top:10px;">
                <input id="pageInput" class="small-input" type="number" min="1" step="1" placeholder="페이지 번호" />
                <button id="goPage" class="btn ghost" type="button">이동</button>
              </div>
              <div class="muted local-small" style="margin-top:6px;">
                현재: <span id="pageLabel">- / -</span>
              </div>
            </div>

            <div>
              <div class="local-small muted" style="margin-bottom:6px;">현재 페이지만 위치 변경(오버라이드)</div>
              <label class="row" style="align-items:flex-start;">
                <input id="overrideToggle" type="checkbox" />
                <span class="local-small">
                  체크하면 <b>이 페이지만</b> 위치가 따로 저장됩니다.<br/>
                  해제하면 오버라이드 삭제(기본 위치로 복귀).
                </span>
              </label>
              <div class="row gap" style="margin-top:10px;">
                <button id="deleteOverrideThis" class="btn ghost" type="button">이 페이지 오버라이드 삭제</button>
              </div>
            </div>

            <div>
              <div class="local-small muted" style="margin-bottom:6px;">페이지 범위에 오버라이드 적용</div>
              <input id="rangeInput" type="text" placeholder="예: 1,3,5-7" />
              <div class="row gap" style="margin-top:10px;">
                <button id="applyRange" class="btn ghost" type="button">현재 위치를 범위에 적용</button>
                <button id="clearOverrides" class="btn ghost" type="button">오버라이드 전체 삭제</button>
              </div>
              <div class="muted local-small" style="margin-top:6px;">
                범위 페이지는 기본 위치 대신 개별 위치 사용
              </div>
            </div>
          </div>

          <div class="card" style="margin-top:14px;">
            <div style="font-weight:800;">오버라이드된 페이지 목록</div>
            <div id="overrideList" class="chip-wrap"></div>
            <div id="overrideEmpty" class="muted local-small" style="margin-top:8px;">없음</div>
          </div>
        </div>
      </section>

      <section class="section">
        <div class="card">
          <div class="muted local-small" style="margin-bottom:8px;">
            미리보기에서 도장 박스를 <b>드래그</b>하거나 캔버스를 <b>클릭</b>하면 위치가 변경됩니다.
          </div>

          <div class="stage-wrap" id="stageWrap" style="display:none;">
            <div class="stage" id="stage">
              <canvas id="pdfCanvas"></canvas>

              <div id="stampOverlay" aria-label="stamp overlay">
                <img id="stampOverlayImg" alt="" style="display:none;" />
                <div id="innerGuide"></div>
                <div id="overlayBadge">6.1×2.5cm</div>
              </div>
            </div>

            <div class="mono muted local-small" id="coordReadout" style="margin-top:10px;"></div>
            <div class="local-small" id="warnMsg" style="margin-top:6px;"></div>
          </div>

          <div class="row between" style="margin-top:16px;">
            <button id="downloadBtn" class="btn primary" type="button">도장 찍고 다운로드</button>
            <div id="status" class="muted local-small"></div>
          </div>
        </div>
      </section>
    </div>
  </main>

  <footer class="site-footer">
    <div class="shell">
      <p>© 업무보조</p>
    </div>
  </footer>

  <script>
    "use strict";

    // =========================
    // PDF.js worker 설정
    // =========================
    if (!window.pdfjsLib) {
      console.error("PDF.js 로드 실패");
    } else {
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
    }

    // =========================
    // 실측 고정: cm -> pt
    // =========================
    const CM_TO_PT = 72 / 2.54;
    const STAMP_W_PT = 6.1 * CM_TO_PT;  // 172.913...
    const STAMP_H_PT = 2.5 * CM_TO_PT;  // 70.866...
    const BORDER_PT  = 0.5 * CM_TO_PT;  // 14.173...
    const DEFAULT_MARGIN_PT = 36;

    const MAX_PDF_BYTES = 30 * 1024 * 1024;

    // 기본 도장 경로
    const DEFAULT_STAMP_URL = "./stamp_copy.png";

    // =========================
    // DOM helpers
    // =========================
    const $ = (sel) => document.querySelector(sel);

    const pdfDrop = $("#pdfDrop");
    const stampDrop = $("#stampDrop");
    const pdfInput = $("#pdfInput");
    const stampInput = $("#stampInput");
    const pdfFileName = $("#pdfFileName");
    const stampFileName = $("#stampFileName");

    const angleDegInput = $("#angleDeg");
    const opacityInput = $("#opacity");

    const prevPageBtn = $("#prevPage");
    const nextPageBtn = $("#nextPage");
    const goPageBtn = $("#goPage");
    const pageInput = $("#pageInput");
    const pageLabel = $("#pageLabel");

    const overrideToggle = $("#overrideToggle");
    const deleteOverrideThisBtn = $("#deleteOverrideThis");
    const rangeInput = $("#rangeInput");
    const applyRangeBtn = $("#applyRange");
    const clearOverridesBtn = $("#clearOverrides");

    const overrideList = $("#overrideList");
    const overrideEmpty = $("#overrideEmpty");

    const stageWrap = $("#stageWrap");
    const stage = $("#stage");
    const canvas = $("#pdfCanvas");
    const overlay = $("#stampOverlay");
    const overlayImg = $("#stampOverlayImg");
    const innerGuide = $("#innerGuide");
    const coordReadout = $("#coordReadout");
    const warnMsg = $("#warnMsg");

    const resetBRBtn = $("#resetBR");
    const resetCenterBtn = $("#resetCenter");

    const downloadBtn = $("#downloadBtn");
    const statusEl = $("#status");

    function setStatus(msg) { statusEl.textContent = msg || ""; }

    function setWarn(message, isWarn) {
      if (!message) {
        warnMsg.textContent = "";
        warnMsg.className = "local-small";
        return;
      }
      warnMsg.textContent = message;
      warnMsg.className = "local-small " + (isWarn ? "warn" : "ok");
    }

    function clamp(n, min, max) {
      return Math.max(min, Math.min(max, n));
    }

    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function readFileAsArrayBuffer(file) {
      return new Promise((resolve, reject) => {
        const r = new FileReader();
        r.onload = () => resolve(r.result);
        r.onerror = () => reject(r.error);
        r.readAsArrayBuffer(file);
      });
    }

    // =========================
    // 상태
    // =========================
    const state = {
      files: {
        pdf: null,
        stampName: null, // string
      },
      pdf: {
        bytesForSave: null,  // ArrayBuffer (pdf-lib용: detached 방지 복사본)
        doc: null,           // PDF.js doc
        numPages: 0,
        currentPage: 1,
        page: null,          // PDFPageProxy
        viewport: null,      // viewport
        pageBox: { x0: 0, y0: 0, wPt: 0, hPt: 0 },
        renderTask: null
      },
      stamp: {
        pngBytes: null,      // Uint8Array (trim + 투명화)
        previewUrl: null     // ObjectURL
      },
      placement: {
        default: null,
        overrides: {}        // { [pageNum]: {normX,normY} }
      },
      overlay: {
        wPx: 0,
        hPx: 0,
        cxPx: 0,
        cyPx: 0
      },
      drag: {
        active: false,
        pointerId: null,
        dx: 0,
        dy: 0,
        moved: false
      }
    };

    // =========================
    // 드롭존 설정
    // =========================
    function setupDropZone(zoneEl, inputEl, onFile) {
      zoneEl.addEventListener("click", () => inputEl.click());

      inputEl.addEventListener("change", async () => {
        const f = inputEl.files && inputEl.files[0];
        if (f) await onFile(f);
      });

      const add = () => zoneEl.classList.add("dragover");
      const remove = () => zoneEl.classList.remove("dragover");

      zoneEl.addEventListener("dragenter", (e) => { e.preventDefault(); add(); });
      zoneEl.addEventListener("dragover", (e) => { e.preventDefault(); add(); });
      zoneEl.addEventListener("dragleave", () => remove());
      zoneEl.addEventListener("drop", async (e) => {
        e.preventDefault();
        remove();
        const f = e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0];
        if (f) await onFile(f);
      });
    }

    // =========================
    // 도장: 트림 + 배경 투명화
    // =========================
    function loadImageFromArrayBuffer(ab) {
      return new Promise((resolve, reject) => {
        const blob = new Blob([ab]);
        const url = URL.createObjectURL(blob);
        const img = new Image();
        img.decoding = "async";
        img.onload = () => { URL.revokeObjectURL(url); resolve(img); };
        img.onerror = () => { URL.revokeObjectURL(url); reject(new Error("도장 이미지 로드 실패")); };
        img.src = url;
      });
    }

    async function canvasToPngBytes(c) {
      const blob = await new Promise((resolve) => c.toBlob(resolve, "image/png"));
      const ab = await blob.arrayBuffer();
      return new Uint8Array(ab);
    }

    function computeBBox(imgData, bgThreshold = 245) {
      const { data, width, height } = imgData;
      let minX = width, minY = height, maxX = -1, maxY = -1;
      let found = 0;

      for (let y = 0; y < height; y++) {
        const row = y * width;
        for (let x = 0; x < width; x++) {
          const i = (row + x) * 4;
          const r = data[i], g = data[i + 1], b = data[i + 2], a = data[i + 3];

          const isTransparentBg = a < 16;
          const isWhiteBg = (r >= bgThreshold && g >= bgThreshold && b >= bgThreshold);
          const isBg = isTransparentBg || isWhiteBg;

          if (!isBg) {
            found++;
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
          }
        }
      }
      if (!found || maxX < 0) return null;

      const pad = 1;
      minX = Math.max(0, minX - pad);
      minY = Math.max(0, minY - pad);
      maxX = Math.min(width - 1, maxX + pad);
      maxY = Math.min(height - 1, maxY + pad);

      return { minX, minY, maxX, maxY };
    }

    async function trimAndTransparentizeStampFromArrayBuffer(ab) {
      const img = await loadImageFromArrayBuffer(ab);

      const srcW = img.naturalWidth || img.width;
      const srcH = img.naturalHeight || img.height;

      const srcCanvas = document.createElement("canvas");
      srcCanvas.width = srcW;
      srcCanvas.height = srcH;

      const sctx = srcCanvas.getContext("2d", { willReadFrequently: true });
      sctx.drawImage(img, 0, 0);

      const imgData = sctx.getImageData(0, 0, srcW, srcH);
      const bbox = computeBBox(imgData, 245);
      if (!bbox) throw new Error("도장 이미지에서 도장을 찾지 못했습니다(배경/투명 확인).");

      const w = bbox.maxX - bbox.minX + 1;
      const h = bbox.maxY - bbox.minY + 1;

      const outCanvas = document.createElement("canvas");
      outCanvas.width = w;
      outCanvas.height = h;

      const octx = outCanvas.getContext("2d", { willReadFrequently: true });
      octx.drawImage(srcCanvas, bbox.minX, bbox.minY, w, h, 0, 0, w, h);

      // 흰 배경 투명화(비투명 이미지 대비)
      const outData = octx.getImageData(0, 0, w, h);
      const p = outData.data;
      const t = 245;
      for (let i = 0; i < p.length; i += 4) {
        const r = p[i], g = p[i + 1], b = p[i + 2], a = p[i + 3];
        if (a < 16) { p[i + 3] = 0; continue; }
        if (r >= t && g >= t && b >= t) p[i + 3] = 0;
      }
      octx.putImageData(outData, 0, 0);

      const pngBytes = await canvasToPngBytes(outCanvas);
      const blob = new Blob([pngBytes], { type: "image/png" });
      const url = URL.createObjectURL(blob);

      return { pngBytes, previewUrl: url };
    }

    function setStampPreview(url) {
      if (state.stamp.previewUrl) {
        try { URL.revokeObjectURL(state.stamp.previewUrl); } catch (_) {}
      }
      state.stamp.previewUrl = url;
      overlayImg.src = url;
      overlayImg.style.display = "block";
      updateOverlayOpacity();
    }

    async function loadDefaultStampIfExists() {
      try {
        const res = await fetch(DEFAULT_STAMP_URL, { cache: "no-store" });
        if (!res.ok) throw new Error("기본 도장 없음");
        const ab = await res.arrayBuffer();

        const { pngBytes, previewUrl } = await trimAndTransparentizeStampFromArrayBuffer(ab);
        state.stamp.pngBytes = pngBytes;
        state.files.stampName = "stamp_copy.png (기본)";
        stampFileName.textContent = state.files.stampName;
        setStampPreview(previewUrl);

        setStatus("기본 도장(stamp_copy.png)을 불러왔습니다. 필요하면 업로드로 교체하세요.");
      } catch (_) {
        state.files.stampName = null;
        stampFileName.textContent = "기본 도장 없음 → 업로드 필요";
      }
    }

    // =========================
    // 페이지 범위 파서 "1,3,5-7"
    // =========================
    function parsePageRange(str, maxPage) {
      const s = (str || "").trim();
      if (!s) throw new Error("페이지 범위를 입력하세요. 예: 1,3,5-7");

      const out = new Set();
      const parts = s.split(",").map(x => x.trim()).filter(Boolean);

      for (const part of parts) {
        if (part.includes("-")) {
          const [aRaw, bRaw] = part.split("-").map(x => x.trim());
          const a = parseInt(aRaw, 10);
          const b = parseInt(bRaw, 10);
          if (!Number.isFinite(a) || !Number.isFinite(b)) throw new Error(`잘못된 범위: ${part}`);
          const start = Math.min(a, b);
          const end = Math.max(a, b);
          for (let i = start; i <= end; i++) {
            if (i >= 1 && i <= maxPage) out.add(i);
          }
        } else {
          const n = parseInt(part, 10);
          if (!Number.isFinite(n)) throw new Error(`잘못된 페이지: ${part}`);
          if (n >= 1 && n <= maxPage) out.add(n);
        }
      }

      const arr = Array.from(out);
      arr.sort((a, b) => a - b);
      if (!arr.length) throw new Error("범위가 비어있거나 페이지 범위를 벗어났습니다.");
      return arr;
    }

    // =========================
    // PDF 미리보기 렌더링
    // =========================
    function getFitScale(viewportAt1, targetCssWidth) {
      const scale = targetCssWidth / viewportAt1.width;
      return clamp(scale, 0.25, 3.0);
    }

    function computePageBoxPt(viewportAt1) {
      const vb = viewportAt1.viewBox; // [xMin, yMin, xMax, yMax]
      const x0 = vb[0], y0 = vb[1], x1 = vb[2], y1 = vb[3];
      return { x0, y0, wPt: (x1 - x0), hPt: (y1 - y0) };
    }

    function pxPerPtFromViewport(viewport, pageBox) {
      const [xA, yA] = viewport.convertToViewportPoint(pageBox.x0, pageBox.y0);
      const [xB, yB] = viewport.convertToViewportPoint(pageBox.x0 + 1, pageBox.y0);
      const [xC, yC] = viewport.convertToViewportPoint(pageBox.x0, pageBox.y0 + 1);
      const sx = Math.hypot(xB - xA, yB - yA);
      const sy = Math.hypot(xC - xA, yC - yA);
      return { sx, sy };
    }

    async function renderPage(pageNum) {
      if (!state.pdf.doc) return;

      try {
        if (state.pdf.renderTask && state.pdf.renderTask.cancel) state.pdf.renderTask.cancel();
      } catch (_) {}

      setStatus(`페이지 렌더링 중… (${pageNum}/${state.pdf.numPages})`);

      const page = await state.pdf.doc.getPage(pageNum);

      const viewportAt1 = page.getViewport({ scale: 1 });
      const pageBox = computePageBoxPt(viewportAt1);

      const containerW = Math.max(320, Math.min(stageWrap.clientWidth || 860, 860));
      const scale = getFitScale(viewportAt1, containerW);

      const viewport = page.getViewport({ scale });

      state.pdf.page = page;
      state.pdf.viewport = viewport;
      state.pdf.pageBox = pageBox;
      state.pdf.currentPage = pageNum;

      const dpr = window.devicePixelRatio || 1;
      const ctx = canvas.getContext("2d", { alpha: false });

      canvas.width = Math.floor(viewport.width * dpr);
      canvas.height = Math.floor(viewport.height * dpr);
      canvas.style.width = `${Math.floor(viewport.width)}px`;
      canvas.style.height = `${Math.floor(viewport.height)}px`;

      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.clearRect(0, 0, viewport.width, viewport.height);

      stageWrap.style.display = "block";

      const task = page.render({ canvasContext: ctx, viewport });
      state.pdf.renderTask = task;
      await task.promise;

      // 오버레이 크기(px): pt -> viewport px
      const { sx, sy } = pxPerPtFromViewport(viewport, pageBox);
      state.overlay.wPx = STAMP_W_PT * sx;
      state.overlay.hPx = STAMP_H_PT * sy;

      overlay.style.width = `${state.overlay.wPx}px`;
      overlay.style.height = `${state.overlay.hPx}px`;

      // 테두리 가이드 0.5cm
      const borderPx = BORDER_PT * sx;
      innerGuide.style.left = `${borderPx}px`;
      innerGuide.style.top = `${borderPx}px`;
      innerGuide.style.width = `${Math.max(0, state.overlay.wPx - 2 * borderPx)}px`;
      innerGuide.style.height = `${Math.max(0, state.overlay.hPx - 2 * borderPx)}px`;

      // 기본 위치가 없으면 우하단 margin 생성
      if (!state.placement.default) {
        const cxPt = pageBox.x0 + pageBox.wPt - DEFAULT_MARGIN_PT - (STAMP_W_PT / 2);
        const cyPt = pageBox.y0 + DEFAULT_MARGIN_PT + (STAMP_H_PT / 2);
        state.placement.default = {
          normX: (cxPt - pageBox.x0) / pageBox.wPt,
          normY: (cyPt - pageBox.y0) / pageBox.hPt
        };
      }

      const hasOverride = !!state.placement.overrides[pageNum];
      overrideToggle.checked = hasOverride;

      const placement = hasOverride ? state.placement.overrides[pageNum] : state.placement.default;
      applyPlacementToOverlay(placement);

      updatePageUI();
      updateOverlayTransform();
      updateOverlayOpacity();
      renderOverrideListUI();
      updateOutOfBoundsWarning();
      updateCoordReadout();

      setStatus("미리보기에서 위치를 조정하세요.");
    }

    function applyPlacementToOverlay(placement) {
      const vp = state.pdf.viewport;
      const pb = state.pdf.pageBox;
      if (!vp || !pb || !placement) return;

      const cxPt = pb.x0 + placement.normX * pb.wPt;
      const cyPt = pb.y0 + placement.normY * pb.hPt;
      const [cxPx, cyPx] = vp.convertToViewportPoint(cxPt, cyPt);

      state.overlay.cxPx = cxPx;
      state.overlay.cyPx = cyPx;

      overlay.style.left = `${cxPx - state.overlay.wPx / 2}px`;
      overlay.style.top = `${cyPx - state.overlay.hPx / 2}px`;
    }

    function overlayCenterToNorm() {
      const vp = state.pdf.viewport;
      const pb = state.pdf.pageBox;
      if (!vp || !pb) return null;

      const [cxPt, cyPt] = vp.convertToPdfPoint(state.overlay.cxPx, state.overlay.cyPx);
      const normX = (cxPt - pb.x0) / pb.wPt;
      const normY = (cyPt - pb.y0) / pb.hPt;
      return { normX, normY, cxPt, cyPt };
    }

    function persistPlacementFromOverlay() {
      const info = overlayCenterToNorm();
      if (!info) return;

      const pageNum = state.pdf.currentPage;
      if (overrideToggle.checked) {
        state.placement.overrides[pageNum] = { normX: info.normX, normY: info.normY };
      } else {
        state.placement.default = { normX: info.normX, normY: info.normY };
      }

      renderOverrideListUI();
      updateCoordReadout();
      updateOutOfBoundsWarning();
    }

    // =========================
    // 미리보기: 회전/불투명도
    // =========================
    function getAngleDeg() {
      return clamp(parseFloat(angleDegInput.value || "0"), -180, 180);
    }
    function getOpacity() {
      return clamp(parseFloat(opacityInput.value || "0.45"), 0.1, 1.0);
    }
    function updateOverlayTransform() {
      const angle = getAngleDeg();
      overlay.style.transform = `rotate(${angle}deg)`; // screen: + 시계방향처럼 보임
      updateOutOfBoundsWarning();
    }
    function updateOverlayOpacity() {
      const op = getOpacity();
      overlayImg.style.opacity = String(op);
    }
    angleDegInput.addEventListener("input", updateOverlayTransform);
    opacityInput.addEventListener("input", updateOverlayOpacity);

    // =========================
    // 페이지 UI
    // =========================
    function updatePageUI() {
      const n = state.pdf.currentPage;
      const total = state.pdf.numPages || 0;
      pageLabel.textContent = `${n} / ${total}`;
      pageInput.value = n;

      prevPageBtn.disabled = (n <= 1);
      nextPageBtn.disabled = (n >= total);
    }

    async function gotoPage(n) {
      const total = state.pdf.numPages;
      if (!total) return;
      const pageNum = clamp(Math.floor(n), 1, total);
      await renderPage(pageNum);
    }
    prevPageBtn.addEventListener("click", async () => { if (state.pdf.doc) await gotoPage(state.pdf.currentPage - 1); });
    nextPageBtn.addEventListener("click", async () => { if (state.pdf.doc) await gotoPage(state.pdf.currentPage + 1); });
    goPageBtn.addEventListener("click", async () => {
      if (!state.pdf.doc) return;
      const n = parseInt(pageInput.value, 10);
      if (Number.isFinite(n)) await gotoPage(n);
    });

    // =========================
    // 오버라이드 목록 UI
    // =========================
    function renderOverrideListUI() {
      const keys = Object.keys(state.placement.overrides)
        .map(x => parseInt(x, 10))
        .filter(Number.isFinite)
        .sort((a, b) => a - b);

      overrideList.innerHTML = "";

      if (!keys.length) {
        overrideEmpty.style.display = "block";
        return;
      }
      overrideEmpty.style.display = "none";

      for (const p of keys) {
        const chip = document.createElement("div");
        chip.className = "chip";

        const link = document.createElement("button");
        link.type = "button";
        link.className = "chip-link";
        link.textContent = `p${p}`;
        link.addEventListener("click", async () => await gotoPage(p));

        const xBtn = document.createElement("button");
        xBtn.type = "button";
        xBtn.className = "chip-x";
        xBtn.textContent = "×";
        xBtn.title = "삭제";
        xBtn.addEventListener("click", async (e) => {
          e.stopPropagation();
          delete state.placement.overrides[p];
          if (state.pdf.currentPage === p) {
            overrideToggle.checked = false;
            applyPlacementToOverlay(state.placement.default);
            updateOutOfBoundsWarning();
            updateCoordReadout();
          }
          renderOverrideListUI();
        });

        chip.appendChild(link);
        chip.appendChild(xBtn);
        overrideList.appendChild(chip);
      }
    }

    // =========================
    // 경고: 페이지 밖(회전 포함, screen px)
    // =========================
    function rotatedCorners(cx, cy, w, h, angleDeg) {
      const t = angleDeg * Math.PI / 180; // screen y-down에서 +는 시계방향처럼 보임
      const cos = Math.cos(t);
      const sin = Math.sin(t);
      const hw = w / 2, hh = h / 2;

      const pts = [
        [-hw, -hh],
        [ hw, -hh],
        [ hw,  hh],
        [-hw,  hh]
      ];

      const out = [];
      for (const [x, y] of pts) {
        const xr = x * cos - y * sin;
        const yr = x * sin + y * cos;
        out.push([cx + xr, cy + yr]);
      }
      return out;
    }

    function updateOutOfBoundsWarning() {
      const vp = state.pdf.viewport;
      if (!vp) return;

      const stageW = vp.width;
      const stageH = vp.height;

      const cx = state.overlay.cxPx;
      const cy = state.overlay.cyPx;
      const w = state.overlay.wPx;
      const h = state.overlay.hPx;
      const angle = getAngleDeg();

      const corners = rotatedCorners(cx, cy, w, h, angle);

      let out = false;
      for (const [x, y] of corners) {
        if (x < 0 || x > stageW || y < 0 || y > stageH) { out = true; break; }
      }

      if (out) {
        overlay.style.borderColor = "rgba(180, 35, 24, 0.95)";
        setWarn("경고: 도장이 페이지 밖으로 나갑니다(회전 포함). 위치를 안쪽으로 옮기세요.", true);
      } else {
        overlay.style.borderColor = "rgba(17, 24, 39, 0.65)";
        setWarn("정상: 도장이 페이지 안에 있습니다.", false);
      }
    }

    // =========================
    // 좌표 표시
    // =========================
    function updateCoordReadout() {
      const info = overlayCenterToNorm();
      if (!info) { coordReadout.textContent = ""; return; }

      const pb = state.pdf.pageBox;
      const ptToCm = 2.54 / 72;

      const pageNum = state.pdf.currentPage;
      const isOverride = !!state.placement.overrides[pageNum];
      const mode = isOverride ? "이 페이지: 개별(오버라이드)" : "기본 위치(전체 적용)";

      const cxCm = info.cxPt * ptToCm;
      const cyCm = info.cyPt * ptToCm;

      coordReadout.textContent =
        `[${mode}]  normX=${info.normX.toFixed(4)}, normY=${info.normY.toFixed(4)} | ` +
        `중심: X=${info.cxPt.toFixed(1)}pt(${cxCm.toFixed(2)}cm), Y=${info.cyPt.toFixed(1)}pt(${cyCm.toFixed(2)}cm) | ` +
        `페이지크기: ${pb.wPt.toFixed(1)}×${pb.hPt.toFixed(1)}pt`;
    }

    // =========================
    // 오버레이 드래그/클릭 이동
    // =========================
    function getStagePoint(e) {
      const r = stage.getBoundingClientRect();
      return { x: e.clientX - r.left, y: e.clientY - r.top };
    }

    overlay.addEventListener("pointerdown", (e) => {
      if (!state.pdf.viewport) return;
      e.preventDefault();

      const p = getStagePoint(e);
      const left = parseFloat(overlay.style.left || "0");
      const top  = parseFloat(overlay.style.top || "0");

      state.drag.active = true;
      state.drag.pointerId = e.pointerId;
      state.drag.dx = p.x - left;
      state.drag.dy = p.y - top;
      state.drag.moved = false;

      overlay.classList.add("dragging");
      overlay.setPointerCapture(e.pointerId);
    });

    overlay.addEventListener("pointermove", (e) => {
      if (!state.drag.active || e.pointerId !== state.drag.pointerId) return;
      e.preventDefault();

      const vp = state.pdf.viewport;
      if (!vp) return;

      const stageW = vp.width;
      const stageH = vp.height;

      const p = getStagePoint(e);

      let left = p.x - state.drag.dx;
      let top  = p.y - state.drag.dy;

      // 너무 멀리 벗어나면 안 보이므로 절반만 나가게 제한
      left = clamp(left, -state.overlay.wPx / 2, stageW - state.overlay.wPx / 2);
      top  = clamp(top,  -state.overlay.hPx / 2, stageH - state.overlay.hPx / 2);

      overlay.style.left = `${left}px`;
      overlay.style.top  = `${top}px`;

      state.overlay.cxPx = left + state.overlay.wPx / 2;
      state.overlay.cyPx = top + state.overlay.hPx / 2;

      state.drag.moved = true;
      persistPlacementFromOverlay();
    });

    overlay.addEventListener("pointerup", (e) => {
      if (e.pointerId !== state.drag.pointerId) return;
      state.drag.active = false;
      state.drag.pointerId = null;
      overlay.classList.remove("dragging");
      try { overlay.releasePointerCapture(e.pointerId); } catch (_) {}
    });

    overlay.addEventListener("pointercancel", (e) => {
      if (e.pointerId !== state.drag.pointerId) return;
      state.drag.active = false;
      state.drag.pointerId = null;
      overlay.classList.remove("dragging");
      try { overlay.releasePointerCapture(e.pointerId); } catch (_) {}
    });

    stage.addEventListener("click", (e) => {
      if (!state.pdf.viewport) return;
      if (state.drag.moved) { state.drag.moved = false; return; }

      const vp = state.pdf.viewport;
      const stageW = vp.width;
      const stageH = vp.height;

      const p = getStagePoint(e);

      const cx = clamp(p.x, 0, stageW);
      const cy = clamp(p.y, 0, stageH);

      state.overlay.cxPx = cx;
      state.overlay.cyPx = cy;

      overlay.style.left = `${cx - state.overlay.wPx / 2}px`;
      overlay.style.top  = `${cy - state.overlay.hPx / 2}px`;

      persistPlacementFromOverlay();
    });

    // =========================
    // 기본 위치 버튼
    // =========================
    function setDefaultPlacementBottomRight() {
      const pb = state.pdf.pageBox;
      if (!pb.wPt || !pb.hPt) return;

      const cxPt = pb.x0 + pb.wPt - DEFAULT_MARGIN_PT - (STAMP_W_PT / 2);
      const cyPt = pb.y0 + DEFAULT_MARGIN_PT + (STAMP_H_PT / 2);
      state.placement.default = {
        normX: (cxPt - pb.x0) / pb.wPt,
        normY: (cyPt - pb.y0) / pb.hPt
      };

      // 기본 편집 모드로
      overrideToggle.checked = false;
      delete state.placement.overrides[state.pdf.currentPage];

      applyPlacementToOverlay(state.placement.default);
      persistPlacementFromOverlay();
    }

    function setDefaultPlacementCenter() {
      const pb = state.pdf.pageBox;
      if (!pb.wPt || !pb.hPt) return;

      const cxPt = pb.x0 + pb.wPt / 2;
      const cyPt = pb.y0 + pb.hPt / 2;
      state.placement.default = {
        normX: (cxPt - pb.x0) / pb.wPt,
        normY: (cyPt - pb.y0) / pb.hPt
      };

      overrideToggle.checked = false;
      delete state.placement.overrides[state.pdf.currentPage];

      applyPlacementToOverlay(state.placement.default);
      persistPlacementFromOverlay();
    }

    resetBRBtn.addEventListener("click", () => { if (state.pdf.doc) setDefaultPlacementBottomRight(); });
    resetCenterBtn.addEventListener("click", () => { if (state.pdf.doc) setDefaultPlacementCenter(); });

    // =========================
    // 오버라이드 토글/삭제/범위 적용
    // =========================
    overrideToggle.addEventListener("change", () => {
      if (!state.pdf.doc) return;
      const pageNum = state.pdf.currentPage;

      if (overrideToggle.checked) {
        const info = overlayCenterToNorm();
        if (info) state.placement.overrides[pageNum] = { normX: info.normX, normY: info.normY };
      } else {
        delete state.placement.overrides[pageNum];
        applyPlacementToOverlay(state.placement.default);
      }

      renderOverrideListUI();
      updateCoordReadout();
      updateOutOfBoundsWarning();
    });

    deleteOverrideThisBtn.addEventListener("click", () => {
      if (!state.pdf.doc) return;
      const pageNum = state.pdf.currentPage;
      delete state.placement.overrides[pageNum];
      overrideToggle.checked = false;
      applyPlacementToOverlay(state.placement.default);
      persistPlacementFromOverlay();
    });

    applyRangeBtn.addEventListener("click", () => {
      if (!state.pdf.doc) return;

      try {
        const pages = parsePageRange(rangeInput.value, state.pdf.numPages);
        const info = overlayCenterToNorm();
        if (!info) throw new Error("현재 위치를 읽지 못했습니다.");

        for (const p of pages) {
          state.placement.overrides[p] = { normX: info.normX, normY: info.normY };
        }
        if (pages.includes(state.pdf.currentPage)) overrideToggle.checked = true;

        renderOverrideListUI();
        updateCoordReadout();
        updateOutOfBoundsWarning();
        setStatus(`범위 적용 완료: ${pages.length}개 페이지`);
      } catch (err) {
        setStatus(err && err.message ? err.message : String(err));
      }
    });

    clearOverridesBtn.addEventListener("click", () => {
      if (!state.pdf.doc) return;
      state.placement.overrides = {};
      overrideToggle.checked = false;
      applyPlacementToOverlay(state.placement.default);
      persistPlacementFromOverlay();
      renderOverrideListUI();
      setStatus("오버라이드 전체 삭제 완료");
    });

    // =========================
    // 파일 핸들러 (PDF / Stamp)
    // =========================
    async function handlePdfFile(file) {
      if (!file) return;

      const isPdf = (file.type === "application/pdf") || /\.pdf$/i.test(file.name);
      if (!isPdf) { setStatus("PDF 파일만 업로드할 수 있습니다."); return; }
      if (file.size > MAX_PDF_BYTES) { setStatus("PDF 파일이 너무 큽니다(30MB 이하 권장)."); return; }
      if (!window.pdfjsLib) { setStatus("PDF.js 로드 실패(CDN 차단 여부 확인)."); return; }

      setStatus("PDF 로딩 중…");
      downloadBtn.disabled = true;

      try {
        const abOriginal = await readFileAsArrayBuffer(file);

        // 헤더 체크
        const head = new TextDecoder("ascii").decode(new Uint8Array(abOriginal).slice(0, 1024));
        if (!head.includes("%PDF-")) throw new Error("PDF로 보이지 않습니다. 파일을 확인해주세요.");

        // detached 방지: pdf-lib 저장용은 복사본으로 보관
        state.pdf.bytesForSave = abOriginal.slice(0);

        // 새 PDF 상태 초기화
        state.files.pdf = file;
        pdfFileName.textContent = file.name;

        state.pdf.doc = null;
        state.pdf.page = null;
        state.pdf.viewport = null;
        state.pdf.pageBox = { x0: 0, y0: 0, wPt: 0, hPt: 0 };
        state.pdf.numPages = 0;
        state.pdf.currentPage = 1;

        state.placement.default = null;
        state.placement.overrides = {};
        renderOverrideListUI();
        overrideToggle.checked = false;

        // 미리보기(PDF.js)용: abOriginal을 그대로 넘김(이 버퍼는 detach되어도 상관없음)
        const loadingTask = pdfjsLib.getDocument({ data: new Uint8Array(abOriginal) });
        const pdfDoc = await loadingTask.promise;

        state.pdf.doc = pdfDoc;
        state.pdf.numPages = pdfDoc.numPages;

        await renderPage(1);
      } catch (err) {
        setStatus(err && err.message ? err.message : String(err));
      } finally {
        downloadBtn.disabled = false;
      }
    }

    async function handleStampFile(file) {
      if (!file) return;

      const isImg = /^image\//i.test(file.type) || /\.(png|jpg|jpeg|webp)$/i.test(file.name);
      if (!isImg) { setStatus("도장 이미지 파일을 업로드하세요(PNG 권장)."); return; }

      setStatus("도장 이미지 처리 중(트림/투명화)…");
      downloadBtn.disabled = true;

      try {
        const ab = await readFileAsArrayBuffer(file);
        const { pngBytes, previewUrl } = await trimAndTransparentizeStampFromArrayBuffer(ab);

        state.stamp.pngBytes = pngBytes;
        state.files.stampName = file.name;

        stampFileName.textContent = file.name;
        setStampPreview(previewUrl);

        setStatus("도장 이미지 준비 완료.");
      } catch (err) {
        setStatus(err && err.message ? err.message : String(err));
      } finally {
        downloadBtn.disabled = false;
      }
    }

    setupDropZone(pdfDrop, pdfInput, handlePdfFile);
    setupDropZone(stampDrop, stampInput, handleStampFile);

    // =========================
    // 저장 직전: 페이지 밖 검사(PT 기준) + 생성
    // =========================
    function isOutOfBoundsPt(pageW, pageH, placement, angleDegUser) {
      // 사용자 각도(+ 시계방향) → PDF(y-up)에서는 음수 회전이 시계방향
      const theta = (-angleDegUser) * Math.PI / 180;
      const cos = Math.cos(theta);
      const sin = Math.sin(theta);

      const CX = placement.normX * pageW;
      const CY = placement.normY * pageH;

      const hw = STAMP_W_PT / 2;
      const hh = STAMP_H_PT / 2;

      const corners = [
        [-hw, -hh],
        [ hw, -hh],
        [ hw,  hh],
        [-hw,  hh]
      ];

      for (const [x, y] of corners) {
        const xr = x * cos - y * sin;
        const yr = x * sin + y * cos;
        const X = CX + xr;
        const Y = CY + yr;
        if (X < 0 || X > pageW || Y < 0 || Y > pageH) return true;
      }
      return false;
    }

    async function stampAndDownload() {
      if (!state.pdf.bytesForSave || !state.files.pdf) throw new Error("PDF 파일을 업로드하세요.");
      if (!state.stamp.pngBytes) throw new Error("도장 이미지가 없습니다. (기본 도장 파일 stamp_copy.png 또는 업로드 필요)");
      if (!window.PDFLib) throw new Error("pdf-lib 로드 실패(CDN 차단 여부 확인).");

      const angleDegUser = getAngleDeg();
      const opacity = getOpacity();

      const { PDFDocument, degrees } = PDFLib;

      setStatus("PDF 처리 준비 중…");
      const pdfDoc = await PDFDocument.load(state.pdf.bytesForSave);

      const stampImg = await pdfDoc.embedPng(state.stamp.pngBytes);
      const pages = pdfDoc.getPages();

      // 생성 전: 페이지 밖 검증
      const outPages = [];
      for (let i = 0; i < pages.length; i++) {
        const pageNum = i + 1;
        const page = pages[i];
        const { width: pageW, height: pageH } = page.getSize();

        const placement = state.placement.overrides[pageNum] || state.placement.default;
        if (!placement) continue;

        if (isOutOfBoundsPt(pageW, pageH, placement, angleDegUser)) outPages.push(pageNum);
      }

      if (outPages.length) {
        const list = outPages.slice(0, 30).join(", ") + (outPages.length > 30 ? " …" : "");
        const ok = confirm(
          `도장이 페이지 밖으로 나가는 페이지가 있습니다:\n${list}\n\n그래도 PDF를 생성할까요?`
        );
        if (!ok) throw new Error("사용자가 취소했습니다.");
      }

      // 회전 중심 고정 보정(시계방향 -> pdf-lib는 -)
      const pdfRotateDeg = -angleDegUser;
      const theta = pdfRotateDeg * Math.PI / 180;
      const cos = Math.cos(theta);
      const sin = Math.sin(theta);

      const cxRot = (STAMP_W_PT / 2) * cos - (STAMP_H_PT / 2) * sin;
      const cyRot = (STAMP_W_PT / 2) * sin + (STAMP_H_PT / 2) * cos;

      for (let i = 0; i < pages.length; i++) {
        const pageNum = i + 1;
        const page = pages[i];
        const { width: pageW, height: pageH } = page.getSize();

        const placement = state.placement.overrides[pageNum] || state.placement.default;
        if (!placement) continue;

        const CX = placement.normX * pageW;
        const CY = placement.normY * pageH;

        const x = CX - cxRot;
        const y = CY - cyRot;

        page.drawImage(stampImg, {
          x, y,
          width: STAMP_W_PT,
          height: STAMP_H_PT,
          rotate: degrees(pdfRotateDeg),
          opacity
        });

        if (i === pages.length - 1 || i % 2 === 0) {
          setStatus(`페이지 처리 중… (${i + 1}/${pages.length})`);
          await new Promise(r => setTimeout(r, 0));
        }
      }

      const outBytes = await pdfDoc.save({ useObjectStreams: true });
      const outBlob = new Blob([outBytes], { type: "application/pdf" });

      const base = state.files.pdf.name.replace(/\.pdf$/i, "");
      downloadBlob(outBlob, `stamped_${base}.pdf`);
      setStatus("완료! 다운로드가 시작되었습니다.");
    }

    downloadBtn.addEventListener("click", async () => {
      downloadBtn.disabled = true;
      try {
        await stampAndDownload();
      } catch (err) {
        setStatus(err && err.message ? err.message : String(err));
      } finally {
        downloadBtn.disabled = false;
      }
    });

    // =========================
    // 리사이즈: 현재 페이지 재렌더
    // =========================
    let resizeTimer = null;
    window.addEventListener("resize", () => {
      if (!state.pdf.doc) return;
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(async () => {
        try { await renderPage(state.pdf.currentPage); } catch (_) {}
      }, 200);
    });

    // =========================
    // 부팅: 기본 도장 로드
    // =========================
    loadDefaultStampIfExists();
  </script>
</body>
</html>
