<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="/static/style.css" />
  <title>원본대조필 도장 찍기</title>

  <!-- pdf-lib (CDN) : 오프라인이 필요하면 이 파일을 내려받아 로컬로 바꿔 끼우면 됩니다 -->
  <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
</head>

<body>
  <header class="site-header">
    <div class="shell">
      <div class="row between">
        <div style="font-weight:700;">업무보조</div>
        <a class="btn btn-home" href="/">홈</a>
      </div>
    </div>
  </header>

  <main>
    <div class="container">
      <h1>원본대조필 도장 찍기</h1>
      <p class="subtitle">
        PDF를 업로드하면 각 페이지에 원본대조필 도장이 1개씩(5개 중 랜덤) 찍힌 PDF로 변환됩니다.
      </p>

      <section class="section">
        <div class="card">
          <form id="form">
            <div class="grid two">
              <div>
                <div class="local-small muted" style="margin-bottom:6px;">PDF 파일 (필수)</div>
                <input id="pdfInput" type="file" accept="application/pdf" required />
              </div>

              <div>
                <div class="local-small muted" style="margin-bottom:6px;">도장 시트 이미지 (선택)</div>
                <input id="sheetInput" type="file" accept="image/png,image/jpeg,image/webp" />
                <div class="muted local-small" style="margin-top:8px;">
                  미선택 시 기본 경로에서 불러옵니다: <code>/stamp-true-copy/stamp_sheet.png</code>
                </div>
              </div>
            </div>

            <hr />

            <div class="grid two">
              <div>
                <div class="local-small muted" style="margin-bottom:6px;">도장 불투명도</div>
                <input id="opacity" type="number" min="0.1" max="1" step="0.05" value="0.45" />
                <div class="muted local-small" style="margin-top:6px;">
                  0.35~0.6 추천 (원문 가독성 유지)
                </div>
              </div>
              <div>
                <div class="local-small muted" style="margin-bottom:6px;">처리 옵션</div>
                <label class="row" style="align-items:flex-start;">
                  <input id="debugPreview" type="checkbox" />
                  <span class="local-small">도장 추출 미리보기(디버그)</span>
                </label>
              </div>
            </div>

            <div class="row between" style="margin-top:14px;">
              <button id="submitBtn" class="btn primary" type="submit">도장 찍고 다운로드</button>
              <div id="status" class="muted local-small"></div>
            </div>
          </form>
        </div>

        <div id="previewWrap" class="card" style="display:none;">
          <div style="font-weight:700; margin-bottom:8px;">도장 추출 미리보기</div>
          <div id="preview" class="row" style="flex-wrap:wrap; gap:10px;"></div>
          <div class="muted local-small" style="margin-top:8px;">
            5개 도장이 잘 분리되어 보이면 성공입니다.
          </div>
        </div>
      </section>

      <section class="section">
        <div class="card">
          <h3 class="local-h3">파일 배치</h3>
          <ul class="tool-list">
            <li><code>/static/style.css</code> : 공통 CSS</li>
            <li><code>/stamp-true-copy/index.html</code> : 이 페이지</li>
            <li><code>/stamp-true-copy/stamp_sheet.png</code> : 5개 도장 시트 이미지</li>
          </ul>
        </div>
      </section>
    </div>
  </main>

  <footer class="site-footer">
    <div class="shell">
      <p>© 업무보조</p>
    </div>
  </footer>

  <script>
    // ==========
    // 유틸
    // ==========
    const $ = (sel) => document.querySelector(sel);

    function setStatus(msg) {
      $("#status").textContent = msg || "";
    }

    function clamp(n, min, max) {
      return Math.max(min, Math.min(max, n));
    }

    function randInt(max) {
      // crypto가 있으면 더 나은 랜덤
      if (window.crypto && crypto.getRandomValues) {
        const buf = new Uint32Array(1);
        crypto.getRandomValues(buf);
        return buf[0] % max;
      }
      return Math.floor(Math.random() * max);
    }

    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function readFileAsArrayBuffer(file) {
      return new Promise((resolve, reject) => {
        const r = new FileReader();
        r.onload = () => resolve(r.result);
        r.onerror = () => reject(r.error);
        r.readAsArrayBuffer(file);
      });
    }

    async function blobToImage(blob) {
      const url = URL.createObjectURL(blob);
      try {
        const img = new Image();
        img.decoding = "async";
        img.src = url;
        await img.decode();
        return img;
      } finally {
        URL.revokeObjectURL(url);
      }
    }

    async function fetchStampSheetBlob() {
      const res = await fetch("./stamp_sheet.png", { cache: "no-store" });
      if (!res.ok) {
        throw new Error("stamp_sheet.png를 /stamp-true-copy/ 폴더에 넣어주세요.");
      }
      return await res.blob();
    }

    function canvasFromImage(img) {
      const canvas = document.createElement("canvas");
      canvas.width = img.naturalWidth || img.width;
      canvas.height = img.naturalHeight || img.height;
      const ctx = canvas.getContext("2d", { willReadFrequently: true });
      ctx.drawImage(img, 0, 0);
      return canvas;
    }

    // ==========
    // 도장 시트에서 5개 도장 자동 추출
    //  - “대충 잘 돌아가는” 실전형 뼈대 + 튜닝 포인트 주석
    // ==========
    function createForegroundMask(imageData, {
      threshold = 250, // r,g,b 모두 threshold 이상이면 배경으로 간주
      step = 2         // 다운샘플링 (성능용)
    } = {}) {
      const { data, width, height } = imageData;
      const w2 = Math.floor(width / step);
      const h2 = Math.floor(height / step);
      const mask = new Uint8Array(w2 * h2);

      for (let y2 = 0; y2 < h2; y2++) {
        const y = y2 * step;
        for (let x2 = 0; x2 < w2; x2++) {
          const x = x2 * step;
          const i = (y * width + x) * 4;
          const r = data[i], g = data[i + 1], b = data[i + 2], a = data[i + 3];

          // 배경(흰색) vs 전경(도장 잉크)
          const isBg = (a === 0) || (r >= threshold && g >= threshold && b >= threshold);
          mask[y2 * w2 + x2] = isBg ? 0 : 1;
        }
      }

      return { mask, w: w2, h: h2, step, srcW: width, srcH: height };
    }

    function dilateMask(mask, w, h, iterations = 1) {
      // 간단한 8방향 dilation: 얇은 선 끊김 보정
      let cur = mask;
      for (let it = 0; it < iterations; it++) {
        const out = new Uint8Array(cur.length);
        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            const idx = y * w + x;
            if (cur[idx]) { out[idx] = 1; continue; }

            let on = 0;
            // 8-neighborhood
            for (let dy = -1; dy <= 1 && !on; dy++) {
              const ny = y + dy;
              if (ny < 0 || ny >= h) continue;
              for (let dx = -1; dx <= 1; dx++) {
                const nx = x + dx;
                if (nx < 0 || nx >= w) continue;
                if (cur[ny * w + nx]) { on = 1; break; }
              }
            }
            out[idx] = on;
          }
        }
        cur = out;
      }
      return cur;
    }

    function findConnectedComponents(mask, w, h, {
      minPixels = 600 // 다운샘플된 픽셀 기준. 시트 해상도에 따라 조정 가능.
    } = {}) {
      const visited = new Uint8Array(mask.length);
      const stack = new Int32Array(mask.length); // 최악 케이스 대비(성능 안정)
      const comps = [];

      for (let i = 0; i < mask.length; i++) {
        if (!mask[i] || visited[i]) continue;

        let top = 0;
        stack[top++] = i;
        visited[i] = 1;

        let count = 0;
        let minX = w, minY = h, maxX = 0, maxY = 0;

        while (top > 0) {
          const idx = stack[--top];
          count++;

          const x = idx % w;
          const y = (idx / w) | 0;

          if (x < minX) minX = x;
          if (y < minY) minY = y;
          if (x > maxX) maxX = x;
          if (y > maxY) maxY = y;

          // 8-connected neighbors
          for (let dy = -1; dy <= 1; dy++) {
            const ny = y + dy;
            if (ny < 0 || ny >= h) continue;
            for (let dx = -1; dx <= 1; dx++) {
              const nx = x + dx;
              if (nx < 0 || nx >= w) continue;
              if (dx === 0 && dy === 0) continue;

              const nidx = ny * w + nx;
              if (!mask[nidx] || visited[nidx]) continue;
              visited[nidx] = 1;
              stack[top++] = nidx;
            }
          }
        }

        if (count >= minPixels) {
          comps.push({ minX, minY, maxX, maxY, count });
        }
      }

      return comps;
    }

    function pickTopStampBoxes(comps, count = 5) {
      if (comps.length < count) return null;

      // 보통 “도장 테두리” 컴포넌트가 가장 큼 → 상위 5개가 도장일 확률이 높음
      const top = comps
        .slice()
        .sort((a, b) => b.count - a.count)
        .slice(0, count)
        // 위->아래, 왼->오 안정 정렬
        .sort((a, b) => (a.minY - b.minY) || (a.minX - b.minX));

      return top;
    }

    function upscaleBox(box, step, pad, srcW, srcH) {
      let x = box.minX * step;
      let y = box.minY * step;
      let w = (box.maxX - box.minX + 1) * step;
      let h = (box.maxY - box.minY + 1) * step;

      x = Math.max(0, x - pad);
      y = Math.max(0, y - pad);
      w = Math.min(srcW - x, w + pad * 2);
      h = Math.min(srcH - y, h + pad * 2);

      return { x, y, w, h };
    }

    async function canvasToPngBytes(canvas) {
      const blob = await new Promise((resolve) => canvas.toBlob(resolve, "image/png"));
      const ab = await blob.arrayBuffer();
      return new Uint8Array(ab);
    }

    async function extractStampsFromSheet(sheetBlob, {
      bgThreshold = 250,
      alphaScale = 0.9,     // PNG 자체 알파를 조금만 줄이고, 실제 찍기는 opacity로 제어 추천
      step = 2,
      dilation = 2,
      pad = 14,
      debug = false,
    } = {}) {
      const img = await blobToImage(sheetBlob);
      const sheetCanvas = canvasFromImage(img);
      const ctx = sheetCanvas.getContext("2d", { willReadFrequently: true });

      const imgData = ctx.getImageData(0, 0, sheetCanvas.width, sheetCanvas.height);

      // 1) 마스크 생성
      const maskInfo = createForegroundMask(imgData, { threshold: bgThreshold, step });
      // 2) dilation로 끊김 보정
      const dilated = dilateMask(maskInfo.mask, maskInfo.w, maskInfo.h, dilation);
      // 3) 연결요소 탐색
      const comps = findConnectedComponents(dilated, maskInfo.w, maskInfo.h, { minPixels: 600 });
      // 4) 상위 5개 bbox 선택
      const top = pickTopStampBoxes(comps, 5);
      if (!top) {
        throw new Error("도장 5개를 찾지 못했습니다. 이미지 품질/배경을 확인해주세요.");
      }

      const boxes = top.map(b => upscaleBox(b, maskInfo.step, pad, maskInfo.srcW, maskInfo.srcH));

      // 5) crop + 배경 투명화 → PNG bytes 5개
      const stamps = [];
      for (const box of boxes) {
        const c = document.createElement("canvas");
        c.width = box.w;
        c.height = box.h;
        const cctx = c.getContext("2d", { willReadFrequently: true });

        cctx.drawImage(sheetCanvas, box.x, box.y, box.w, box.h, 0, 0, box.w, box.h);

        const d = cctx.getImageData(0, 0, c.width, c.height);
        const p = d.data;

        for (let i = 0; i < p.length; i += 4) {
          const r = p[i], g = p[i + 1], b = p[i + 2];
          const isBg = (r >= bgThreshold && g >= bgThreshold && b >= bgThreshold);

          if (isBg) {
            p[i + 3] = 0; // 배경 투명
          } else {
            // 잉크 픽셀은 살짝만 알파 조정(필요 없으면 1.0)
            p[i + 3] = Math.round(p[i + 3] * alphaScale);
          }
        }

        cctx.putImageData(d, 0, 0);
        stamps.push({
          pngBytes: await canvasToPngBytes(c),
          debugCanvas: debug ? c : null
        });
      }

      return { stamps, boxes };
    }

    function renderStampPreview(stamps) {
      const wrap = $("#previewWrap");
      const holder = $("#preview");
      holder.innerHTML = "";

      for (const s of stamps) {
        const img = document.createElement("img");
        img.style.width = "160px";
        img.style.height = "auto";
        img.style.border = "1px solid #e5e5e5";
        img.style.borderRadius = "10px";
        img.style.background = "#fff";
        img.src = s.debugCanvas.toDataURL("image/png");
        holder.appendChild(img);
      }

      wrap.style.display = "block";
    }

    // ==========
    // PDF에 도장 찍기 (pdf-lib)
    // ==========
    async function stampPdfInBrowser(pdfArrayBuffer, stampPngBytesList, {
      opacity = 0.45,
      margin = 36,
      widthRatio = 0.22,
      minWidth = 120,
      maxWidth = 200,
      onProgress = null,
    } = {}) {
      const { PDFDocument } = PDFLib;

      const pdfDoc = await PDFDocument.load(pdfArrayBuffer);

      // 도장 5개를 문서에 1회 임베드 후 재사용
      const embeddedStamps = [];
      for (const pngBytes of stampPngBytesList) {
        embeddedStamps.push(await pdfDoc.embedPng(pngBytes));
      }

      const pages = pdfDoc.getPages();
      const total = pages.length;

      for (let i = 0; i < total; i++) {
        const page = pages[i];
        const { width: pageW, height: pageH } = page.getSize();

        const stampImg = embeddedStamps[randInt(embeddedStamps.length)];

        const stampW = clamp(pageW * widthRatio, minWidth, maxWidth);
        const scale = stampW / stampImg.width;
        const stampH = stampImg.height * scale;

        // pdf-lib 좌표계: (0,0) = bottom-left
        const x = pageW - margin - stampW;
        const y = margin;

        page.drawImage(stampImg, {
          x, y,
          width: stampW,
          height: stampH,
          opacity: opacity
        });

        if (onProgress && (i % 3 === 0 || i === total - 1)) {
          onProgress(i + 1, total);
          // UI 업데이트를 브라우저에 양보
          await new Promise(r => setTimeout(r, 0));
        }
      }

      const outBytes = await pdfDoc.save({ useObjectStreams: true });
      return outBytes;
    }

    // ==========
    // 이벤트 핸들러
    // ==========
    let cachedStamps = null;
    let cachedKey = null;

    async function getStamps({ sheetFile, debug }) {
      const key = sheetFile
        ? `${sheetFile.name}_${sheetFile.size}_${sheetFile.lastModified}`
        : "DEFAULT_SHEET";

      if (cachedStamps && cachedKey === key) return cachedStamps;

      const sheetBlob = sheetFile ? sheetFile : await fetchStampSheetBlob();
      const { stamps } = await extractStampsFromSheet(sheetBlob, {
        debug,
        // 필요하면 튜닝:
        bgThreshold: 250,
        alphaScale: 1.0,
        step: 2,
        dilation: 2,
        pad: 14,
      });

      cachedStamps = stamps;
      cachedKey = key;
      return cachedStamps;
    }

    $("#form").addEventListener("submit", async (e) => {
      e.preventDefault();

      const pdfFile = $("#pdfInput").files[0];
      if (!pdfFile) {
        setStatus("PDF 파일을 선택하세요.");
        return;
      }
      if (!/\.pdf$/i.test(pdfFile.name)) {
        setStatus("PDF 파일만 업로드할 수 있습니다.");
        return;
      }

      const sheetFile = $("#sheetInput").files[0] || null;
      const debug = $("#debugPreview").checked;

      const submitBtn = $("#submitBtn");
      submitBtn.disabled = true;

      try {
        setStatus("도장 이미지 분석 중…");
        const stamps = await getStamps({ sheetFile, debug });

        if (debug) {
          // debugCanvas가 들어있게 추출됨
          renderStampPreview(stamps);
        } else {
          $("#previewWrap").style.display = "none";
        }

        setStatus("PDF 로딩 중…");
        const pdfAb = await readFileAsArrayBuffer(pdfFile);

        setStatus("페이지 처리 중…");
        const opacity = parseFloat($("#opacity").value || "0.45");
        const stampedBytes = await stampPdfInBrowser(pdfAb, stamps.map(s => s.pngBytes), {
          opacity: clamp(opacity, 0.1, 1.0),
          onProgress: (done, total) => setStatus(`페이지 처리 중… (${done}/${total})`)
        });

        const outBlob = new Blob([stampedBytes], { type: "application/pdf" });
        const base = pdfFile.name.replace(/\.pdf$/i, "");
        downloadBlob(outBlob, `stamped_${base}.pdf`);

        setStatus("완료! 다운로드가 시작되었습니다.");
      } catch (err) {
        setStatus(err && err.message ? err.message : String(err));
      } finally {
        submitBtn.disabled = false;
      }
    });
  </script>



</body>
</html>