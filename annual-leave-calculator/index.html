<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>2026학년도 연차유급휴가 부여일수 계산기</title>

  <link rel="stylesheet" href="/static/style.css" />
  
  <script src="https://cdn.sheetjs.com/xlsx-0.20.3/package/dist/xlsx.full.min.js"></script>

  <!-- 공통 CSS에 없는 앱 전용 최소 스타일만 추가 -->
  <style>
    .msg { border:1px solid #e5e5e5; border-radius:12px; padding:10px 12px; background:#fafafa; }
    .msg.ok { border-color:#b7eb8f; background:#f6ffed; }
    .msg.warn { border-color:#ffd666; background:#fffbe6; }
    .msg.err { border-color:#ffccc7; background:#fff2f0; }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; font-size:0.92rem; border:1px solid #ddd; background:#fff; }
    .pill.ok { border-color:#b7eb8f; }
    .pill.warn { border-color:#ffd666; }
    .pill.err { border-color:#ffccc7; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size:0.95rem; background:#f3f4f6; border:1px solid #e5e7eb; padding:1px 6px; border-radius:6px; }

    details > summary { cursor:pointer; font-weight:700; color:#111; }
    details > summary:hover { text-decoration: underline; }
    .hidden { display:none !important; }

    .table-compact th, .table-compact td { padding: 6px 8px; }
    .right { text-align:right; }
    .center { text-align:center; }
    .nowrap { white-space: nowrap; }

    .stack { display:flex; flex-direction:column; gap:10px; }
    .mini { font-size:0.95rem; color:#555; }

    .danger-line { border-left: 4px solid #ff4d4f; padding-left: 10px; }
    .warn-line { border-left: 4px solid #faad14; padding-left: 10px; }

    /* select 폭: 공통 CSS에 field select rule이 있지만, 여기선 표 내부 select도 안정화 */
    table select { min-width: 140px; }
  </style>
</head>

<body>
  <header class="site-header">
    <div class="shell">
      <h1>2026학년도 연차유급휴가 부여일수 계산기</h1>
      <p class="subtitle">
        기준기간: <span class="kbd">2025-03-01 ~ 2026-02-28</span> · 부여기준일: <span class="kbd">2026-03-01</span> ·
        브라우저 로컬 처리(서버 전송 없음)
      </p>
    </div>
  </header>

  <main class="container">
    <section class="section">
      <h2>1. 학사일정 입력(학교별)</h2>
      <p class="muted">
        방학중 비상시근로자 출근율(학기/연간) 계산에 사용합니다. 상시근로자만 산정하는 경우에도 입력해두면 검토가 편합니다.
      </p>

      <div class="grid two">
        <div class="card">
          <h3 class="local-h3 local-tight">여름방학</h3>
          <div class="grid two">
            <label class="stack">
              <span class="mini">시작일</span>
              <input type="date" id="summerStart" />
            </label>
            <label class="stack">
              <span class="mini">종료일</span>
              <input type="date" id="summerEnd" />
            </label>
          </div>
        </div>
        <div class="card">
          <h3 class="local-h3 local-tight">겨울방학</h3>
          <div class="grid two">
            <label class="stack">
              <span class="mini">시작일</span>
              <input type="date" id="winterStart" />
            </label>
            <label class="stack">
              <span class="mini">종료일</span>
              <input type="date" id="winterEnd" />
            </label>
          </div>
        </div>
      </div>

      <div class="row gap">
        <button class="btn primary" id="btnApplyCalendar">학사일정 적용</button>
        <button class="btn ghost" id="btnSetExampleCalendar">예시 입력(테스트)</button>
      </div>

      <div id="calendarSummary" class="msg" style="margin-top:12px;"></div>
    </section>

    <section class="section">
      <h2>2. 인사정보 입력 방식 선택</h2>
      <p class="muted">
        인사기록 조회 엑셀 파일이 없을 수도 있으므로 <b>파일 업로드</b> 또는 <b>수기 입력</b> 중 선택합니다.
      </p>

      <div class="card">
        <div class="row gap">
          <label class="row"><input type="radio" name="hrMode" value="file" checked /> 파일 업로드</label>
          <label class="row"><input type="radio" name="hrMode" value="manual" /> 수기 입력</label>
        </div>

        <div id="hrFileBox" style="margin-top:12px;">
          <div class="grid two">
            <label class="stack">
              <span class="mini">인사기록 조회 엑셀(.xlsx)</span>
              <input type="file" id="hrFile" accept=".xlsx,.xls" />
            </label>
            <div class="msg warn">
              <div><b>안내</b></div>
              <ul>
                <li>엑셀 파싱은 <span class="kbd">XLSX(SheetJS)</span> 로딩이 필요합니다.</li>
                <li>내부망에서 CDN 차단 시, 라이브러리를 로컬 파일로 포함해야 합니다.</li>
              </ul>
            </div>
          </div>
          <div class="row gap" style="margin-top:10px;">
            <button class="btn primary" id="btnLoadHr">인사파일 불러오기</button>
            <button class="btn" id="btnClearHr">인사정보 초기화</button>
          </div>
          <div id="hrMsg" class="msg" style="margin-top:12px;"></div>
        </div>

        <div id="hrManualBox" class="hidden" style="margin-top:12px;">
          <h3 class="local-h3">대상자 수기 등록</h3>

          <div class="grid three">
            <label class="stack">
              <span class="mini">성명(필수)</span>
              <input type="text" id="mName" placeholder="홍길동" />
            </label>
            <label class="stack">
              <span class="mini">개인번호(선택)</span>
              <input type="text" id="mPid" placeholder="K1234567 등" />
            </label>
            <label class="stack">
              <span class="mini">최초임용일(필수)</span>
              <input type="date" id="mHire" />
            </label>

            <label class="stack">
              <span class="mini">직군</span>
              <select id="mGroup">
                <option value="regular">교육공무직</option>
                <option value="special">특수운영직군</option>
              </select>
            </label>

            <label class="stack">
              <span class="mini">근무형태</span>
              <select id="mPattern">
                <option value="always">상시 근무자</option>
                <option value="emergency">방학 중 비상시 근로자</option>
              </select>
            </label>

            <label class="stack">
              <span class="mini">1일 소정근로시간</span>
              <input type="number" id="mDailyHours" value="8" min="1" max="12" step="1" class="numeric" />
            </label>
          </div>

          <div class="row gap" style="margin-top:10px;">
            <button class="btn primary" id="btnAddWorker">대상자 추가</button>
            <button class="btn" id="btnClearWorkers">대상자 전체 삭제</button>
          </div>

          <div class="table-wrap">
            <table class="sheetlike table-compact" id="workersTable">
              <thead>
                <tr>
                  <th class="nowrap">키</th>
                  <th class="nowrap">성명</th>
                  <th class="nowrap">개인번호</th>
                  <th class="nowrap">직군</th>
                  <th class="nowrap">근무형태</th>
                  <th class="nowrap">최초임용일</th>
                  <th class="nowrap right">1일시간</th>
                  <th class="nowrap right">근속(2026-03-01)</th>
                  <th class="nowrap center">삭제</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>

          <div id="hrManualMsg" class="msg" style="margin-top:12px;"></div>
        </div>
      </div>
    </section>

    <section class="section">
      <h2>3. 근무상황(복무) 입력 방식 선택</h2>
      <p class="muted">
        근무상황조회(근무상황목록) 파일이 없을 수도 있으므로 <b>파일 업로드</b> 또는 <b>수기 입력</b> 중 선택합니다.
        파일 업로드 시에는 복무 전체 목록을 자동 취합·분류하여 결과로 출력합니다.
      </p>

      <div class="card">
        <div class="row gap">
          <label class="row"><input type="radio" name="workMode" value="file" checked /> 파일 업로드</label>
          <label class="row"><input type="radio" name="workMode" value="manual" /> 수기 입력</label>
        </div>

        <div id="workFileBox" style="margin-top:12px;">
          <div class="grid two">
            <label class="stack">
              <span class="mini">근무상황목록 엑셀/CSV(다중 업로드 가능)</span>
              <input type="file" id="workFiles" accept=".xlsx,.xls,.csv" multiple />
            </label>
            <div class="msg warn">
              <div><b>안내</b></div>
              <ul>
                <li>복무를 잘못 낸 경우를 대비해, <b>모든 복무 내역을 취합</b>하여 자동 분류하고 검토표로 출력합니다.</li>
                <li>자동 분류가 애매한 항목은 <span class="pill warn">검토</span>로 표시됩니다(사람 확인 필요).</li>
              </ul>
            </div>
          </div>

          <div class="row gap" style="margin-top:10px;">
            <button class="btn primary" id="btnLoadWork">근무상황 파일 불러오기</button>
            <button class="btn" id="btnClearWork">근무상황 초기화</button>
          </div>
          <div id="workMsg" class="msg" style="margin-top:12px;"></div>
        </div>

        <div id="workManualBox" class="hidden" style="margin-top:12px;">
          <h3 class="local-h3">복무 수기 등록(예외사항 중심)</h3>
          <p class="muted">
            수기 입력 모드는 기본적으로 “정상 근무(출근)”을 전제로 하고, <b>산정에 영향 있는 예외사항</b>(산정 제외/결근성/방학근무크레딧 등)을 기간 단위로 입력하는 방식입니다.
          </p>

          <div class="grid three">
            <label class="stack">
              <span class="mini">대상자 선택</span>
              <select id="wSelect"></select>
            </label>
            <label class="stack">
              <span class="mini">시작일</span>
              <input type="date" id="wStart" />
            </label>
            <label class="stack">
              <span class="mini">종료일</span>
              <input type="date" id="wEnd" />
            </label>

            <label class="stack">
              <span class="mini">복무종별(텍스트)</span>
              <input type="text" id="wType" placeholder="질병휴직 / 결근 / 연가 등" />
            </label>

            <label class="stack">
              <span class="mini">사유(선택)</span>
              <input type="text" id="wReason" placeholder="필요 시 입력" />
            </label>

            <label class="stack">
              <span class="mini">분류(자동/수동)</span>
              <select id="wClass">
                <option value="auto">자동판별</option>
                <option value="deemed">출근간주(분자 포함)</option>
                <option value="excluded">산정제외(분모·분자 제외)</option>
                <option value="absence">결근성(출근율↓/개근월수 제외)</option>
                <option value="review">검토(확인 필요)</option>
              </select>
            </label>
          </div>

          <div class="row gap" style="margin-top:10px;">
            <label class="row">
              <input type="checkbox" id="wCredit" />
              방학근무크레딧(연간 출근율 분자에 반영)
            </label>
            <button class="btn primary" id="btnAddRecord">복무 추가</button>
            <button class="btn" id="btnClearManualRecords">수기 복무 전체 삭제</button>
          </div>

          <div id="workManualMsg" class="msg" style="margin-top:12px;"></div>
        </div>
      </div>
    </section>

    <section class="section">
      <h2>4. 계산 실행</h2>

      <div class="card">
        <div class="grid two">
          <div class="msg">
            <div><b>비상시근로자 출근율(3종)</b></div>
            <ol>
              <li>비상시 기준(학기=방학 제외) 출근율</li>
              <li>상시 기준(연간=방학 포함) 출근율</li>
              <li>산정 제외기간 제거 후 비상시 기준 출근율</li>
            </ol>
            <div class="muted">상시근로자는 연간 기준(1종)만 산정합니다.</div>
          </div>

          <div class="msg">
            <div><b>고정값</b></div>
            <ul>
              <li>기준기간: 2025-03-01 ~ 2026-02-28</li>
              <li>부여기준일: 2026-03-01</li>
              <li>토요일은 분모에서 제외(연간/학기 동일)</li>
              <li>비례부여: 소수 둘째 자리 반올림 → 시간단위 환산</li>
            </ul>
          </div>
        </div>

        <div class="row gap" style="margin-top:12px;">
          <button class="btn primary" id="btnRun">계산 실행</button>
          <button class="btn" id="btnDownload">결과 다운로드(XLSX)</button>
          <button class="btn ghost" id="btnSaveLocal">로컬 저장</button>
          <button class="btn ghost" id="btnLoadLocal">로컬 불러오기</button>
        </div>

        <div id="runMsg" class="msg" style="margin-top:12px;"></div>
      </div>
    </section>

    <section class="section">
      <h2>5. 결과</h2>

      <div id="resultSummary" class="msg">계산 실행 후 결과가 표시됩니다.</div>

      <div class="table-wrap">
        <table class="sheetlike table-compact" id="resultTable">
          <thead>
            <tr>
              <th class="nowrap">키</th>
              <th class="nowrap">성명</th>
              <th class="nowrap">직군</th>
              <th class="nowrap">근무형태</th>
              <th class="nowrap right">근속</th>
              <th class="nowrap right">출근율(학기)</th>
              <th class="nowrap right">출근율(연간)</th>
              <th class="nowrap right">출근율(재산정)</th>
              <th class="nowrap right">기본+가산</th>
              <th class="nowrap right">최종부여</th>
              <th class="nowrap">판정</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>

      <h3>개인별 상세(복무 취합/분류 포함)</h3>
      <div id="detailBox" class="stack"></div>
    </section>

    <footer class="site-footer">
      <div class="shell">
        <p>본 도구는 2026학년도(2026-03-01 부여) 전용입니다. 단체협약/편람 변경 반영 없음.</p>
        <p>파일 처리는 브라우저 로컬에서 수행됩니다(서버 업로드/전송 없음).</p>
      </div>
    </footer>
  </main>

<script>
/** =========================================================
 *  2026학년도 연차 계산기 (단일 HTML / JS-only)
 *  - 기준기간: 2025-03-01 ~ 2026-02-28
 *  - 부여기준일: 2026-03-01
 *  - 토요일 제외(분모), 방학(학기 분모에서 제외)
 *  - 비상시: 출근율 3종
 *  - 입력: 인사/근무상황 각 "파일 or 수기" 선택
 *  ========================================================= */

(() => {
  "use strict";

  /** ---------------------------
   *  고정 상수(일회성: 2026학년도 전용)
   *  --------------------------- */
  const PERIOD_START = ymdToUTC("2025-03-01");
  const PERIOD_END   = ymdToUTC("2026-02-28"); // inclusive
  const GRANT_DATE   = ymdToUTC("2026-03-01");

  const DEFAULT_DAILY_HOURS = 8;

  const CLASS_LABEL = {
    deemed: "출근간주",
    excluded: "산정제외",
    absence: "결근성",
    review: "검토",
    auto: "자동"
  };

  // 2026학년도 전용 자동 분류 룰(필요 시 여기만 수정하면 됨)
  // - 실제 NAIS 종별/사유 표기가 학교/교육청마다 다를 수 있으므로 "키워드 포함" 방식으로 보수적으로 구현
  const RULES_2026 = {
    // 산정제외(분모·분자 제외) 키워드
    excludedKeywords: [
      "질병휴직", "가족돌봄휴직", "노조전임", "유학휴직", "행방불명",
      "파업", "쟁의", "휴업", "사용자귀책"
    ],
    // 결근성(출근율↓ / 개근월수 제외) 키워드
    absenceKeywords: [
      "결근", "무단", "연차초과", "미승인", "무급결근"
    ],
    // 출근간주(분자 포함) 키워드
    deemedKeywords: [
      "연가", "연차", "공가", "특별휴가", "경조", "유급병가", "병가",
      "산재", "요양", "출산", "유산", "사산", "배우자출산",
      "예비군", "민방위", "동원", "공민권", "보상휴가", "휴일대체",
      "가족돌봄휴가", "생리휴가", "난임", "임신기", "육아기"
    ],
    // 방학근무크레딧 추정 키워드(방학 기간과 겹치면 분자에 더해줌)
    creditKeywords: [
      "방학", "급식실", "청소", "우선채용", "산업안전", "직무연수", "연수", "교육"
    ],
    // 검토 필요 키워드(애매하거나 학교별 처리차 큰 유형)
    reviewKeywords: [
      "재량휴업", "개교기념", "단축", "외근", "출장", "조합", "노조", "대체"
    ]
  };

  /** ---------------------------
   *  상태(State)
   *  --------------------------- */
  const state = {
    calendar: {
      summerStart: null,
      summerEnd: null,
      winterStart: null,
      winterEnd: null,
      applied: false,
      sets: null, // {fullSet, semesterSet, vacationSet, counts...}
    },
    workers: new Map(), // key -> worker
    records: [], // {id, workerKey, start, end, type, reason, minutes, autoClass, finalClass, credit}
    results: [], // 계산 결과
    lastRunAt: null,
  };

  /** ---------------------------
   *  DOM Helpers
   *  --------------------------- */
  const $ = (sel) => document.querySelector(sel);
  const $$ = (sel) => Array.from(document.querySelectorAll(sel));

  function setMsg(el, cls, html) {
    el.className = `msg ${cls || ""}`.trim();
    el.innerHTML = html;
  }

  function escapeHtml(s) {
    return String(s ?? "")
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  /** ---------------------------
   *  Date Utilities (UTC 기반)
   *  --------------------------- */
  function ymdToUTC(ymd) {
    // ymd: "YYYY-MM-DD"
    const [y, m, d] = ymd.split("-").map(Number);
    return new Date(Date.UTC(y, m - 1, d));
  }

  function utcToYmd(date) {
    const y = date.getUTCFullYear();
    const m = String(date.getUTCMonth() + 1).padStart(2, "0");
    const d = String(date.getUTCDate()).padStart(2, "0");
    return `${y}-${m}-${d}`;
  }

  function addDaysUTC(date, days) {
    const t = date.getTime() + days * 86400000;
    return new Date(t);
  }

  function clampToPeriod(date) {
    if (date < PERIOD_START) return PERIOD_START;
    if (date > PERIOD_END) return PERIOD_END;
    return date;
  }

  function isSaturdayUTC(date) {
    // 0 Sun ... 6 Sat
    return date.getUTCDay() === 6;
  }

  function isWithinInclusive(date, start, end) {
    return date >= start && date <= end;
  }

  function normalizeRange(start, end) {
    if (!start || !end) return null;
    if (end < start) [start, end] = [end, start];
    start = clampToPeriod(start);
    end = clampToPeriod(end);
    if (end < PERIOD_START || start > PERIOD_END) return null;
    return { start, end };
  }

  /** ---------------------------
   *  Calendar Sets
   *  - fullSet: 기준기간 내 "토요일 제외" 날짜
   *  - vacationSet: 여름+겨울방학 기간 내 "토요일 제외" 날짜
   *  - semesterSet: fullSet - vacationSet
   *  --------------------------- */
  function buildCalendarSets() {
    const fullSet = new Set();
    const vacationSet = new Set();

    // full set
    for (let d = PERIOD_START; d <= PERIOD_END; d = addDaysUTC(d, 1)) {
      if (isSaturdayUTC(d)) continue;
      fullSet.add(utcToYmd(d));
    }

    // vacation set
    const ss = state.calendar.summerStart;
    const se = state.calendar.summerEnd;
    const ws = state.calendar.winterStart;
    const we = state.calendar.winterEnd;

    const vacRanges = [];
    const r1 = (ss && se) ? normalizeRange(ss, se) : null;
    const r2 = (ws && we) ? normalizeRange(ws, we) : null;
    if (r1) vacRanges.push(r1);
    if (r2) vacRanges.push(r2);

    for (const r of vacRanges) {
      for (let d = r.start; d <= r.end; d = addDaysUTC(d, 1)) {
        if (isSaturdayUTC(d)) continue;
        const ymd = utcToYmd(d);
        if (fullSet.has(ymd)) vacationSet.add(ymd);
      }
    }

    const semesterSet = new Set();
    for (const ymd of fullSet) {
      if (!vacationSet.has(ymd)) semesterSet.add(ymd);
    }

    const fullCount = fullSet.size;
    const vacCount = vacationSet.size;
    const semCount = semesterSet.size;

    state.calendar.sets = {
      fullSet,
      vacationSet,
      semesterSet,
      fullCount,
      vacCount,
      semCount
    };
  }

  function renderCalendarSummary() {
    const el = $("#calendarSummary");
    const sets = state.calendar.sets;

    if (!state.calendar.applied || !sets) {
      setMsg(el, "warn", `
        <div><b>학사일정 미적용</b></div>
        <div class="muted">여름/겨울방학을 입력하고 <span class="kbd">학사일정 적용</span>을 눌러주세요.</div>
      `);
      return;
    }

    const ss = state.calendar.summerStart ? utcToYmd(state.calendar.summerStart) : "-";
    const se = state.calendar.summerEnd ? utcToYmd(state.calendar.summerEnd) : "-";
    const ws = state.calendar.winterStart ? utcToYmd(state.calendar.winterStart) : "-";
    const we = state.calendar.winterEnd ? utcToYmd(state.calendar.winterEnd) : "-";

    setMsg(el, "ok", `
      <div><b>학사일정 적용 완료</b></div>
      <ul>
        <li>여름방학: ${ss} ~ ${se}</li>
        <li>겨울방학: ${ws} ~ ${we}</li>
      </ul>
      <ul>
        <li>연간 총일수(토요일 제외): <b>${sets.fullCount}</b>일</li>
        <li>방학일수(토요일 제외): <b>${sets.vacCount}</b>일</li>
        <li>학기 총일수(토요일 제외, 방학 제외): <b>${sets.semCount}</b>일</li>
      </ul>
      <div class="muted">※ 방학 입력이 없으면 비상시 출근율(학기/연간) 산정 정확도가 저하됩니다.</div>
    `);
  }

  /** ---------------------------
   *  Worker Utilities
   *  --------------------------- */
  function workerKeyOf(name, pid) {
    const p = (pid || "").trim();
    if (p) return p;
    return (name || "").trim();
  }

  function computeServiceYears(hireDateUTC) {
    // 2026-03-01 기준 "완료 연수" 계산 (예: 2023-03-01 -> 3년)
    if (!hireDateUTC) return 0;
    const y = GRANT_DATE.getUTCFullYear() - hireDateUTC.getUTCFullYear();
    const m = GRANT_DATE.getUTCMonth() - hireDateUTC.getUTCMonth();
    const d = GRANT_DATE.getUTCDate() - hireDateUTC.getUTCDate();
    let years = y;
    if (m < 0 || (m === 0 && d < 0)) years -= 1;
    return Math.max(0, years);
  }

  function addOrUpdateWorker(w) {
    // w: {key,name,pid,group,pattern,hireDateUTC,dailyHours}
    if (!w.key) w.key = workerKeyOf(w.name, w.pid);
    if (!w.key) throw new Error("대상자 키 생성 실패(성명/개인번호 확인)");

    const prev = state.workers.get(w.key);
    const merged = prev ? { ...prev, ...w } : w;

    merged.serviceYears = computeServiceYears(merged.hireDateUTC);
    merged.addDays = Math.floor(Math.max(0, merged.serviceYears - 1) / 2);

    state.workers.set(merged.key, merged);
  }

  function renderWorkersTable() {
    const tbody = $("#workersTable tbody");
    tbody.innerHTML = "";

    const arr = Array.from(state.workers.values())
      .sort((a, b) => (a.name || "").localeCompare(b.name || "", "ko"));

    for (const w of arr) {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td class="nowrap">${escapeHtml(w.key)}</td>
        <td class="nowrap">${escapeHtml(w.name)}</td>
        <td class="nowrap">${escapeHtml(w.pid || "")}</td>
        <td class="nowrap">${w.group === "special" ? "특수운영직군" : "교육공무직"}</td>
        <td class="nowrap">${w.pattern === "emergency" ? "방학중 비상시" : "상시"}</td>
        <td class="nowrap">${w.hireDateUTC ? utcToYmd(w.hireDateUTC) : ""}</td>
        <td class="right nowrap">${escapeHtml(String(w.dailyHours ?? DEFAULT_DAILY_HOURS))}</td>
        <td class="right nowrap">${escapeHtml(String(w.serviceYears ?? 0))}년</td>
        <td class="center nowrap"><button class="btn btn-lightgrey" data-del="${escapeHtml(w.key)}">삭제</button></td>
      `;
      tbody.appendChild(tr);
    }

    // delete bindings
    tbody.querySelectorAll("button[data-del]").forEach(btn => {
      btn.addEventListener("click", () => {
        const key = btn.getAttribute("data-del");
        state.workers.delete(key);

        // 관련 레코드 제거
        state.records = state.records.filter(r => r.workerKey !== key);

        renderWorkersTable();
        renderWorkerSelect();
      });
    });

    // message
    setMsg($("#hrManualMsg"), arr.length ? "ok" : "warn", `
      <div><b>대상자 수</b>: ${arr.length}명</div>
      <div class="muted">※ 수기 입력 시, 근무상황(복무)도 수기 입력으로 충분히 산정 가능합니다.</div>
    `);
  }

  function renderWorkerSelect() {
    const sel = $("#wSelect");
    sel.innerHTML = "";
    const arr = Array.from(state.workers.values())
      .sort((a,b) => (a.name||"").localeCompare(b.name||"", "ko"));

    if (arr.length === 0) {
      const opt = document.createElement("option");
      opt.value = "";
      opt.textContent = "대상자 없음(인사정보 입력 필요)";
      sel.appendChild(opt);
      sel.disabled = true;
      return;
    }

    sel.disabled = false;
    for (const w of arr) {
      const opt = document.createElement("option");
      opt.value = w.key;
      opt.textContent = `${w.name} (${w.key}) · ${w.group==="special"?"특수":"일반"}/${w.pattern==="emergency"?"비상시":"상시"}`;
      sel.appendChild(opt);
    }
  }

  /** ---------------------------
   *  Records Utilities
   *  --------------------------- */
  function nextRecordId() {
    return "R" + Math.random().toString(36).slice(2, 10) + Date.now().toString(36);
  }

  function autoClassify(type, reason) {
    const t = String(type || "");
    const r = String(reason || "");
    const hay = (t + " " + r).trim();

    if (!hay) return "review";

    // 우선순위: excluded > absence > deemed > review
    if (includesAny(hay, RULES_2026.excludedKeywords)) return "excluded";
    if (includesAny(hay, RULES_2026.absenceKeywords)) return "absence";
    if (includesAny(hay, RULES_2026.deemedKeywords)) return "deemed";
    if (includesAny(hay, RULES_2026.reviewKeywords)) return "review";

    // 아무것도 매칭 안 되면 검토
    return "review";
  }

  function autoCreditGuess(type, reason) {
    const hay = (String(type||"") + " " + String(reason||"")).trim();
    if (!hay) return false;
    return includesAny(hay, RULES_2026.creditKeywords);
  }

  function includesAny(text, keywords) {
    const s = text.replace(/\s+/g, "");
    return keywords.some(k => s.includes(String(k).replace(/\s+/g, "")));
  }

  function addRecord(rec) {
    // rec: {workerKey, startUTC, endUTC, type, reason, minutes(optional), classMode(optional), finalClass(optional), credit(optional)}
    const range = normalizeRange(rec.startUTC, rec.endUTC);
    if (!range) throw new Error("복무 기간이 기준기간과 겹치지 않습니다.");

    const r = {
      id: nextRecordId(),
      workerKey: rec.workerKey,
      startUTC: range.start,
      endUTC: range.end,
      type: rec.type || "",
      reason: rec.reason || "",
      minutes: rec.minutes ?? null, // null이면 날짜 범위로 일수 계산(1일=일근로시간)
      autoClass: autoClassify(rec.type, rec.reason),
      finalClass: rec.finalClass || null, // null이면 autoClass 사용
      credit: !!rec.credit
    };

    // credit 기본 추정(수기/파일 공통): 방학과 겹치고 키워드 매칭이면 true
    if (!r.credit && state.calendar.sets) {
      const anyVac = rangeOverlapsVacation(r.startUTC, r.endUTC);
      if (anyVac && autoCreditGuess(r.type, r.reason)) r.credit = true;
    }

    state.records.push(r);
  }

  function rangeOverlapsVacation(startUTC, endUTC) {
    if (!state.calendar.sets) return false;
    for (let d = startUTC; d <= endUTC; d = addDaysUTC(d, 1)) {
      const ymd = utcToYmd(d);
      if (state.calendar.sets.vacationSet.has(ymd)) return true;
    }
    return false;
  }

  function recordClass(r) {
    return r.finalClass || r.autoClass || "review";
  }

  function computeRecordMinutesOnSet(r, dateSet, dailyMinutes) {
    // r.minutes가 있는 경우: 범위 내 포함 날짜 수 기준으로 캡
    // r.minutes가 없으면: 포함 날짜 수 * dailyMinutes
    let count = 0;
    for (let d = r.startUTC; d <= r.endUTC; d = addDaysUTC(d, 1)) {
      const ymd = utcToYmd(d);
      if (!dateSet.has(ymd)) continue;
      count += 1;
    }
    if (count === 0) return 0;

    if (r.minutes == null) {
      return count * dailyMinutes;
    }

    // minutes 제공된 경우
    const cap = count * dailyMinutes;
    return Math.max(0, Math.min(cap, Number(r.minutes) || 0));
  }

  /** ---------------------------
   *  Attendance & Leave Calculation
   *  --------------------------- */

  function baseDaysForWorker(w, rates) {
    // 기본일수 결정(요구 반영)
    // - 상시(교육공무직): 15
    // - 비상시(교육공무직): 기본 12, 단 연간출근율(상시기준) 80% 이상이면 15로 전환
    // - 비상시(특수운영직군): 기본 11, 단 연간출근율 80% 이상이면 15로 전환(가산효과 4일)
    const rFull = rates.rateFull ?? 0;
    const isEmergency = (w.pattern === "emergency");
    const isSpecial = (w.group === "special");

    if (!isEmergency) {
      return 15;
    }

    // emergency
    if (!isSpecial) {
      return (rFull >= 0.8) ? 15 : 12;
    } else {
      return (rFull >= 0.8) ? 15 : 11;
    }
  }

  function totalStandardDays(w, baseDays) {
    // 근속가산 + 25일 상한
    const add = w.addDays ?? 0;
    return Math.min(25, baseDays + add);
  }

  function calcRatesForWorker(w) {
    // returns:
    // - for always: rateFull, rateRecalcFull (재산정은 내부 참고용), rateSemester=null, rateRecalcSemester=null
    // - for emergency: rateSemester, rateFull, rateRecalcSemester
    const dailyHours = Number(w.dailyHours || DEFAULT_DAILY_HOURS);
    const dailyMinutes = dailyHours * 60;

    if (!state.calendar.sets) {
      // 캘린더 미적용 상태에서도 상시는 계산 가능, 비상시는 경고
      buildCalendarSets();
    }
    const sets = state.calendar.sets;

    const workerRecords = state.records.filter(r => r.workerKey === w.key);

    // 집계(분류별)
    // - excluded/absence는 출근율에 직접 영향
    // - deemed는 정보성
    // - credit는 비상시 연간출근율 분자(방학근무)로 사용
    let excludedFull = 0, absenceFull = 0;
    let excludedSem = 0, absenceSem = 0;
    let creditVac = 0;

    // full year 기준: 토요일 제외 전체
    for (const r of workerRecords) {
      const cls = recordClass(r);
      const mFull = computeRecordMinutesOnSet(r, sets.fullSet, dailyMinutes);

      if (cls === "excluded") excludedFull += mFull;
      if (cls === "absence") absenceFull += mFull;

      // semester 기준(비상시)
      const mSem = computeRecordMinutesOnSet(r, sets.semesterSet, dailyMinutes);
      if (cls === "excluded") excludedSem += mSem;
      if (cls === "absence") absenceSem += mSem;

      // vacation credit: 방학기간 + credit 체크된 항목만 분자에 더함
      if (r.credit) {
        const mVac = computeRecordMinutesOnSet(r, sets.vacationSet, dailyMinutes);
        creditVac += mVac;
      }
    }

    const fullTotal = sets.fullCount * dailyMinutes;

    if (w.pattern !== "emergency") {
      // 상시
      const attended = Math.max(0, fullTotal - excludedFull - absenceFull);
      const rateFull = safeDiv(attended, fullTotal);
      const rateRecalcFull = safeDiv(attended, Math.max(1, fullTotal - excludedFull));

      return {
        dailyMinutes,
        fullTotal,
        semTotal: null,
        excludedFull, absenceFull,
        excludedSem: null, absenceSem: null,
        creditVac: null,
        attendedFull: attended,
        attendedSem: null,
        rateSemester: null,
        rateFull,
        rateRecalcSemester: null,
        rateRecalcFull
      };
    }

    // 비상시
    const semTotal = sets.semCount * dailyMinutes;
    const attendedSem = Math.max(0, semTotal - excludedSem - absenceSem);

    // 연간 분자(상시 기준): 학기 출근(가정) + 방학근무크레딧
    // ※ 방학은 원칙적으로 근로제공 정지 기간이므로 기본 분자는 0, 크레딧만 반영
    const attendedFull = Math.max(0, attendedSem + creditVac);

    const rateSemester = safeDiv(attendedSem, semTotal);
    const rateRecalcSemester = safeDiv(attendedSem, Math.max(1, semTotal - excludedSem));
    const rateFull = safeDiv(attendedFull, fullTotal);

    return {
      dailyMinutes,
      fullTotal,
      semTotal,
      excludedFull, absenceFull, // 참고용
      excludedSem, absenceSem,
      creditVac,
      attendedFull,
      attendedSem,
      rateSemester,
      rateFull,
      rateRecalcSemester,
      rateRecalcFull: null
    };
  }

  function safeDiv(a, b) {
    if (!b || b <= 0) return 0;
    return a / b;
  }

  function roundToOneDecimalDays(days) {
    return Math.round(days * 10) / 10;
  }

  function daysToDaysHours(days, dailyHours) {
    const d = Math.floor(days);
    const frac = days - d;
    let h = Math.round(frac * dailyHours);
    let dd = d;
    if (h >= dailyHours) { dd += 1; h = 0; }
    return { days: dd, hours: h };
  }

  function calcGrantForWorker(w) {
    const rates = calcRatesForWorker(w);
    const baseDays = baseDaysForWorker(w, rates);
    const standard = totalStandardDays(w, baseDays);

    const serviceYears = w.serviceYears ?? 0;
    const isEmergency = (w.pattern === "emergency");

    // 1년 미만: 월 단위 1일(개근월수) 산정
    if (serviceYears < 1) {
      const monthly = calcMonthlyAccrual(w);
      return {
        workerKey: w.key,
        baseDays,
        addDays: w.addDays ?? 0,
        standardDays: standard,
        finalDays: monthly.days,
        finalHours: monthly.hours,
        method: "신규(1년 미만) 1개월 개근 1일",
        note: monthly.note,
        rates
      };
    }

    // 1년 이상: 80% / 비례 / 개근월수(80 미만) 경로
    if (!isEmergency) {
      // 상시: 연간 1종 기준
      const rate1 = rates.rateFull ?? 0;
      const rate2 = rates.rateRecalcFull ?? 0;

      if (rate1 >= 0.8) {
        return {
          workerKey: w.key,
          baseDays,
          addDays: w.addDays ?? 0,
          standardDays: standard,
          finalDays: standard,
          finalHours: 0,
          method: "정상부여(연간 출근율 80% 이상)",
          note: "",
          rates
        };
      }

      if (rate2 >= 0.8) {
        // 비례부여: (기본+가산) * (총일수-제외)/총일수
        const fullDays = state.calendar.sets ? state.calendar.sets.fullCount : 0;
        const excludedDays = Math.round((rates.excludedFull ?? 0) / rates.dailyMinutes);
        const ratio = safeDiv(Math.max(0, fullDays - excludedDays), Math.max(1, fullDays));
        const raw = standard * ratio;
        const rounded = roundToOneDecimalDays(raw);
        const dh = daysToDaysHours(rounded, (w.dailyHours || DEFAULT_DAILY_HOURS));
        return {
          workerKey: w.key,
          baseDays,
          addDays: w.addDays ?? 0,
          standardDays: standard,
          finalDays: dh.days,
          finalHours: dh.hours,
          method: "비례부여(제외기간 재산정 80% 충족)",
          note: `비례: ${standard} × (${fullDays - excludedDays}/${fullDays}) = ${rounded}일`,
          rates
        };
      }

      // 재산정도 80 미만 → 개근월수
      const monthly = calcMonthlyAccrual(w);
      return {
        workerKey: w.key,
        baseDays,
        addDays: w.addDays ?? 0,
        standardDays: standard,
        finalDays: monthly.days,
        finalHours: monthly.hours,
        method: "80% 미달 → 개근월수(1개월 1일)",
        note: monthly.note,
        rates
      };
    }

    // 비상시: 학기 80% / 학기 재산정 80% / 개근월수
    const rateSem = rates.rateSemester ?? 0;
    const rateSem2 = rates.rateRecalcSemester ?? 0;

    if (rateSem >= 0.8) {
      return {
        workerKey: w.key,
        baseDays,
        addDays: w.addDays ?? 0,
        standardDays: standard,
        finalDays: standard,
        finalHours: 0,
        method: "정상부여(학기 출근율 80% 이상)",
        note: "",
        rates
      };
    }

    if (rateSem2 >= 0.8) {
      const semDays = state.calendar.sets ? state.calendar.sets.semCount : 0;
      const excludedDays = Math.round((rates.excludedSem ?? 0) / rates.dailyMinutes);
      const ratio = safeDiv(Math.max(0, semDays - excludedDays), Math.max(1, semDays));
      const raw = standard * ratio;
      const rounded = roundToOneDecimalDays(raw);
      const dh = daysToDaysHours(rounded, (w.dailyHours || DEFAULT_DAILY_HOURS));
      return {
        workerKey: w.key,
        baseDays,
        addDays: w.addDays ?? 0,
        standardDays: standard,
        finalDays: dh.days,
        finalHours: dh.hours,
        method: "비례부여(제외기간 제거 후 학기 80% 충족)",
        note: `비례: ${standard} × (${semDays - excludedDays}/${semDays}) = ${rounded}일`,
        rates
      };
    }

    const monthly = calcMonthlyAccrual(w);
    return {
      workerKey: w.key,
      baseDays,
      addDays: w.addDays ?? 0,
      standardDays: standard,
      finalDays: monthly.days,
      finalHours: monthly.hours,
      method: "80% 미달 → 개근월수(1개월 1일)",
      note: monthly.note,
      rates
    };
  }

  function calcMonthlyAccrual(w) {
    // 단순화된 “개근월수” 계산
    // - 결근성(absence) 레코드가 해당 월(또는 방학 버킷)에 1건이라도 있으면 개근 불인정
    // - 상시: 2025-03 ~ 2026-02 월별(최대 11로 캡)
    // - 비상시: 학기월(3~6,9~11) + 여름방학(7~8) 1 + 겨울방학(12~2) 1 → 최대 9
    const dailyHours = Number(w.dailyHours || DEFAULT_DAILY_HOURS);
    const dailyMinutes = dailyHours * 60;

    const workerRecords = state.records.filter(r => r.workerKey === w.key && recordClass(r) === "absence");
    const sets = state.calendar.sets;

    const absenceDates = new Set();

    // 결근성 기록의 날짜를 수집(토요일 제외)
    for (const r of workerRecords) {
      for (let d = r.startUTC; d <= r.endUTC; d = addDaysUTC(d, 1)) {
        if (isSaturdayUTC(d)) continue;
        const ymd = utcToYmd(d);
        if (!sets || sets.fullSet.has(ymd)) absenceDates.add(ymd);
      }
    }

    if (w.pattern !== "emergency") {
      // 상시: 월별
      const months = enumerateMonths(PERIOD_START, PERIOD_END);
      let okCount = 0;
      const okMonths = [];

      for (const ym of months) {
        // 해당 월에 결근성 날짜가 하나라도 있으면 미개근
        const hasAbs = anyAbsenceInMonth(absenceDates, ym);
        if (!hasAbs) { okCount += 1; okMonths.push(ym); }
      }

      const capped = Math.min(11, okCount); // 상시 최대 11(사용자 정리 반영)
      return {
        days: capped,
        hours: 0,
        note: `개근월수(상시): ${okCount}개월 중 ${capped}일(최대11) 부여`
      };
    }

    // 비상시: 9 버킷(학기월 7 + 방학2)
    // 학기월: 2025-03,04,05,06,09,10,11
    const bucketMonths = ["2025-03","2025-04","2025-05","2025-06","2025-09","2025-10","2025-11"];
    let ok = 0;

    // 학기월
    for (const ym of bucketMonths) {
      const hasAbs = anyAbsenceInMonth(absenceDates, ym);
      if (!hasAbs) ok += 1;
    }

    // 여름방학 버킷(7~8): 방학기간에 결근성 있으면 미개근 처리(실무상 거의 없지만 방어)
    const hasSummerAbs = anyAbsenceInVacation(absenceDates, "summer");
    if (!hasSummerAbs) ok += 1;

    // 겨울방학 버킷(12~2)
    const hasWinterAbs = anyAbsenceInVacation(absenceDates, "winter");
    if (!hasWinterAbs) ok += 1;

    const capped = Math.min(9, ok);
    return {
      days: capped,
      hours: 0,
      note: `개근월수(비상시): 버킷 ${ok}개 중 ${capped}일(최대9) 부여`
    };
  }

  function enumerateMonths(startUTC, endUTC) {
    const res = [];
    let y = startUTC.getUTCFullYear();
    let m = startUTC.getUTCMonth() + 1;
    const ey = endUTC.getUTCFullYear();
    const em = endUTC.getUTCMonth() + 1;

    while (y < ey || (y === ey && m <= em)) {
      res.push(`${y}-${String(m).padStart(2,"0")}`);
      m += 1;
      if (m === 13) { m = 1; y += 1; }
    }
    return res;
  }

  function anyAbsenceInMonth(absenceDates, ym) {
    for (const ymd of absenceDates) {
      if (ymd.startsWith(ym + "-")) return true;
    }
    return false;
  }

  function anyAbsenceInVacation(absenceDates, which) {
    const sets = state.calendar.sets;
    if (!sets) return false;

    const targetSet = sets.vacationSet;
    // which 구분은 현재 별도 사용 안 하고 vacationSet 전체로 판단
    for (const ymd of absenceDates) {
      if (targetSet.has(ymd)) return true;
    }
    return false;
  }

  /** ---------------------------
   *  Rendering Results
   *  --------------------------- */
  function renderResults() {
    const tbody = $("#resultTable tbody");
    tbody.innerHTML = "";

    if (!state.results || state.results.length === 0) {
      setMsg($("#resultSummary"), "warn", "계산 결과가 없습니다. <b>계산 실행</b>을 먼저 수행하세요.");
      $("#detailBox").innerHTML = "";
      return;
    }

    const resArr = state.results.slice().sort((a,b) => {
      const wa = state.workers.get(a.workerKey);
      const wb = state.workers.get(b.workerKey);
      return (wa?.name || "").localeCompare(wb?.name || "", "ko");
    });

    setMsg($("#resultSummary"), "ok", `
      <div><b>계산 완료</b> · 대상자 ${resArr.length}명 · 실행시각: ${escapeHtml(new Date(state.lastRunAt).toLocaleString())}</div>
      <div class="muted">※ 상세에서 복무 자동분류를 <b>최종분류로 수정</b>하면 즉시 재계산됩니다.</div>
    `);

    for (const r of resArr) {
      const w = state.workers.get(r.workerKey);
      const rateSem = (r.rates.rateSemester == null) ? "-" : pct(r.rates.rateSemester);
      const rateFull = pct(r.rates.rateFull ?? 0);
      const rateRe = (r.rates.rateRecalcSemester == null)
        ? (r.rates.rateRecalcFull == null ? "-" : pct(r.rates.rateRecalcFull))
        : pct(r.rates.rateRecalcSemester);

      const std = `${r.baseDays}+${r.addDays}=${r.standardDays}`;
      const final = (r.finalHours > 0) ? `${r.finalDays}일 ${r.finalHours}시간` : `${r.finalDays}일`;

      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td class="nowrap">${escapeHtml(w?.key || r.workerKey)}</td>
        <td class="nowrap">${escapeHtml(w?.name || "")}</td>
        <td class="nowrap">${w?.group==="special" ? "특수운영" : "교육공무직"}</td>
        <td class="nowrap">${w?.pattern==="emergency" ? "비상시" : "상시"}</td>
        <td class="right nowrap">${escapeHtml(String(w?.serviceYears ?? 0))}년</td>
        <td class="right nowrap">${rateSem}</td>
        <td class="right nowrap">${rateFull}</td>
        <td class="right nowrap">${rateRe}</td>
        <td class="right nowrap">${std}</td>
        <td class="right nowrap"><b>${final}</b></td>
        <td class="nowrap">${escapeHtml(r.method)}</td>
      `;
      tbody.appendChild(tr);
    }

    renderDetail();
  }

  function pct(x) {
    return (x * 100).toFixed(1) + "%";
  }

  function renderDetail() {
    const box = $("#detailBox");
    box.innerHTML = "";

    const resArr = state.results.slice().sort((a,b) => {
      const wa = state.workers.get(a.workerKey);
      const wb = state.workers.get(b.workerKey);
      return (wa?.name || "").localeCompare(wb?.name || "", "ko");
    });

    for (const rr of resArr) {
      const w = state.workers.get(rr.workerKey);
      const records = state.records.filter(x => x.workerKey === rr.workerKey)
        .sort((a,b) => a.startUTC - b.startUTC);

      const sets = state.calendar.sets;
      const dailyMinutes = rr.rates.dailyMinutes || (Number(w?.dailyHours||DEFAULT_DAILY_HOURS)*60);

      // 분류별 합계(연간 기준으로 표시)
      const sum = { deemed:0, excluded:0, absence:0, review:0, creditVac:0, total:0 };
      if (sets) sum.total = sets.fullCount * dailyMinutes;

      for (const rec of records) {
        const cls = recordClass(rec);
        const mFull = sets ? computeRecordMinutesOnSet(rec, sets.fullSet, dailyMinutes) : 0;
        sum[cls] = (sum[cls] || 0) + mFull;

        if (rec.credit && sets) {
          sum.creditVac += computeRecordMinutesOnSet(rec, sets.vacationSet, dailyMinutes);
        }
      }

      const rateSem = (rr.rates.rateSemester == null) ? "-" : pct(rr.rates.rateSemester);
      const rateFull = pct(rr.rates.rateFull ?? 0);
      const rateRe = (rr.rates.rateRecalcSemester == null)
        ? (rr.rates.rateRecalcFull == null ? "-" : pct(rr.rates.rateRecalcFull))
        : pct(rr.rates.rateRecalcSemester);

      const final = (rr.finalHours > 0) ? `${rr.finalDays}일 ${rr.finalHours}시간` : `${rr.finalDays}일`;
      const std = `${rr.baseDays}+${rr.addDays}=${rr.standardDays}`;

      const details = document.createElement("details");
      details.className = "card";
      details.open = false;

      details.innerHTML = `
        <summary>
          ${escapeHtml(w?.name || rr.workerKey)} (${escapeHtml(w?.key || rr.workerKey)})
          · <span class="pill">${w?.group==="special" ? "특수운영" : "교육공무직"}</span>
          · <span class="pill">${w?.pattern==="emergency" ? "비상시" : "상시"}</span>
          · 최종 <b>${final}</b> (${escapeHtml(rr.method)})
        </summary>

        <div style="margin-top:12px;" class="grid two">
          <div class="msg">
            <div><b>기본/가산</b>: ${std} (상한 25 적용)</div>
            <div><b>근속</b>: ${escapeHtml(String(w?.serviceYears ?? 0))}년 (기준일 2026-03-01)</div>
            <div><b>출근율</b>:
              학기 ${rateSem} · 연간 ${rateFull} · 재산정 ${rateRe}
            </div>
            ${rr.note ? `<div class="muted">※ ${escapeHtml(rr.note)}</div>` : ""}
          </div>

          <div class="msg">
            <div><b>복무 분류 합계(연간 기준)</b></div>
            <ul>
              <li>산정제외: ${minutesToDays(sum.excluded, dailyMinutes)}</li>
              <li>결근성: ${minutesToDays(sum.absence, dailyMinutes)}</li>
              <li>출근간주: ${minutesToDays(sum.deemed, dailyMinutes)} <span class="muted">(정보성)</span></li>
              <li>검토: ${minutesToDays(sum.review, dailyMinutes)}</li>
              ${w?.pattern==="emergency" ? `<li>방학근무크레딧(분자 가산): ${minutesToDays(sum.creditVac, dailyMinutes)}</li>` : ""}
            </ul>
            <div class="muted">※ 자동 분류는 보수적으로 동작합니다. 애매한 항목은 검토로 남깁니다.</div>
          </div>
        </div>

        <hr />

        <div class="msg warn">
          <div><b>행정 검토 포인트</b></div>
          <ul>
            <li>검토(확인 필요)로 분류된 항목은 실제 유급/무급 및 산정 반영 여부를 확인하세요.</li>
            <li>비상시근로자의 방학근무크레딧은 “방학기간과 겹치는 유급근무”만 체크 권장.</li>
          </ul>
        </div>

        <h4>복무 전체 목록(최종분류 수정 가능)</h4>
        <div class="table-wrap">
          <table class="sheetlike table-compact">
            <thead>
              <tr>
                <th class="nowrap">기간</th>
                <th class="nowrap">종별</th>
                <th class="nowrap">사유</th>
                <th class="nowrap">자동</th>
                <th class="nowrap">최종</th>
                <th class="nowrap">방학크레딧</th>
                <th class="nowrap center">삭제</th>
              </tr>
            </thead>
            <tbody>
              ${records.map(rec => renderRecordRow(rec)).join("")}
            </tbody>
          </table>
        </div>
      `;

      box.appendChild(details);
    }

    // 이벤트 바인딩(최종분류/크레딧/삭제)
    box.querySelectorAll("[data-rec-id]").forEach(el => {
      const rid = el.getAttribute("data-rec-id");
      const field = el.getAttribute("data-field");

      if (field === "finalClass") {
        el.addEventListener("change", () => {
          const rec = state.records.find(x => x.id === rid);
          if (!rec) return;
          const v = el.value;
          rec.finalClass = (v === "auto") ? null : v;
          runCalculation(); // 수정 즉시 재계산
        });
      }

      if (field === "credit") {
        el.addEventListener("change", () => {
          const rec = state.records.find(x => x.id === rid);
          if (!rec) return;
          rec.credit = !!el.checked;
          runCalculation();
        });
      }

      if (field === "delete") {
        el.addEventListener("click", () => {
          state.records = state.records.filter(x => x.id !== rid);
          runCalculation();
        });
      }
    });
  }

  function minutesToDays(mins, dailyMinutes) {
    const days = (mins / dailyMinutes);
    const rounded = Math.round(days * 10) / 10;
    const dh = daysToDaysHours(rounded, dailyMinutes/60);
    return (dh.hours > 0) ? `${dh.days}일 ${dh.hours}시간` : `${dh.days}일`;
  }

  function renderRecordRow(rec) {
    const auto = rec.autoClass || "review";
    const fin = rec.finalClass || "auto";
    const range = `${utcToYmd(rec.startUTC)} ~ ${utcToYmd(rec.endUTC)}`;
    const opt = (value, label) => `<option value="${value}" ${fin===value ? "selected":""}>${label}</option>`;

    return `
      <tr>
        <td class="nowrap">${escapeHtml(range)}</td>
        <td class="nowrap">${escapeHtml(rec.type || "")}</td>
        <td class="nowrap">${escapeHtml(rec.reason || "")}</td>
        <td class="nowrap">${escapeHtml(CLASS_LABEL[auto] || auto)}</td>
        <td class="nowrap">
          <select data-rec-id="${rec.id}" data-field="finalClass">
            ${opt("auto","자동(기본)") }
            ${opt("deemed","출근간주") }
            ${opt("excluded","산정제외") }
            ${opt("absence","결근성") }
            ${opt("review","검토") }
          </select>
        </td>
        <td class="center nowrap">
          <input type="checkbox" data-rec-id="${rec.id}" data-field="credit" ${rec.credit ? "checked":""} />
        </td>
        <td class="center nowrap">
          <button class="btn btn-lightgrey" data-rec-id="${rec.id}" data-field="delete">삭제</button>
        </td>
      </tr>
    `;
  }

  /** ---------------------------
   *  XLSX Parsing (파일 업로드 모드)
   *  - 인사기록, 근무상황목록은 양식이 조금씩 달라서 "헤더 후보 탐색" 방식으로 구현
   *  --------------------------- */

  function ensureXLSX() {
    if (typeof XLSX === "undefined") {
      throw new Error("XLSX 라이브러리를 찾을 수 없습니다. (CDN 차단 여부 확인 필요)");
    }
  }

  function readFileAsArrayBuffer(file) {
    return new Promise((resolve, reject) => {
      const fr = new FileReader();
      fr.onload = () => resolve(fr.result);
      fr.onerror = () => reject(new Error("파일 읽기 실패"));
      fr.readAsArrayBuffer(file);
    });
  }

  function sheetToJson(workbook) {
    // 첫번째 시트를 기본 사용
    const sheetName = workbook.SheetNames[0];
    const ws = workbook.Sheets[sheetName];
    return XLSX.utils.sheet_to_json(ws, { header: 1, raw: false, defval: "" }); // 2D array
  }

  function normalizeHeader(s) {
    return String(s || "").replace(/\s+/g, "").replace(/[()]/g, "").toLowerCase();
  }

  function findHeaderRow(rows, mustHaveAny) {
    // mustHaveAny: ["성명","이름"] 같은 키워드 중 하나라도 포함되면 후보
    let bestIdx = -1;
    let bestScore = -1;

    for (let i = 0; i < Math.min(rows.length, 30); i++) {
      const row = rows[i];
      if (!Array.isArray(row)) continue;

      const nh = row.map(normalizeHeader);
      const joined = nh.join("|");

      const hit = mustHaveAny.some(k => joined.includes(normalizeHeader(k)));
      if (!hit) continue;

      // 점수: 유효한 헤더 셀 개수
      const score = nh.filter(x => x && x.length >= 2).length;
      if (score > bestScore) {
        bestScore = score;
        bestIdx = i;
      }
    }
    return bestIdx;
  }

  function findColumnIndex(headers, candidates) {
    const nh = headers.map(normalizeHeader);
    for (const c of candidates) {
      const nc = normalizeHeader(c);
      const idx = nh.findIndex(h => h === nc);
      if (idx >= 0) return idx;
    }
    // includes 매칭
    for (const c of candidates) {
      const nc = normalizeHeader(c);
      const idx = nh.findIndex(h => h.includes(nc) || nc.includes(h));
      if (idx >= 0) return idx;
    }
    return -1;
  }

  function parseDateLoose(v) {
    const s = String(v || "").trim();
    if (!s) return null;

    // 2025-03-01, 2025.03.01, 2025/03/01 지원
    const m = s.match(/(\d{4})[.\-/](\d{1,2})[.\-/](\d{1,2})/);
    if (m) {
      const y = Number(m[1]);
      const mo = Number(m[2]);
      const d = Number(m[3]);
      return new Date(Date.UTC(y, mo - 1, d));
    }
    return null;
  }

  async function loadHrFile(file) {
    ensureXLSX();
    const buf = await readFileAsArrayBuffer(file);
    const wb = XLSX.read(buf, { type: "array" });
    const rows = sheetToJson(wb);

    // 헤더 행 탐색
    const headerIdx = findHeaderRow(rows, ["성명", "이름", "직종", "근무"]);
    if (headerIdx < 0) throw new Error("인사기록 파일에서 헤더 행을 찾지 못했습니다. (양식 확인 필요)");

    const headers = rows[headerIdx].map(x => String(x || "").trim());
    const dataRows = rows.slice(headerIdx + 1).filter(r => Array.isArray(r) && r.some(x => String(x||"").trim() !== ""));

    // 컬럼 매핑(보수적)
    const colName = findColumnIndex(headers, ["성명","이름"]);
    const colPid  = findColumnIndex(headers, ["개인번호","사번","인적번호","개인번호(아이디)"]);
    const colHire = findColumnIndex(headers, ["최초임용일","근무시작일","임용일","현소속교육청근무일","최초계약일","계약시작일"]);
    const colGroup = findColumnIndex(headers, ["직군","직군구분","직종구분","구분"]);
    const colJob = findColumnIndex(headers, ["직종","직종명"]);
    const colPattern = findColumnIndex(headers, ["근무형태","근무형태명","근무구분","근무유형"]);
    const colDailyH = findColumnIndex(headers, ["1일근로시간","일근로시간","1일소정근로시간"]);
    const colWeeklyH = findColumnIndex(headers, ["주소정근로시간","주당근로시간","주근무시간"]);

    if (colName < 0) throw new Error("인사기록 파일에서 [성명] 컬럼을 찾지 못했습니다.");

    let loaded = 0;
    let skipped = 0;

    for (const row of dataRows) {
      const name = String(row[colName] || "").trim();
      if (!name) { skipped++; continue; }

      const pid = (colPid >= 0) ? String(row[colPid] || "").trim() : "";
      const hire = (colHire >= 0) ? parseDateLoose(row[colHire]) : null;

      // 직군(특수운영직군 여부) 추정
      const groupRaw = (colGroup >= 0) ? String(row[colGroup] || "").trim() : "";
      const jobRaw = (colJob >= 0) ? String(row[colJob] || "").trim() : "";
      const group = (groupRaw.includes("특수") || jobRaw.includes("특수")) ? "special" : "regular";

      // 근무형태(상시/비상시) 추정
      const patRaw = (colPattern >= 0) ? String(row[colPattern] || "").trim() : "";
      const pattern = (patRaw.includes("비상") || patRaw.includes("방학") || patRaw.includes("비근무")) ? "emergency" : "always";

      // 1일시간 추정
      let dailyHours = DEFAULT_DAILY_HOURS;
      if (colDailyH >= 0) {
        const v = Number(String(row[colDailyH]).replace(/[^0-9.]/g, ""));
        if (Number.isFinite(v) && v > 0) dailyHours = v;
      } else if (colWeeklyH >= 0) {
        const v = Number(String(row[colWeeklyH]).replace(/[^0-9.]/g, ""));
        if (Number.isFinite(v) && v > 0) {
          // 주40시간이면 8시간으로 환산 (단순)
          dailyHours = Math.round((v / 5) * 10) / 10;
        }
      }

      addOrUpdateWorker({
        key: workerKeyOf(name, pid),
        name, pid,
        group,
        pattern,
        hireDateUTC: hire,
        dailyHours
      });

      loaded++;
    }

    renderWorkersTable();
    renderWorkerSelect();

    return { loaded, skipped, headers };
  }

  async function loadWorkFiles(files) {
    ensureXLSX();
    if (!files || files.length === 0) throw new Error("근무상황 파일이 선택되지 않았습니다.");

    let totalRecs = 0;
    let createdWorkers = 0;

    for (const file of files) {
      const ext = (file.name.split(".").pop() || "").toLowerCase();

      if (ext === "csv") {
        const text = await file.text();
        const rows = csvToRows(text);
        const { recs, newWorkers } = parseWorkRows(rows, file.name);
        totalRecs += recs;
        createdWorkers += newWorkers;
        continue;
      }

      const buf = await readFileAsArrayBuffer(file);
      const wb = XLSX.read(buf, { type: "array" });
      const rows = sheetToJson(wb);
      const { recs, newWorkers } = parseWorkRows(rows, file.name);
      totalRecs += recs;
      createdWorkers += newWorkers;
    }

    renderWorkersTable();
    renderWorkerSelect();

    return { totalRecs, createdWorkers };
  }

  function csvToRows(text) {
    // 단순 CSV 파서(따옴표 일부 지원)
    const lines = text.split(/\r?\n/).filter(x => x.trim() !== "");
    return lines.map(line => parseCsvLine(line));
  }

  function parseCsvLine(line) {
    const res = [];
    let cur = "";
    let inQ = false;

    for (let i = 0; i < line.length; i++) {
      const ch = line[i];
      if (ch === '"' ) {
        if (inQ && line[i+1] === '"') { cur += '"'; i++; continue; }
        inQ = !inQ; continue;
      }
      if (ch === "," && !inQ) { res.push(cur); cur = ""; continue; }
      cur += ch;
    }
    res.push(cur);
    return res;
  }

  function parseWorkRows(rows, filename) {
    // 근무상황목록은 양식 편차가 크므로 "필수 헤더(성명/기간/종별)"가 있는 행을 헤더로 찾는다.
    const headerIdx = findHeaderRow(rows, ["성명", "기간", "종별", "근무", "복무"]);
    if (headerIdx < 0) throw new Error(`[${filename}] 헤더 행을 찾지 못했습니다.`);

    const headers = rows[headerIdx].map(x => String(x||"").trim());
    const dataRows = rows.slice(headerIdx + 1).filter(r => Array.isArray(r) && r.some(x => String(x||"").trim() !== ""));

    const colName = findColumnIndex(headers, ["성명","이름"]);
    const colPid  = findColumnIndex(headers, ["개인번호","사번","인적번호"]);
    const colType = findColumnIndex(headers, ["종별","복무종별","근무상황","근태종류","복무구분"]);
    const colReason = findColumnIndex(headers, ["사유","상세사유","용무","비고"]);
    const colStart = findColumnIndex(headers, ["시작일","시작","from","시작일자"]);
    const colEnd   = findColumnIndex(headers, ["종료일","종료","to","종료일자"]);
    const colRange = findColumnIndex(headers, ["기간","일시","기간(일시)"]);
    const colMinutes = findColumnIndex(headers, ["시간","분","사용시간","근무시간","일수","기간(일수)"]);

    if (colName < 0) throw new Error(`[${filename}] 성명 컬럼을 찾지 못했습니다.`);
    if (colType < 0 && colRange < 0) throw new Error(`[${filename}] 종별/기간 컬럼을 찾지 못했습니다.`);

    let recs = 0;
    let newWorkers = 0;

    for (const row of dataRows) {
      const nameRaw = String(row[colName] || "").trim();
      if (!nameRaw) continue;

      // "홍길동 (K123...)" 형태면 pid 추출
      let name = nameRaw;
      let pidFromName = "";
      const m = nameRaw.match(/\((K[0-9A-Za-z]+)\)/);
      if (m) pidFromName = m[1];
      name = nameRaw.replace(/\(.*?\)/g, "").trim();

      const pid = (colPid >= 0 ? String(row[colPid]||"").trim() : "") || pidFromName;
      const key = workerKeyOf(name, pid);

      if (!state.workers.has(key)) {
        // 인사파일이 없는 경우를 대비해 임시 대상자 생성(최소값)
        addOrUpdateWorker({
          key,
          name,
          pid,
          group: "regular",
          pattern: "always",
          hireDateUTC: null,
          dailyHours: DEFAULT_DAILY_HOURS
        });
        newWorkers++;
      }

      // 기간/시작/종료 파싱
      let start = null, end = null;

      if (colRange >= 0) {
        const rangeStr = String(row[colRange] || "").trim();
        const parsed = parseRangeLoose(rangeStr);
        if (parsed) { start = parsed.start; end = parsed.end; }
      }

      if ((!start || !end) && colStart >= 0 && colEnd >= 0) {
        const s = parseDateLoose(row[colStart]);
        const e = parseDateLoose(row[colEnd]);
        if (s && e) { start = s; end = e; }
      }

      // 단일 일자만 있는 경우 보정
      if (!start && colStart >= 0) start = parseDateLoose(row[colStart]);
      if (!end && colEnd >= 0) end = parseDateLoose(row[colEnd]);
      if (start && !end) end = start;
      if (end && !start) start = end;

      if (!start || !end) continue;

      const type = (colType >= 0) ? String(row[colType] || "").trim() : "";
      const reason = (colReason >= 0) ? String(row[colReason] || "").trim() : "";

      // minutes 파싱(가능하면)
      let minutes = null;
      if (colMinutes >= 0) {
        minutes = parseMinutesLoose(row[colMinutes]);
      }

      // credit는 방학+키워드로 기본 추정
      addRecord({
        workerKey: key,
        startUTC: start,
        endUTC: end,
        type,
        reason,
        minutes,
        credit: false
      });
      recs++;
    }

    return { recs, newWorkers };
  }

  function parseRangeLoose(s) {
    // "2025-03-01 ~ 2025-03-05" / "2025.03.01~2025.03.05" 등
    const str = String(s||"").trim();
    if (!str) return null;
    const parts = str.split("~").map(x => x.trim());
    if (parts.length === 2) {
      const a = parseDateLoose(parts[0]);
      const b = parseDateLoose(parts[1]);
      if (a && b) return { start: a, end: b };
    }
    // 단일 날짜
    const d = parseDateLoose(str);
    if (d) return { start: d, end: d };
    return null;
  }

  function parseMinutesLoose(v) {
    const s = String(v||"").trim();
    if (!s) return null;

    // "1일 2시간 30분", "2시간", "30분", "1.5" 등
    let days = 0, hours = 0, mins = 0;

    const md = s.match(/(\d+(?:\.\d+)?)\s*일/);
    const mh = s.match(/(\d+(?:\.\d+)?)\s*시간/);
    const mm = s.match(/(\d+(?:\.\d+)?)\s*분/);

    if (md) days = Number(md[1]);
    if (mh) hours = Number(mh[1]);
    if (mm) mins = Number(mm[1]);

    if (md || mh || mm) {
      return Math.round(days * 24 * 60 + hours * 60 + mins);
    }

    // 숫자만 있으면 "일수"로 들어오는 케이스가 있어 보수적으로 minutes는 null 처리
    return null;
  }

  /** ---------------------------
   *  Run & Download
   *  --------------------------- */
  function runCalculation() {
    // 사전 체크
    if (!state.calendar.sets) buildCalendarSets();

    const workers = Array.from(state.workers.values());
    if (workers.length === 0) {
      setMsg($("#runMsg"), "err", "대상자가 없습니다. 인사정보(파일 또는 수기)를 먼저 입력하세요.");
      state.results = [];
      renderResults();
      return;
    }

    // 비상시가 존재하는데 방학 입력이 없으면 경고
    const hasEmergency = workers.some(w => w.pattern === "emergency");
    if (hasEmergency && !state.calendar.applied) {
      setMsg($("#runMsg"), "warn", `
        <div class="warn-line">
          <b>경고</b>: 비상시근로자가 포함되어 있으나 학사일정(방학)이 적용되지 않았습니다.<br/>
          비상시 출근율(학기/연간) 및 방학근무크레딧 판정 정확도가 저하될 수 있습니다.
        </div>
      `);
    } else {
      setMsg($("#runMsg"), "ok", "계산을 수행합니다.");
    }

    state.results = workers.map(w => calcGrantForWorker(w));
    state.lastRunAt = Date.now();

    renderResults();
  }

  function downloadXlsx() {
    ensureXLSX();

    if (!state.results || state.results.length === 0) {
      alert("계산 결과가 없습니다. 먼저 계산 실행을 수행하세요.");
      return;
    }

    const wb = XLSX.utils.book_new();

    // 결과 시트
    const rows1 = [];
    rows1.push([
      "키","성명","직군","근무형태","최초임용일","근속(2026-03-01)",
      "출근율(학기)","출근율(연간)","출근율(재산정)",
      "기본","가산","표준합계(상한적용)",
      "최종부여(일)","최종부여(시간)","판정","비고"
    ]);

    for (const r of state.results) {
      const w = state.workers.get(r.workerKey);
      rows1.push([
        w?.key || r.workerKey,
        w?.name || "",
        w?.group==="special" ? "특수운영직군" : "교육공무직",
        w?.pattern==="emergency" ? "방학중비상시" : "상시",
        w?.hireDateUTC ? utcToYmd(w.hireDateUTC) : "",
        w?.serviceYears ?? 0,
        r.rates.rateSemester==null ? "" : pctValue(r.rates.rateSemester),
        pctValue(r.rates.rateFull ?? 0),
        r.rates.rateRecalcSemester==null
          ? (r.rates.rateRecalcFull==null ? "" : pctValue(r.rates.rateRecalcFull))
          : pctValue(r.rates.rateRecalcSemester),
        r.baseDays,
        r.addDays,
        r.standardDays,
        r.finalDays,
        r.finalHours,
        r.method,
        r.note || ""
      ]);
    }

    const ws1 = XLSX.utils.aoa_to_sheet(rows1);
    XLSX.utils.book_append_sheet(wb, ws1, "연차부여결과");

    // 복무 전체 시트
    const rows2 = [];
    rows2.push([
      "키","성명","기간시작","기간종료","종별","사유","자동분류","최종분류","방학크레딧"
    ]);

    for (const rec of state.records) {
      const w = state.workers.get(rec.workerKey);
      const auto = rec.autoClass || "review";
      const fin = rec.finalClass || "auto";
      rows2.push([
        rec.workerKey,
        w?.name || "",
        utcToYmd(rec.startUTC),
        utcToYmd(rec.endUTC),
        rec.type || "",
        rec.reason || "",
        CLASS_LABEL[auto] || auto,
        fin === "auto" ? "자동" : (CLASS_LABEL[fin] || fin),
        rec.credit ? "Y" : ""
      ]);
    }

    const ws2 = XLSX.utils.aoa_to_sheet(rows2);
    XLSX.utils.book_append_sheet(wb, ws2, "복무취합(전체)");

    const out = XLSX.write(wb, { bookType: "xlsx", type: "array" });
    const blob = new Blob([out], { type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" });

    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "2026학년도_연차부여결과.xlsx";
    document.body.appendChild(a);
    a.click();
    a.remove();
  }

  function pctValue(x) {
    return (x * 100).toFixed(1) + "%";
  }

  /** ---------------------------
   *  LocalStorage
   *  --------------------------- */
  const LS_KEY = "annualLeave2026_state_v1";

  function saveLocal() {
    const payload = {
      calendar: {
        summerStart: state.calendar.summerStart ? utcToYmd(state.calendar.summerStart) : null,
        summerEnd: state.calendar.summerEnd ? utcToYmd(state.calendar.summerEnd) : null,
        winterStart: state.calendar.winterStart ? utcToYmd(state.calendar.winterStart) : null,
        winterEnd: state.calendar.winterEnd ? utcToYmd(state.calendar.winterEnd) : null,
        applied: state.calendar.applied
      },
      workers: Array.from(state.workers.values()).map(w => ({
        key: w.key, name: w.name, pid: w.pid,
        group: w.group, pattern: w.pattern,
        hireDate: w.hireDateUTC ? utcToYmd(w.hireDateUTC) : null,
        dailyHours: w.dailyHours
      })),
      records: state.records.map(r => ({
        id: r.id,
        workerKey: r.workerKey,
        start: utcToYmd(r.startUTC),
        end: utcToYmd(r.endUTC),
        type: r.type,
        reason: r.reason,
        minutes: r.minutes,
        autoClass: r.autoClass,
        finalClass: r.finalClass,
        credit: r.credit
      }))
    };

    localStorage.setItem(LS_KEY, JSON.stringify(payload));
    alert("로컬 저장 완료");
  }

  function loadLocal() {
    const raw = localStorage.getItem(LS_KEY);
    if (!raw) { alert("저장된 데이터가 없습니다."); return; }

    const p = JSON.parse(raw);

    // calendar
    state.calendar.summerStart = p.calendar.summerStart ? ymdToUTC(p.calendar.summerStart) : null;
    state.calendar.summerEnd   = p.calendar.summerEnd ? ymdToUTC(p.calendar.summerEnd) : null;
    state.calendar.winterStart = p.calendar.winterStart ? ymdToUTC(p.calendar.winterStart) : null;
    state.calendar.winterEnd   = p.calendar.winterEnd ? ymdToUTC(p.calendar.winterEnd) : null;
    state.calendar.applied = !!p.calendar.applied;

    if (state.calendar.applied) {
      buildCalendarSets();
      renderCalendarSummary();
      // inputs 반영
      $("#summerStart").value = p.calendar.summerStart || "";
      $("#summerEnd").value = p.calendar.summerEnd || "";
      $("#winterStart").value = p.calendar.winterStart || "";
      $("#winterEnd").value = p.calendar.winterEnd || "";
    }

    // workers
    state.workers.clear();
    for (const w of (p.workers || [])) {
      addOrUpdateWorker({
        key: w.key, name: w.name, pid: w.pid,
        group: w.group, pattern: w.pattern,
        hireDateUTC: w.hireDate ? ymdToUTC(w.hireDate) : null,
        dailyHours: w.dailyHours
      });
    }

    // records
    state.records = [];
    for (const r of (p.records || [])) {
      state.records.push({
        id: r.id,
        workerKey: r.workerKey,
        startUTC: ymdToUTC(r.start),
        endUTC: ymdToUTC(r.end),
        type: r.type,
        reason: r.reason,
        minutes: r.minutes ?? null,
        autoClass: r.autoClass || autoClassify(r.type, r.reason),
        finalClass: r.finalClass || null,
        credit: !!r.credit
      });
    }

    renderWorkersTable();
    renderWorkerSelect();
    runCalculation();
    alert("로컬 불러오기 완료");
  }

  /** ---------------------------
   *  UI Events
   *  --------------------------- */
  function bindEvents() {
    // calendar
    $("#btnApplyCalendar").addEventListener("click", () => {
      state.calendar.summerStart = $("#summerStart").value ? ymdToUTC($("#summerStart").value) : null;
      state.calendar.summerEnd   = $("#summerEnd").value ? ymdToUTC($("#summerEnd").value) : null;
      state.calendar.winterStart = $("#winterStart").value ? ymdToUTC($("#winterStart").value) : null;
      state.calendar.winterEnd   = $("#winterEnd").value ? ymdToUTC($("#winterEnd").value) : null;

      buildCalendarSets();
      state.calendar.applied = true;
      renderCalendarSummary();
    });

    $("#btnSetExampleCalendar").addEventListener("click", () => {
      // 테스트용: 임의 입력(학교별로 반드시 수정)
      $("#summerStart").value = "2025-07-21";
      $("#summerEnd").value = "2025-08-20";
      $("#winterStart").value = "2025-12-26";
      $("#winterEnd").value = "2026-02-06";
      $("#btnApplyCalendar").click();
    });

    // hr mode toggle
    $$("input[name='hrMode']").forEach(r => {
      r.addEventListener("change", () => {
        const mode = $$("input[name='hrMode']").find(x => x.checked)?.value;
        $("#hrFileBox").classList.toggle("hidden", mode !== "file");
        $("#hrManualBox").classList.toggle("hidden", mode !== "manual");
      });
    });

    // work mode toggle
    $$("input[name='workMode']").forEach(r => {
      r.addEventListener("change", () => {
        const mode = $$("input[name='workMode']").find(x => x.checked)?.value;
        $("#workFileBox").classList.toggle("hidden", mode !== "file");
        $("#workManualBox").classList.toggle("hidden", mode !== "manual");
      });
    });

    // HR file load
    $("#btnLoadHr").addEventListener("click", async () => {
      const f = $("#hrFile").files?.[0];
      if (!f) { setMsg($("#hrMsg"), "err", "인사파일을 선택하세요."); return; }

      try {
        const out = await loadHrFile(f);
        setMsg($("#hrMsg"), "ok", `
          <div><b>인사파일 불러오기 완료</b></div>
          <ul>
            <li>로드: ${out.loaded}명</li>
          </ul>
          <div class="muted">※ 헤더 자동 탐색 방식이며, 양식 편차가 큰 경우 컬럼을 인식하지 못할 수 있습니다.</div>
        `);
      } catch (e) {
        setMsg($("#hrMsg"), "err", `<b>오류</b>: ${escapeHtml(e.message)}`);
      }
    });

    $("#btnClearHr").addEventListener("click", () => {
      state.workers.clear();
      state.records = [];
      state.results = [];
      renderWorkersTable();
      renderWorkerSelect();
      renderResults();
      setMsg($("#hrMsg"), "warn", "인사정보/근무상황/결과를 초기화했습니다.");
    });

    // HR manual add
    $("#btnAddWorker").addEventListener("click", () => {
      const name = $("#mName").value.trim();
      const pid = $("#mPid").value.trim();
      const hire = $("#mHire").value ? ymdToUTC($("#mHire").value) : null;
      const group = $("#mGroup").value;
      const pattern = $("#mPattern").value;
      const dailyHours = Number($("#mDailyHours").value || DEFAULT_DAILY_HOURS);

      if (!name) { setMsg($("#hrManualMsg"), "err", "성명은 필수입니다."); return; }
      if (!hire) { setMsg($("#hrManualMsg"), "err", "최초임용일은 필수입니다."); return; }

      addOrUpdateWorker({
        key: workerKeyOf(name, pid),
        name, pid,
        group, pattern,
        hireDateUTC: hire,
        dailyHours
      });

      $("#mName").value = "";
      $("#mPid").value = "";
      // hire는 보존(연속 입력 편의)

      renderWorkersTable();
      renderWorkerSelect();
      setMsg($("#hrManualMsg"), "ok", "대상자를 추가했습니다.");
    });

    $("#btnClearWorkers").addEventListener("click", () => {
      state.workers.clear();
      state.records = [];
      renderWorkersTable();
      renderWorkerSelect();
      setMsg($("#hrManualMsg"), "warn", "대상자/복무 데이터 전체 삭제 완료");
    });

    // Work file load
    $("#btnLoadWork").addEventListener("click", async () => {
      const files = $("#workFiles").files;
      if (!files || files.length === 0) { setMsg($("#workMsg"), "err", "근무상황 파일을 선택하세요."); return; }

      try {
        const out = await loadWorkFiles(Array.from(files));
        setMsg($("#workMsg"), "ok", `
          <div><b>근무상황 파일 불러오기 완료</b></div>
          <ul>
            <li>복무 레코드: ${out.totalRecs}건</li>
            <li>인사정보 미존재로 임시 생성된 대상자: ${out.createdWorkers}명</li>
          </ul>
          <div class="muted">※ 임시 대상자는 직군/근무형태/최초임용일 정보가 부족하므로, 필요 시 수기 보정하세요.</div>
        `);

        // 파일 업로드 후 즉시 계산까지는 자동 실행하지 않음(사용자 통제)
      } catch (e) {
        setMsg($("#workMsg"), "err", `<b>오류</b>: ${escapeHtml(e.message)}`);
      }
    });

    $("#btnClearWork").addEventListener("click", () => {
      state.records = [];
      state.results = [];
      renderResults();
      setMsg($("#workMsg"), "warn", "근무상황(복무) 데이터 초기화 완료");
    });

    // Work manual add record
    $("#btnAddRecord").addEventListener("click", () => {
      const wk = $("#wSelect").value;
      if (!wk) { setMsg($("#workManualMsg"), "err", "대상자 선택이 필요합니다."); return; }

      const s = $("#wStart").value ? ymdToUTC($("#wStart").value) : null;
      const e = $("#wEnd").value ? ymdToUTC($("#wEnd").value) : null;
      if (!s || !e) { setMsg($("#workManualMsg"), "err", "시작일/종료일은 필수입니다."); return; }

      const type = $("#wType").value.trim();
      const reason = $("#wReason").value.trim();
      const clsMode = $("#wClass").value;
      const credit = $("#wCredit").checked;

      try {
        addRecord({
          workerKey: wk,
          startUTC: s,
          endUTC: e,
          type,
          reason,
          finalClass: clsMode === "auto" ? null : clsMode,
          credit
        });
        setMsg($("#workManualMsg"), "ok", "복무 항목을 추가했습니다.");
        $("#wType").value = "";
        $("#wReason").value = "";
      } catch (err) {
        setMsg($("#workManualMsg"), "err", `<b>오류</b>: ${escapeHtml(err.message)}`);
      }
    });

    $("#btnClearManualRecords").addEventListener("click", () => {
      state.records = [];
      setMsg($("#workManualMsg"), "warn", "복무 수기 데이터 전체 삭제 완료");
    });

    // Run
    $("#btnRun").addEventListener("click", runCalculation);

    // Download
    $("#btnDownload").addEventListener("click", () => {
      try {
        downloadXlsx();
      } catch (e) {
        alert(e.message);
      }
    });

    // Local save/load
    $("#btnSaveLocal").addEventListener("click", saveLocal);
    $("#btnLoadLocal").addEventListener("click", loadLocal);
  }

  /** ---------------------------
   *  init
   *  --------------------------- */
  function init() {
    // 기본 메시지
    setMsg($("#hrMsg"), "", "인사정보 파일 업로드 또는 수기 입력을 선택하세요.");
    setMsg($("#workMsg"), "", "근무상황 파일 업로드 또는 수기 입력을 선택하세요.");
    setMsg($("#runMsg"), "", "대상자/복무 입력 후 계산 실행을 누르세요.");

    // 달력 초기 상태
    buildCalendarSets();
    renderCalendarSummary();

    // worker select
    renderWorkerSelect();

    // bind events
    bindEvents();

    // 최초 렌더
    renderWorkersTable();
    renderResults();
  }

  init();

})();
</script>
</body>
</html>
